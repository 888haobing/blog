{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/icarus/source/assets/avatar.png","path":"assets/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/assets/sparkling.ico","path":"assets/sparkling.ico","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/thumbnail.svg","path":"img/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1595865272667},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1595865272667},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1605625633992},{"_id":"themes/icarus/.travis.yml","hash":"0a96b9f82de11bd524a74a3de9a32fd6cd6a6b47","modified":1595865272670},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1595865272670},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1595865272671},{"_id":"themes/icarus/_config.post.yml","hash":"b65c28b08e441e48afe659961464fedd70b8a078","modified":1596129834725},{"_id":"themes/icarus/README.md","hash":"247ec8047ee3105d31099dd8e6ca498b6bff1336","modified":1605625633993},{"_id":"themes/icarus/_config.yml","hash":"dfa95dbe0d04b73895c2e22b60b4623b1265343c","modified":1596383975049},{"_id":"themes/icarus/package.json","hash":"6d0ac9679ad8b524a68f94e85946b805b003acd4","modified":1605625634018},{"_id":"source/categories/index.md","hash":"35714c9f7bfed4bad7d93cb3602aa1478d15eda6","modified":1595865272666},{"_id":"themes/icarus/.github/stale.yml","hash":"c508741a907d5dbfc5e48521d6038aecae113473","modified":1595865272670},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1605625633993},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1605625633994},{"_id":"themes/icarus/include/register.js","hash":"a974b56a1fbb254f1ae048cc2221363faaccec25","modified":1605625633995},{"_id":"themes/icarus/languages/de.yml","hash":"01d9c27c3c9224d8c58b1cf7099ef008b9411a45","modified":1605625634006},{"_id":"themes/icarus/languages/en.yml","hash":"1bdb74288808c4d306b46630860e586a1fcd88a7","modified":1605625634007},{"_id":"themes/icarus/languages/es.yml","hash":"48fe3d7d304239b5e5e93f63600093700d6f0fed","modified":1605625634007},{"_id":"themes/icarus/languages/fr.yml","hash":"14765cc6216b4af5a05341315c9f6ee54d636a78","modified":1605625634007},{"_id":"themes/icarus/languages/id.yml","hash":"c04fca89e536d539a8bf95980bff7dff79125ba3","modified":1605625634007},{"_id":"themes/icarus/languages/ja.yml","hash":"7568f246a21813527ccea8a1da72a9526aa2d233","modified":1605625634008},{"_id":"themes/icarus/languages/ko.yml","hash":"f2211a8ca1d73f05a1c931aa11accb4e34c483c4","modified":1605625634008},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"531b22c71fab8aae60ddc7599aaa5f46140cf2c1","modified":1605625634009},{"_id":"themes/icarus/languages/pl.yml","hash":"612639b0e0a15185c12eecfe3e8913b629ecdfdf","modified":1605625634008},{"_id":"themes/icarus/languages/ru.yml","hash":"bf784c6f31e8fb7ed78509468bddecd447c3b73b","modified":1605625634009},{"_id":"themes/icarus/languages/tr.yml","hash":"96d94f7a5d56b2682ae2792f0808139d4b950704","modified":1605625634009},{"_id":"themes/icarus/languages/vn.yml","hash":"64307bfa16d851334e2f37a29a84d644624c2060","modified":1605625634009},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"82ff607b1671b88d259d10b6ce8ca1bb05b2cff4","modified":1605625634009},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"92f8cf599ad06bb14f79f4806ac4c695f60044d7","modified":1605625634010},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1605625634010},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1595865272691},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1595865272691},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1595865272696},{"_id":"themes/icarus/layout/layout.jsx","hash":"a5829907b219e95266f7ed5ee6203e60e2273f93","modified":1605625634015},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1595865272697},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1595865272698},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1595865272699},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1595865272700},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1595865272701},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272691},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272696},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272697},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272699},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272699},{"_id":"source/_posts/fe/async-await和promise的一些区别.md","hash":"0f358b82f43dd2f3f5232cfcffb357e92ea2ad97","modified":1596306112859},{"_id":"source/_posts/fe/ios-safari何时才能更好的支持pwa.md","hash":"a3928cd7ef45ced3f2e33870b0a3e28ccd6fd2c3","modified":1596306112860},{"_id":"source/_posts/fe/http的缓存机制.md","hash":"164d549c9b5f788d0505dbddb6b1261091e3c942","modified":1596306112859},{"_id":"source/_posts/fe/http状态码.md","hash":"f23f451542f53c78f01111f7df2a8df32bac22c9","modified":1596306112859},{"_id":"source/_posts/fe/javascript-基础知识点总结.md","hash":"0c0a1f250850200c22cbfd82090190a7df74d99d","modified":1605622540852},{"_id":"source/_posts/fe/javascript的模块机制.md","hash":"30b1a326ce2c5c197c95cd5f463eb7da413a06af","modified":1596306112861},{"_id":"source/_posts/fe/javascript的原型链与继承.md","hash":"1200a59d1ecf77ea41921e81d50b54d4ecac0539","modified":1596306112861},{"_id":"source/_posts/fe/meta标签的使用.md","hash":"70fa6f956bcb54b6801e1a4784679d7cee91ea25","modified":1596306112863},{"_id":"source/_posts/fe/js中的异步链式调用.md","hash":"d51f56e03ba1041f25a24ba4965ef1b9e18ff793","modified":1596306112862},{"_id":"source/_posts/fe/javascript面向对象编程-es6版本.md","hash":"aa5228a2557f6fc171850b542ff1d8565cf2d87a","modified":1596306112862},{"_id":"source/_posts/fe/script标签有几种写法.md","hash":"77f013c67792abeb30c331eacb49d9f1a93ca897","modified":1596306112866},{"_id":"source/_posts/fe/react-组件中-state-和生命周期.md","hash":"e30cbd78529b5cad86ac9e5d660ce2ae21d0b137","modified":1596306112865},{"_id":"source/_posts/fe/speaking-javascript-阅读笔记-三.md","hash":"f3672637f78f25327f0f5f57883bc7b168845e6a","modified":1596306112867},{"_id":"source/_posts/fe/speaking-javascript-阅读笔记-二.md","hash":"73a924b0fd072d63e32080ac84ad887659f66068","modified":1596306112867},{"_id":"source/_posts/fe/speaking-javascript-阅读笔记-一.md","hash":"fa2e45a4ec136147c91a0650ead79bd8c3c83273","modified":1596306112866},{"_id":"source/_posts/fe/speaking-javascript-阅读笔记-附加篇.md","hash":"2a888bb6022a6130ec436ee71c060894e58551d5","modified":1596306112868},{"_id":"source/_posts/fe/vue-3-0-beta-b站直播内容速记.md","hash":"dd0a47a0b6eba8edfeefc5ec4015bf58ef7b0202","modified":1596306112869},{"_id":"source/_posts/fe/vue-v2-6-10-的选项-生命周期钩子.md","hash":"36b53c805812287b270eb9bd1d73acf2319ac701","modified":1596306112870},{"_id":"source/_posts/fe/vue使用自定义指令完成节流和防抖.md","hash":"9439df1c5fc08158cc00e0c36e3df9b790d4e876","modified":1596306112871},{"_id":"source/_posts/fe/vue中的-computed-和-watch的区别.md","hash":"9dc03ed45c3e085b95495d64129936dcfe707c44","modified":1596306112870},{"_id":"source/_posts/fe/yarn内那些冷门的命令.md","hash":"736b8fc46faf567f50a2b667d3b105ab89f2a9c1","modified":1596306112871},{"_id":"source/_posts/fe/从零到一实现一个js版深克隆.md","hash":"62ba90db354be9f7daf9912201fc73a14e7866b3","modified":1595865272659},{"_id":"source/_posts/fe/从dom与虚拟dom了解vue和react是如何响应数据变化的.md","hash":"bf85f187719be3ca60ee06f915cbd18b1687903f","modified":1596306112872},{"_id":"source/_posts/fe/task-job-与-eventloop.md","hash":"80f337642d3efadaefa86dd3068fdbfefb306cdb","modified":1596306112868},{"_id":"source/_posts/fe/养成好习惯-html语义化.md","hash":"00ff06b0b044a3b4cf5cb16fc90b934b9acc6c1e","modified":1596306112873},{"_id":"source/_posts/fe/利用css写一个可高度自定义的多行文本自动省略vue组件.md","hash":"6433c61a177db7cfcef1edeb6d2feaf4e6ff5318","modified":1596306112873},{"_id":"source/_posts/fe/做前端笔试题前-需要复习的数组方法.md","hash":"7eec250d90cfd8ec09cda4f411fc5ee9900a42c9","modified":1596306112872},{"_id":"source/_posts/fe/利用css给自己的博客增加灰度化效果.md","hash":"67480e7ce82ebe0b1eb114042b94c08d3dc8a85e","modified":1596306112874},{"_id":"source/_posts/fe/前端看http.md","hash":"b847beeeddb92b37bc51074f3922663a193d9d36","modified":1596306112875},{"_id":"source/_posts/fe/在一个较大的对象数组里查询指定的对象.md","hash":"bd6f754db7dbcd4a871f5c84250862134dff5c14","modified":1596306112876},{"_id":"source/_posts/fe/我们为什么需要使用vuex做状态管理.md","hash":"292b1dfb91d8ab7ac06f426d4f2f7b86a9368f16","modified":1596306112877},{"_id":"source/_posts/fe/执行npm命令报lifecycle的警告解决.md","hash":"97f751f1d33ddf8c9e86b5b30cd4a30dfa50438a","modified":1595865272662},{"_id":"source/_posts/fe/node-js环境log颜色表.md","hash":"0260b52dd0b4c4cb17b41048ab20bf757cc98cb7","modified":1596371670520},{"_id":"source/_posts/fe/osi七层模型-tcp-ip四层模型.md","hash":"c3be7f90071dae45938ef0c05ee83b95ef55ea26","modified":1596371670521},{"_id":"source/_posts/life/bye-qyer.md","hash":"b0fce38599316efea69dc673cebd0c9996fb9db5","modified":1596306112879},{"_id":"source/_posts/fe/移动端ios特殊的点击事件.md","hash":"4422f03b9025b5f2f53005644f1e99e155535ed5","modified":1596306112878},{"_id":"source/_posts/fe/对于前端熟悉又陌生的ria.md","hash":"ee9d9ef9c43d4e6c53f066b55d8184016b4cefad","modified":1596371670522},{"_id":"source/_posts/other/centos服务器配置防火墙.md","hash":"8f7c63f764fa30879513aa2cafb73376460ad903","modified":1596371670524},{"_id":"source/_posts/fe/浏览器的重绘-repaint-与重排-reflow-机制.md","hash":"ee1622ca75ece6cc9ce8b6e1f4cc36069bf863a8","modified":1596371670523},{"_id":"source/_posts/other/saas-laas-paas这些名词的快速理解.md","hash":"08e65e2789b49977619bc5a8ffa20f27b0024a50","modified":1605622540854},{"_id":"source/_posts/other/git常用命令速览.md","hash":"03968de34fa2b81a1735c1a47edfed7b14aa1cf2","modified":1596306112881},{"_id":"source/_posts/other/利用docker管理vps-nginx篇.md","hash":"87b8f914359a52415dd2fab31692fcc6d3509d15","modified":1596306112882},{"_id":"source/_posts/other/rm2100-ax200-ping.md","hash":"25de2a9339e58e5b7a3f53e8e4bbe5fc757c1712","modified":1605622540853},{"_id":"source/_posts/other/sentry-一站式错误监控平台部署记录.md","hash":"6d7a715ba053c125c605ad3e87ff7e3ba97ee9c7","modified":1596561912584},{"_id":"source/_posts/other/利用wsl在windows下获得更好的开发体验.md","hash":"e5ff3d8ffb251b698e7553c097f959946b718822","modified":1596306112883},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"7ba0efa830da1990457d0b0b9c1c490b3dd031c9","modified":1595865272668},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0ff1b931f11230e77b190e4bde0ce05d6f1ef531","modified":1595865272668},{"_id":"source/_posts/other/我的博客更新日志.md","hash":"fe7d7fceabfd009cb97d726f9bd296553eebaf36","modified":1596371670526},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"42afb69546eae522e340e3adb99f7bfc4cc4c397","modified":1595865272668},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1595865272669},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1595865272669},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1595865272669},{"_id":"themes/icarus/include/migration/head.js","hash":"269ba172013cbd2f10b9bc51af0496628081329b","modified":1605625633994},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1595865272673},{"_id":"themes/icarus/include/schema/config.json","hash":"ac633f9d349bca4f089d59d2c3738b57376f1b31","modified":1605625633999},{"_id":"themes/icarus/include/style/article.styl","hash":"be25e890113e926bbac3bf1461d7ce5427914774","modified":1605625634002},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1605625634002},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1595865272682},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1595865272682},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1605625634003},{"_id":"themes/icarus/include/style/custom-share.styl","hash":"528a8f10c8278c3146e2fe409a182721c1afad06","modified":1596479586303},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1605625634003},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1595865272683},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1605625634004},{"_id":"themes/icarus/include/style/navbar.styl","hash":"ecc73c8ad504c0fa4bb910eb51500c14e0a8d662","modified":1595868149054},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1605625634004},{"_id":"themes/icarus/include/style/plugin.styl","hash":"dc98160142c95ef81ba4789351002a5fcf29c04c","modified":1605625634004},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1595865272685},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1595865272686},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1595865272685},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1595865272686},{"_id":"themes/icarus/layout/common/article.jsx","hash":"f31c5a78fc4b2d72acf4583342be9e72ac9adf21","modified":1605625634011},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1595865272692},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1595865272693},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1605625634012},{"_id":"themes/icarus/layout/common/head.jsx","hash":"bcee2e258d13af6ac439ee6adaeefc06ea384e7e","modified":1605625634012},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"fcd9fd4624dee49207ef09ea2a1c63f524f3710c","modified":1605625634013},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1595865272695},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"a6b7a2891bbc7c71dcc2a0e756e9c9847bbb6729","modified":1605625634013},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1595865272695},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1595865272695},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"689cf4a6b79337b11d1d56afa9dda09223a809a1","modified":1595865272696},{"_id":"themes/icarus/layout/custom/share.jsx","hash":"8cda350cc22377f386a79bfe363fdb319d606379","modified":1596561912623},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1605625634016},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1595865272698},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"6fb534c9e9ba8c22449d11fc68b891c343a3a742","modified":1605625634018},{"_id":"themes/icarus/source/assets/avatar.png","hash":"ef65a7fcbd4e47add91ff07cef0da249cb670456","modified":1595865272702},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1605625634019},{"_id":"themes/icarus/source/assets/sparkling.ico","hash":"98da1452fbbc6ff9448e78fda068e8581650455e","modified":1595865272702},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1605625634019},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1605625634019},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1595865272703},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1595865272704},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1595865272704},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1595865272705},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1595865272705},{"_id":"themes/icarus/source/img/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1595865272706},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1595865272705},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1595865272706},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1605625634022},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1605625634022},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1605625634022},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272674},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272678},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272679},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272680},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1595865272680},{"_id":"source/_posts/other/forestry.io.md","hash":"9e23faf0c26d72aa8dd2212082303512f60ae997","modified":1596360955174},{"_id":"themes/icarus/include/schema/common/article.json","hash":"8d78149f44629d0848921c6fb9c008b03cef3116","modified":1605625633996},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"bd30bd9ffc84e88e704384acdfcaab09019a744f","modified":1595865272675},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1595865272675},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1605625633996},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1605625633997},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1605625633997},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1605625633997},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1595865272677},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1595865272677},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1595865272677},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1595865272677},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"d000b4d1d09bdd64756265aa4cd2ea980ab7ddc7","modified":1595865272678},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1595865272679},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1595865272679},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1595865272681},{"_id":"source/_posts/other/题解-每周10道前端面试题.md","hash":"e1a8ce5344c97df1b98bb11d66439dc012ee7615","modified":1596371670527},{"_id":"source/_posts/fe/跨域这个问题还得单独揪出来说一下.md","hash":"0132936ebf4feb0e17ffb4ca21e39e5efc7ed783","modified":1605622540852},{"_id":"source/_posts/other/ms-edge.md","hash":"5d87c3f316a81392b3392d64486b7d1dbbc18e9b","modified":1605622540853},{"_id":"source/_posts/other/sed.md","hash":"8e46b43ef42d4a7877985949c68702af742c15db","modified":1605622540854},{"_id":"source/_posts/other/uwp.md","hash":"632a671cdbfed230f400a4ec010252d57f68f8c3","modified":1605622540854},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1605625633992},{"_id":"themes/icarus/_config.yml.7526da86a0df246a4f21e2a8e160bc54","hash":"dfa95dbe0d04b73895c2e22b60b4623b1265343c","modified":1596561912608},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1605625633994},{"_id":"themes/icarus/include/style/widget.styl","hash":"af07ee43e209b6361eed22171bb50efaef7cbfeb","modified":1605625634005},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1605625634022},{"_id":"public/js/algolia.js","hash":"a8df0c0abeeb4ee1d2d720161f3aea7339380704","modified":1605625852264},{"_id":"public/js/google_cse.js","hash":"1a9881669dfdeb2b3214074eee0d3e01e52db2c4","modified":1605625852264},{"_id":"public/js/insight.js","hash":"86bbdb7305d9bf19ad62d2ca2cf169fc8d9f9d31","modified":1605625852264},{"_id":"public/js/toc.js","hash":"da6fb757a1b083b8ed138bf29aad3a7bf8ec4f11","modified":1605625852264},{"_id":"public/content.json","hash":"dd422538c780d1ff8e38d55151d84de269afe121","modified":1605625852264},{"_id":"public/manifest.json","hash":"3b2a5f4b5e4647ba426d36814820df8471951be5","modified":1605625852264},{"_id":"public/categories/index.html","hash":"eb72e56c14a85ae733a57badc6706bf90797f423","modified":1605625886528},{"_id":"public/2020/09/23/fe/跨域这个问题还得单独揪出来说一下/index.html","hash":"dc15e86b9507a7ffb72704397f520c48e5460faf","modified":1605625886528},{"_id":"public/2020/08/22/other/sed/index.html","hash":"a87ef9b067f0359a73c8c278afb0a765805663c2","modified":1605625886528},{"_id":"public/2020/08/09/other/ms-edge/index.html","hash":"ec4e76186ca1663333710f876ce203d95ed7e5bf","modified":1605625886528},{"_id":"public/2020/08/10/other/uwp/index.html","hash":"f4ac48b87445864f5d9cf06d2ff651ca753986d4","modified":1605625886528},{"_id":"public/2020/08/01/other/forestry.io/index.html","hash":"a2dfe355985941f41da90e2f594b4d72890b8f97","modified":1605625886528},{"_id":"public/2020/06/14/other/rm2100-ax200-ping/index.html","hash":"a7cf9502aacb5ed3a3f06fe2ddb2bbd53b1de400","modified":1605625886528},{"_id":"public/2020/05/07/other/sentry-一站式错误监控平台部署记录/index.html","hash":"3a2ec01df38b57addbc8d3d114bed7822c8fece8","modified":1605625886528},{"_id":"public/2020/04/22/other/利用wsl在windows下获得更好的开发体验/index.html","hash":"d8b4b8b3a5f22c09d06dfc17459a45b6e69c71b4","modified":1605625886528},{"_id":"public/2020/04/21/fe/vue-3-0-beta-b站直播内容速记/index.html","hash":"864bb32436e606ca8bf7be3b85dba1f23fb4df21","modified":1605625886528},{"_id":"public/2020/04/14/fe/ios-safari何时才能更好的支持pwa/index.html","hash":"631c7e0ec7d9f1238e93c4d499b78bd4d0507e42","modified":1605625886528},{"_id":"public/2020/04/03/fe/利用css给自己的博客增加灰度化效果/index.html","hash":"ec9638a9774648ed5f7d1167f0fdbd150428384e","modified":1605625886528},{"_id":"public/2020/03/20/fe/从零到一实现一个js版深克隆/index.html","hash":"460ecd473e1c5895ffc36a03fd723cc5a82b4cb8","modified":1605625886528},{"_id":"public/2020/03/25/other/利用docker管理vps-nginx篇/index.html","hash":"02af09f46b82793933fb0e819785717cb17e9a43","modified":1605625886528},{"_id":"public/2020/03/18/fe/javascript的模块机制/index.html","hash":"585a0c501499cce489773c0cd492c86858aca154","modified":1605625886528},{"_id":"public/2020/03/15/fe/javascript面向对象编程-es6版本/index.html","hash":"f8a68d8e37d54661b4e02d648de580df612128b2","modified":1605625886528},{"_id":"public/2020/03/03/fe/做前端笔试题前-需要复习的数组方法/index.html","hash":"959fae9caa089fd127d392e01f8380c22bdd9da0","modified":1605625886528},{"_id":"public/2020/03/02/other/题解-每周10道前端面试题/index.html","hash":"4575dae604b0cfd97bf9517a5a5c7bb7b5127bf6","modified":1605625886528},{"_id":"public/2020/03/02/fe/speaking-javascript-阅读笔记-附加篇/index.html","hash":"4732527bafd278704c1164f0f528dfd04c501259","modified":1605625886528},{"_id":"public/2020/03/01/fe/speaking-javascript-阅读笔记-三/index.html","hash":"19ce37fe227b6c500b769950f5ed8cd7f759b3db","modified":1605625886528},{"_id":"public/2020/02/29/fe/speaking-javascript-阅读笔记-二/index.html","hash":"c8e9521c62f59dcfd385a3e84f75133955f06dd2","modified":1605625886528},{"_id":"public/2020/02/26/other/我的博客更新日志/index.html","hash":"5c02d3613437513392bea1f8ad92857a1d99d7cc","modified":1605625886528},{"_id":"public/2020/02/28/fe/speaking-javascript-阅读笔记-一/index.html","hash":"af4bd5566abb8452a97be56f67e6cb0053534a2f","modified":1605625886528},{"_id":"public/2020/02/27/fe/对于前端熟悉又陌生的ria/index.html","hash":"eb16419e623e4a967b3f02998a7e3553ac37fff5","modified":1605625886528},{"_id":"public/2020/02/16/fe/js中的异步链式调用/index.html","hash":"ca52d5c1dd1ca4262a3938aed80da9d9b6e95c2d","modified":1605625886528},{"_id":"public/2020/01/07/fe/从dom与虚拟dom了解vue和react是如何响应数据变化的/index.html","hash":"9b0ae2fab1efad61a8b30aa33fcb55a4889ccf11","modified":1605625886528},{"_id":"public/2020/01/06/other/saas-laas-paas这些名词的快速理解/index.html","hash":"6a32ac79f7e7a859208a4766d0908bb18b3096ae","modified":1605625886528},{"_id":"public/2020/01/05/fe/yarn内那些冷门的命令/index.html","hash":"824f764d8fb465bb8c069fdafccf8179fe7908e1","modified":1605625886528},{"_id":"public/2019/12/27/fe/执行npm命令报lifecycle的警告解决/index.html","hash":"a3ea1e8b221bf97fea5ebf884b4a0740c2bd0735","modified":1605625886528},{"_id":"public/2019/08/21/fe/vue中的-computed-和-watch的区别/index.html","hash":"d79d4ee376331c40ccbc1dcf93d8b41b075ec4d4","modified":1605625886528},{"_id":"public/2019/08/21/fe/javascript的原型链与继承/index.html","hash":"be167cae20e785594430176e942ef72935b4c87a","modified":1605625886528},{"_id":"public/2019/08/21/fe/我们为什么需要使用vuex做状态管理/index.html","hash":"8add4be5febf2bb1b6a37d905a8963d199a00ca3","modified":1605625886528},{"_id":"public/2019/08/20/fe/task-job-与-eventloop/index.html","hash":"95746793cfbbe33ddf0566ebd39f9fc1233360ad","modified":1605625886528},{"_id":"public/2019/08/20/fe/浏览器的重绘-repaint-与重排-reflow-机制/index.html","hash":"d94585d5aac3974ca00ea05cbe181abc4107b9c5","modified":1605625886528},{"_id":"public/2019/08/19/fe/http的缓存机制/index.html","hash":"ef7efe5819928c3e783f7ce29291e11baf560287","modified":1605625886528},{"_id":"public/2019/08/19/fe/http状态码/index.html","hash":"ba7e10cb434e088b32ed01ffe3fe0eb35fe030d4","modified":1605625886528},{"_id":"public/2019/08/19/fe/async-await和promise的一些区别/index.html","hash":"5acb2487029f5de0b338d9331e3e311e65654f9e","modified":1605625886528},{"_id":"public/2019/08/19/fe/osi七层模型-tcp-ip四层模型/index.html","hash":"3e646688705381b55379e17b02fb7f88ece1fe10","modified":1605625886528},{"_id":"public/2019/08/18/fe/react-组件中-state-和生命周期/index.html","hash":"d8611a62c61541c1d09a884128b1103a1eddc308","modified":1605625886528},{"_id":"public/2019/08/18/fe/vue-v2-6-10-的选项-生命周期钩子/index.html","hash":"086b70afbbec160047bd1eefd491cea9917d8b99","modified":1605625886528},{"_id":"public/2019/08/18/fe/前端看http/index.html","hash":"bff7d4d6049c4d22c957a42853e93424658a9a17","modified":1605625886528},{"_id":"public/2019/08/17/life/bye-qyer/index.html","hash":"cc66dae46a2e4374af5c52a788d1b969b0066f3e","modified":1605625886528},{"_id":"public/2019/08/16/fe/script标签有几种写法/index.html","hash":"4db4376a2711aec32d294d128213066840c9772d","modified":1605625886528},{"_id":"public/2019/08/16/fe/meta标签的使用/index.html","hash":"0a2f5cb290fa1158acf8c1f9e9cdc1ad39c6b125","modified":1605625886528},{"_id":"public/2019/08/12/fe/移动端ios特殊的点击事件/index.html","hash":"adf59a1a3d3c6781b1cb03c6a5b84ce0048b8ec1","modified":1605625886528},{"_id":"public/2019/08/11/fe/javascript-基础知识点总结/index.html","hash":"51458570764597113ba40fff0648943478be6c79","modified":1605625886528},{"_id":"public/2019/08/11/fe/vue使用自定义指令完成节流和防抖/index.html","hash":"ab57d9126e9937cb6bbc08ce67ea5fe9876e2a9c","modified":1605625886528},{"_id":"public/2019/08/11/fe/养成好习惯-html语义化/index.html","hash":"1e32ad382acbb49fa87535d2df96647fad9e8df3","modified":1605625886528},{"_id":"public/2019/08/11/fe/利用css写一个可高度自定义的多行文本自动省略vue组件/index.html","hash":"f72944e120f12b78329459e5436eaea9b668fd3b","modified":1605625886528},{"_id":"public/2019/08/11/fe/在一个较大的对象数组里查询指定的对象/index.html","hash":"367e722936c8c559367b409cb86c783170da284e","modified":1605625886528},{"_id":"public/2019/08/11/fe/node-js环境log颜色表/index.html","hash":"c142e29d83879eeb76119c0238a4bd35d52ffc89","modified":1605625886528},{"_id":"public/2019/08/11/other/git常用命令速览/index.html","hash":"2639ddb62be8ef01b0e7223c54b42c3420c6480c","modified":1605625886528},{"_id":"public/2019/08/25/other/centos服务器配置防火墙/index.html","hash":"3622a2d8030ba1345a64c8f59140757673c26429","modified":1605625886528},{"_id":"public/archives/index.html","hash":"7f4fd56f4a3a79e9eb6014544f1c73899e41b538","modified":1605625886528},{"_id":"public/archives/page/2/index.html","hash":"dfed76a645487711d4edd931023916110c7bedcb","modified":1605625886528},{"_id":"public/archives/page/3/index.html","hash":"37ccfadd9c83da68d98333459fc61973db75c723","modified":1605625886528},{"_id":"public/archives/page/5/index.html","hash":"a48cf701928946f6b857705086089e07f24d721f","modified":1605625886528},{"_id":"public/archives/page/4/index.html","hash":"1bdd54420d82a75399f3a5ccc00ca710184b7224","modified":1605625886528},{"_id":"public/archives/2019/index.html","hash":"ac03bf65912540f14b14197d49225ec2f9dd9a31","modified":1605625886528},{"_id":"public/archives/page/6/index.html","hash":"5626fdf2b9a649b0257f7580f4fc3e5875a8405f","modified":1605625886528},{"_id":"public/archives/2019/page/2/index.html","hash":"9006d31491e983f83f36c818230dee7af47ef8a4","modified":1605625886528},{"_id":"public/archives/2019/page/3/index.html","hash":"649b68505f12e5aa726461bd051745919a78c1ac","modified":1605625886528},{"_id":"public/archives/2019/08/index.html","hash":"fdefa70316ad2979520679986e050eb0a16edb08","modified":1605625886528},{"_id":"public/archives/2019/08/page/2/index.html","hash":"46d481834e347f718f0a17ed5aad110324ceafb6","modified":1605625886528},{"_id":"public/archives/2019/12/index.html","hash":"d5eb1eee6556fcd3f95509c6d920660155c03cb7","modified":1605625886528},{"_id":"public/archives/2019/08/page/3/index.html","hash":"b80684715cf06b4661233a66fe207c826e60f59c","modified":1605625886528},{"_id":"public/archives/2020/index.html","hash":"ee6d80af0bced13cfd124446236c2e7c1a247f75","modified":1605625886528},{"_id":"public/archives/2020/page/2/index.html","hash":"b2be1aec23688db2b25b73b90e119a800b901e2e","modified":1605625886528},{"_id":"public/archives/2020/page/3/index.html","hash":"15b98ba983a1ef71df715d232ff663304ef89003","modified":1605625886528},{"_id":"public/archives/2020/02/index.html","hash":"d57e61f16a7950d2d5133c807cee4aa1573e7b97","modified":1605625886528},{"_id":"public/archives/2020/01/index.html","hash":"71f25afa895b1c3b6013949f4dfc22c0af56b72a","modified":1605625886528},{"_id":"public/archives/2020/03/index.html","hash":"dd9d0468414fbd064bf9551e689d85d7f5f0f83c","modified":1605625886528},{"_id":"public/archives/2020/04/index.html","hash":"7476ab9192949d78a179a9225559ef19b03a4b31","modified":1605625886528},{"_id":"public/archives/2020/05/index.html","hash":"8275aa23af2a0b67e056fb3b5ce03dce1d1b7b7d","modified":1605625886528},{"_id":"public/archives/2020/06/index.html","hash":"fa17c727847bfa79ffcedb1a4c934e3cb03048d0","modified":1605625886528},{"_id":"public/archives/2020/08/index.html","hash":"49ff552a07b86ebc754cb38ff774aa10af2a8419","modified":1605625886528},{"_id":"public/archives/2020/09/index.html","hash":"794c4429af8e6682275f714989acba739d089d23","modified":1605625886528},{"_id":"public/index.html","hash":"9c976addd17ff16c0ba18cdf7c7045740548f695","modified":1605625886528},{"_id":"public/page/3/index.html","hash":"56fb4a088cc9eca695dc9bf3523660c5765a4c2a","modified":1605625886528},{"_id":"public/page/4/index.html","hash":"29bbbf09da0cdf899a854ab80677f3b35bcff880","modified":1605625886528},{"_id":"public/page/2/index.html","hash":"d56daebaff48ce2c2c09c2724d4aa1e54fd853d9","modified":1605625886528},{"_id":"public/page/5/index.html","hash":"b820949dd00c00f6ab4f6855969ed83033204cd3","modified":1605625886528},{"_id":"public/page/6/index.html","hash":"7a3b1224d9f77d95a5076f97cdee635ff87da500","modified":1605625886528},{"_id":"public/tags/PWA/index.html","hash":"8497040ba102ade3f2b0cb53bb9905b2b74c54e0","modified":1605625886528},{"_id":"public/tags/Safari/index.html","hash":"51d3a71dd388579a2d533b40be4a0dc6b0ba3af3","modified":1605625886528},{"_id":"public/tags/HTTP/index.html","hash":"3c46b392b9f73e8ebbb74fe3e30e8d3552ec1d22","modified":1605625886528},{"_id":"public/tags/JavaScript/page/2/index.html","hash":"a520f172f2d4817c132e88c751677cb3b553a485","modified":1605625886528},{"_id":"public/tags/JavaScript/index.html","hash":"ed12f70fcb7a137ee23f357d61c7b79bb36c0a54","modified":1605625886528},{"_id":"public/tags/HTML/index.html","hash":"e9e87627f9b010f267809d082fb06fffc1bdec93","modified":1605625886528},{"_id":"public/tags/Vue-js/index.html","hash":"8221845d0f723502d4a4d03c803c8012ff4fb10e","modified":1605625886528},{"_id":"public/tags/React-js/index.html","hash":"e69a9d7d269e239a51d0c41d69c1a6d8541cd8fa","modified":1605625886528},{"_id":"public/tags/NPM/index.html","hash":"359efeaf2890947a24d1997e6a6f657dbcd3564f","modified":1605625886528},{"_id":"public/tags/前端/index.html","hash":"e31c78454d90199845d049b510e9e44f0e03dc8c","modified":1605625886528},{"_id":"public/tags/CSS/index.html","hash":"f7e41f19a8da16f059db124ce0a60c7162e40916","modified":1605625886528},{"_id":"public/tags/Node-js/index.html","hash":"57b8d6f7564563f7d33184180ff46a7c051dbfc5","modified":1605625886528},{"_id":"public/tags/工作/index.html","hash":"95fbcb1372ba06dcb06787cbc5c3d7decbd3d5e5","modified":1605625886528},{"_id":"public/tags/Linux/index.html","hash":"4c547cfbaa6aa8e0475f4f8153e6aa4841ba6fd2","modified":1605625886528},{"_id":"public/tags/CheatSheet/index.html","hash":"3fac49ebcb00140cd0bc549b1b6d775cfcfa7555","modified":1605625886528},{"_id":"public/tags/记录/index.html","hash":"df8a96af08c6988051d2aabf0cd53b7f56f7fcde","modified":1605625886528},{"_id":"public/tags/工具/index.html","hash":"43ce687eda96833e3ae56974ec8f29ed9a377776","modified":1605625886528},{"_id":"public/tags/WSL/index.html","hash":"ee561202751c63ef2c57ac9c301e264d2e4d376a","modified":1605625886528},{"_id":"public/tags/概念/index.html","hash":"73517e8c26b1836688d99591c27ffe017d82f754","modified":1605625886528},{"_id":"public/tags/Edge/index.html","hash":"b98766e7a0e1fd6d91e43e95330549096f783fc9","modified":1605625886528},{"_id":"public/tags/UWP/index.html","hash":"8a56fee28ca9622a30b375ef969fd57d344785c0","modified":1605625886528},{"_id":"public/categories/Frontend/index.html","hash":"60b23b31e11aeb5408e8066d96239b342a744cdf","modified":1605625886528},{"_id":"public/categories/Frontend/page/2/index.html","hash":"604535cc583854598ef020a42924cd8ee9bc9770","modified":1605625886528},{"_id":"public/categories/Frontend/page/3/index.html","hash":"239e7f1ac8837aa4e66c1bbf2d5710945e2d04cc","modified":1605625886528},{"_id":"public/categories/Frontend/page/4/index.html","hash":"e05de3057bde569857f5403391dffdc54827676c","modified":1605625886528},{"_id":"public/categories/Life/index.html","hash":"aee79d6c3c3894d63de44833f21baad669ce3d2c","modified":1605625886528},{"_id":"public/categories/Other/index.html","hash":"e9af31c4e1ece8ed662cc3cef8ae1164f8105563","modified":1605625886528},{"_id":"public/categories/Other/page/2/index.html","hash":"1c7dd4b8ab25a7ee62e0a03892b84e42bbad1929","modified":1605625886528},{"_id":"public/tags/index.html","hash":"8b1851f65f1b9972d5337557c038d53116929f00","modified":1605625886528},{"_id":"public/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1605625852264},{"_id":"public/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1605625852264},{"_id":"public/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1605625852264},{"_id":"public/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1605625852264},{"_id":"public/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1605625852264},{"_id":"public/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1605625852264},{"_id":"public/img/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1605625852264},{"_id":"public/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1605625852264},{"_id":"public/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1605625852264},{"_id":"public/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1605625852264},{"_id":"public/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1605625852264},{"_id":"public/css/cyberpunk.css","hash":"0d8dc4bf137bd7ccd0125f1bb6af45c1e51d7489","modified":1605625852264},{"_id":"public/css/default.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1605625852264},{"_id":"public/css/style.css","hash":"f36bff9e79cb531e5ac60c5242c449644d3c7750","modified":1605625852264},{"_id":"public/assets/sparkling.ico","hash":"98da1452fbbc6ff9448e78fda068e8581650455e","modified":1605625852264},{"_id":"public/assets/avatar.png","hash":"ef65a7fcbd4e47add91ff07cef0da249cb670456","modified":1605625852264}],"Category":[{"name":"Frontend","_id":"ckdev5ia30003j1wt4qhy8937"},{"name":"Life","_id":"ckdev5ib8002vj1wt2rurfxtv"},{"name":"Other","_id":"ckdev5iba0036j1wt88u62045"}],"Data":[],"Page":[{"title":"文章分类","date":"2019-08-15T03:22:18.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2019-08-15 11:22:18\ntype: \"categories\"\n---\n","updated":"2020-07-27T15:54:32.666Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckdev5i9l0000j1wtewzr2hvz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"date":"2020-04-14T00:07:03.000Z","title":"iOS Safari何时才能更好的支持PWA？","excerpt":"这篇文章写的其实满气愤的，PWA其实是非常棒的特性，但是在iOS上表现如此之差也难堪重任。","thumbnail":"","_content":"### 写在前面\n\n最近由于疫情的原因，找工作是越来越难了，自己的工作时间也很尴尬，三年不足，一年有余，反思自己，觉得应该在现在的时间多学些东西，同时督促自己提高效率，就想到了“番茄工作法”，想找一个App来配合使用，看到了一个叫\"FocusList\"的工具，很简洁，支持macOS + iOS，但是价格让我望而却步，简单的功能也需要近15元，还不包括macOS，而且作者上一次版本更新还是在一年前，现在的macOS三天一小更新，五天一大更新，付费最担心的莫过于后面的系统支持不好。正好最近想练下React Hooks，决定自己仿照App实现一个番茄计时，加入PWA和Web提醒功能，噩梦就这么来了。\n\n### MDN的官方写法\n\n在MDN的[通过通知推送让 PWA 可重用“”](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Re-engageable_Notifications_Push)一文中，给出了规范的写法，这里提到Notification的requestPermission是一个Promise对象，因此，可以用如下写法提示用户打开推送许可：\n\n```javascript\nNotification.requestPermission().then(function(result) {\n    if(result === 'granted') {\n        randomNotification();\n    }\n});\n```\n\nOK，这种写法很简洁，也非常容易在业务里实现，部署到HTTPS的域名下试试效果，Chrome（macOS）下完美。\n\n再用Safari（macOS）打开，错误，emmm，看到报错：`undefined is not an object (evaluating 'Notification.requestPermission().then')`，了解，应该是Safari需要兼容，也许是实现不同，通过查阅文档果然，Safari是通过Callback实现的，也就是说，这段代码应该改为：\n\n```javascript\ntry {\n    Notification.requestPermission()\n        .then(() => doSomething())\n} catch (error) {\n    // Safari doesn't return a promise for requestPermissions and it                                     \n    // throws a TypeError. It takes a callback as the first argument                                     \n    // instead.\n    if (error instanceof TypeError) {\n       Notification.requestPermission(() => {\n           doSomething();\n       });\n    } else {\n       throw error;\n    }\n}      \n```\n\n通过这种改造，ok，macOS上的Safari能够正常请求允许并发送通知了，很不错。\n\n### iOS与macOS —— 区别对待\n\n本以为到这里已经结束了，但万万没想到的是，iOS对PWA的支持是 __有限的__ , 在iOS上，压根就没有Notification这个对象，也就是说，如果想兼容iOS设备，就要先做一个判断：\n\n```javascript\nif(typeof Notification === 'undefined') return; // Without Notification, code below will throw error.\ntry {\n    Notification.requestPermission()\n        .then(() => doSomething())\n} catch (error) {\n    // Safari doesn't return a promise for requestPermissions and it                                     \n    // throws a TypeError. It takes a callback as the first argument                                     \n    // instead.\n    if (error instanceof TypeError) {\n       Notification.requestPermission(() => {\n           doSomething();\n       });\n    } else {\n       throw error;\n    }\n}      \n```\n\n踩过坑，就要知道iOS究竟实现了PWA的哪些部分，查阅资料，总结下来 __至今仍未支持的功能__ 有：\n\n- 创建应用程序加载屏幕\n- 使用推送通知\n- 添加离线支持（iOS会在指定时间清除AppCache，因此，离线支持不是永久可用的。）\n- 创建一个初始的应用程序UI来实现即时加载\n- 通过浏览器引导对话框，提示安装到主屏幕\n\n所以，到这里我终于明白为什么iOS市场会有一些功能很简单但是需要付费的软件了，生态闭环，封闭了一些功能，使得开发者 __不得不__ 采用不同的方式来实现。\n\n这也是PWA迄今为止仍无法大范围普及的原因，功能缺失，是不能作为App的 __替代__ 来完成使用的。\n\n而小程序，能够通过宿主平台的能力（推送、缓存、以及账户共享等等），完成PWA很早就期望的一些能力，因此，小程序是目前相对“Lite”的应用形式。\n\n> 另外一种推送方式是FCM，即Firebase Cloud Messaging，它需要一个完全唯一的用户设备ASN，但是通过Web的方式，我们不能够获得这种ASN，因此这一条路也是不通的。\n\n### Apple，何时才能做出改变？\n\n谷歌相关问题，就能够发现很多相关的提问。距离iOS开始支持standalone模式的PWA已经过去了一年多的时间（从iOS12.2发布算起，发布的时间是2019年3月25日），其实我想对于Apple而言，技术不是问题，核心问题是PWA可能会给AppStore带来或多或少的影响，这从根本影响了Apple支持PWA的愿望。","source":"_posts/fe/ios-safari何时才能更好的支持pwa.md","raw":"---\ncategories: Frontend\ntags:\n- PWA\n- Safari\ndate: 2020-04-14T16:07:03.000+08:00\ntitle: iOS Safari何时才能更好的支持PWA？\nexcerpt: 这篇文章写的其实满气愤的，PWA其实是非常棒的特性，但是在iOS上表现如此之差也难堪重任。\nthumbnail: ''\n\n---\n### 写在前面\n\n最近由于疫情的原因，找工作是越来越难了，自己的工作时间也很尴尬，三年不足，一年有余，反思自己，觉得应该在现在的时间多学些东西，同时督促自己提高效率，就想到了“番茄工作法”，想找一个App来配合使用，看到了一个叫\"FocusList\"的工具，很简洁，支持macOS + iOS，但是价格让我望而却步，简单的功能也需要近15元，还不包括macOS，而且作者上一次版本更新还是在一年前，现在的macOS三天一小更新，五天一大更新，付费最担心的莫过于后面的系统支持不好。正好最近想练下React Hooks，决定自己仿照App实现一个番茄计时，加入PWA和Web提醒功能，噩梦就这么来了。\n\n### MDN的官方写法\n\n在MDN的[通过通知推送让 PWA 可重用“”](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Re-engageable_Notifications_Push)一文中，给出了规范的写法，这里提到Notification的requestPermission是一个Promise对象，因此，可以用如下写法提示用户打开推送许可：\n\n```javascript\nNotification.requestPermission().then(function(result) {\n    if(result === 'granted') {\n        randomNotification();\n    }\n});\n```\n\nOK，这种写法很简洁，也非常容易在业务里实现，部署到HTTPS的域名下试试效果，Chrome（macOS）下完美。\n\n再用Safari（macOS）打开，错误，emmm，看到报错：`undefined is not an object (evaluating 'Notification.requestPermission().then')`，了解，应该是Safari需要兼容，也许是实现不同，通过查阅文档果然，Safari是通过Callback实现的，也就是说，这段代码应该改为：\n\n```javascript\ntry {\n    Notification.requestPermission()\n        .then(() => doSomething())\n} catch (error) {\n    // Safari doesn't return a promise for requestPermissions and it                                     \n    // throws a TypeError. It takes a callback as the first argument                                     \n    // instead.\n    if (error instanceof TypeError) {\n       Notification.requestPermission(() => {\n           doSomething();\n       });\n    } else {\n       throw error;\n    }\n}      \n```\n\n通过这种改造，ok，macOS上的Safari能够正常请求允许并发送通知了，很不错。\n\n### iOS与macOS —— 区别对待\n\n本以为到这里已经结束了，但万万没想到的是，iOS对PWA的支持是 __有限的__ , 在iOS上，压根就没有Notification这个对象，也就是说，如果想兼容iOS设备，就要先做一个判断：\n\n```javascript\nif(typeof Notification === 'undefined') return; // Without Notification, code below will throw error.\ntry {\n    Notification.requestPermission()\n        .then(() => doSomething())\n} catch (error) {\n    // Safari doesn't return a promise for requestPermissions and it                                     \n    // throws a TypeError. It takes a callback as the first argument                                     \n    // instead.\n    if (error instanceof TypeError) {\n       Notification.requestPermission(() => {\n           doSomething();\n       });\n    } else {\n       throw error;\n    }\n}      \n```\n\n踩过坑，就要知道iOS究竟实现了PWA的哪些部分，查阅资料，总结下来 __至今仍未支持的功能__ 有：\n\n- 创建应用程序加载屏幕\n- 使用推送通知\n- 添加离线支持（iOS会在指定时间清除AppCache，因此，离线支持不是永久可用的。）\n- 创建一个初始的应用程序UI来实现即时加载\n- 通过浏览器引导对话框，提示安装到主屏幕\n\n所以，到这里我终于明白为什么iOS市场会有一些功能很简单但是需要付费的软件了，生态闭环，封闭了一些功能，使得开发者 __不得不__ 采用不同的方式来实现。\n\n这也是PWA迄今为止仍无法大范围普及的原因，功能缺失，是不能作为App的 __替代__ 来完成使用的。\n\n而小程序，能够通过宿主平台的能力（推送、缓存、以及账户共享等等），完成PWA很早就期望的一些能力，因此，小程序是目前相对“Lite”的应用形式。\n\n> 另外一种推送方式是FCM，即Firebase Cloud Messaging，它需要一个完全唯一的用户设备ASN，但是通过Web的方式，我们不能够获得这种ASN，因此这一条路也是不通的。\n\n### Apple，何时才能做出改变？\n\n谷歌相关问题，就能够发现很多相关的提问。距离iOS开始支持standalone模式的PWA已经过去了一年多的时间（从iOS12.2发布算起，发布的时间是2019年3月25日），其实我想对于Apple而言，技术不是问题，核心问题是PWA可能会给AppStore带来或多或少的影响，这从根本影响了Apple支持PWA的愿望。","slug":"fe/ios-safari何时才能更好的支持pwa","published":1,"updated":"2020-08-01T18:21:52.860Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5i9z0001j1wt1e7i0z10","content":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>最近由于疫情的原因，找工作是越来越难了，自己的工作时间也很尴尬，三年不足，一年有余，反思自己，觉得应该在现在的时间多学些东西，同时督促自己提高效率，就想到了“番茄工作法”，想找一个App来配合使用，看到了一个叫”FocusList”的工具，很简洁，支持macOS + iOS，但是价格让我望而却步，简单的功能也需要近15元，还不包括macOS，而且作者上一次版本更新还是在一年前，现在的macOS三天一小更新，五天一大更新，付费最担心的莫过于后面的系统支持不好。正好最近想练下React Hooks，决定自己仿照App实现一个番茄计时，加入PWA和Web提醒功能，噩梦就这么来了。</p>\n<h3 id=\"MDN的官方写法\"><a href=\"#MDN的官方写法\" class=\"headerlink\" title=\"MDN的官方写法\"></a>MDN的官方写法</h3><p>在MDN的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Re-engageable_Notifications_Push\">通过通知推送让 PWA 可重用“”</a>一文中，给出了规范的写法，这里提到Notification的requestPermission是一个Promise对象，因此，可以用如下写法提示用户打开推送许可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Notification.requestPermission().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result === <span class=\"string\">'granted'</span>) &#123;</span><br><span class=\"line\">        randomNotification();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OK，这种写法很简洁，也非常容易在业务里实现，部署到HTTPS的域名下试试效果，Chrome（macOS）下完美。</p>\n<p>再用Safari（macOS）打开，错误，emmm，看到报错：<code>undefined is not an object (evaluating &#39;Notification.requestPermission().then&#39;)</code>，了解，应该是Safari需要兼容，也许是实现不同，通过查阅文档果然，Safari是通过Callback实现的，也就是说，这段代码应该改为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Notification.requestPermission()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> doSomething())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Safari doesn't return a promise for requestPermissions and it                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// throws a TypeError. It takes a callback as the first argument                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// instead.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error <span class=\"keyword\">instanceof</span> <span class=\"built_in\">TypeError</span>) &#123;</span><br><span class=\"line\">       Notification.requestPermission(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">           doSomething();</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种改造，ok，macOS上的Safari能够正常请求允许并发送通知了，很不错。</p>\n<h3 id=\"iOS与macOS-——-区别对待\"><a href=\"#iOS与macOS-——-区别对待\" class=\"headerlink\" title=\"iOS与macOS —— 区别对待\"></a>iOS与macOS —— 区别对待</h3><p>本以为到这里已经结束了，但万万没想到的是，iOS对PWA的支持是 <strong>有限的</strong> , 在iOS上，压根就没有Notification这个对象，也就是说，如果想兼容iOS设备，就要先做一个判断：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> Notification === <span class=\"string\">'undefined'</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// Without Notification, code below will throw error.</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Notification.requestPermission()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> doSomething())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Safari doesn't return a promise for requestPermissions and it                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// throws a TypeError. It takes a callback as the first argument                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// instead.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error <span class=\"keyword\">instanceof</span> <span class=\"built_in\">TypeError</span>) &#123;</span><br><span class=\"line\">       Notification.requestPermission(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">           doSomething();</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>踩过坑，就要知道iOS究竟实现了PWA的哪些部分，查阅资料，总结下来 <strong>至今仍未支持的功能</strong> 有：</p>\n<ul>\n<li>创建应用程序加载屏幕</li>\n<li>使用推送通知</li>\n<li>添加离线支持（iOS会在指定时间清除AppCache，因此，离线支持不是永久可用的。）</li>\n<li>创建一个初始的应用程序UI来实现即时加载</li>\n<li>通过浏览器引导对话框，提示安装到主屏幕</li>\n</ul>\n<p>所以，到这里我终于明白为什么iOS市场会有一些功能很简单但是需要付费的软件了，生态闭环，封闭了一些功能，使得开发者 <strong>不得不</strong> 采用不同的方式来实现。</p>\n<p>这也是PWA迄今为止仍无法大范围普及的原因，功能缺失，是不能作为App的 <strong>替代</strong> 来完成使用的。</p>\n<p>而小程序，能够通过宿主平台的能力（推送、缓存、以及账户共享等等），完成PWA很早就期望的一些能力，因此，小程序是目前相对“Lite”的应用形式。</p>\n<blockquote>\n<p>另外一种推送方式是FCM，即Firebase Cloud Messaging，它需要一个完全唯一的用户设备ASN，但是通过Web的方式，我们不能够获得这种ASN，因此这一条路也是不通的。</p>\n</blockquote>\n<h3 id=\"Apple，何时才能做出改变？\"><a href=\"#Apple，何时才能做出改变？\" class=\"headerlink\" title=\"Apple，何时才能做出改变？\"></a>Apple，何时才能做出改变？</h3><p>谷歌相关问题，就能够发现很多相关的提问。距离iOS开始支持standalone模式的PWA已经过去了一年多的时间（从iOS12.2发布算起，发布的时间是2019年3月25日），其实我想对于Apple而言，技术不是问题，核心问题是PWA可能会给AppStore带来或多或少的影响，这从根本影响了Apple支持PWA的愿望。</p>\n","site":{"data":{}},"more":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>最近由于疫情的原因，找工作是越来越难了，自己的工作时间也很尴尬，三年不足，一年有余，反思自己，觉得应该在现在的时间多学些东西，同时督促自己提高效率，就想到了“番茄工作法”，想找一个App来配合使用，看到了一个叫”FocusList”的工具，很简洁，支持macOS + iOS，但是价格让我望而却步，简单的功能也需要近15元，还不包括macOS，而且作者上一次版本更新还是在一年前，现在的macOS三天一小更新，五天一大更新，付费最担心的莫过于后面的系统支持不好。正好最近想练下React Hooks，决定自己仿照App实现一个番茄计时，加入PWA和Web提醒功能，噩梦就这么来了。</p>\n<h3 id=\"MDN的官方写法\"><a href=\"#MDN的官方写法\" class=\"headerlink\" title=\"MDN的官方写法\"></a>MDN的官方写法</h3><p>在MDN的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps/Re-engageable_Notifications_Push\">通过通知推送让 PWA 可重用“”</a>一文中，给出了规范的写法，这里提到Notification的requestPermission是一个Promise对象，因此，可以用如下写法提示用户打开推送许可：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Notification.requestPermission().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(result === <span class=\"string\">'granted'</span>) &#123;</span><br><span class=\"line\">        randomNotification();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OK，这种写法很简洁，也非常容易在业务里实现，部署到HTTPS的域名下试试效果，Chrome（macOS）下完美。</p>\n<p>再用Safari（macOS）打开，错误，emmm，看到报错：<code>undefined is not an object (evaluating &#39;Notification.requestPermission().then&#39;)</code>，了解，应该是Safari需要兼容，也许是实现不同，通过查阅文档果然，Safari是通过Callback实现的，也就是说，这段代码应该改为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Notification.requestPermission()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> doSomething())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Safari doesn't return a promise for requestPermissions and it                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// throws a TypeError. It takes a callback as the first argument                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// instead.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error <span class=\"keyword\">instanceof</span> <span class=\"built_in\">TypeError</span>) &#123;</span><br><span class=\"line\">       Notification.requestPermission(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">           doSomething();</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过这种改造，ok，macOS上的Safari能够正常请求允许并发送通知了，很不错。</p>\n<h3 id=\"iOS与macOS-——-区别对待\"><a href=\"#iOS与macOS-——-区别对待\" class=\"headerlink\" title=\"iOS与macOS —— 区别对待\"></a>iOS与macOS —— 区别对待</h3><p>本以为到这里已经结束了，但万万没想到的是，iOS对PWA的支持是 <strong>有限的</strong> , 在iOS上，压根就没有Notification这个对象，也就是说，如果想兼容iOS设备，就要先做一个判断：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> Notification === <span class=\"string\">'undefined'</span>) <span class=\"keyword\">return</span>; <span class=\"comment\">// Without Notification, code below will throw error.</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Notification.requestPermission()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> doSomething())</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Safari doesn't return a promise for requestPermissions and it                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// throws a TypeError. It takes a callback as the first argument                                     </span></span><br><span class=\"line\">    <span class=\"comment\">// instead.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error <span class=\"keyword\">instanceof</span> <span class=\"built_in\">TypeError</span>) &#123;</span><br><span class=\"line\">       Notification.requestPermission(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">           doSomething();</span><br><span class=\"line\">       &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>踩过坑，就要知道iOS究竟实现了PWA的哪些部分，查阅资料，总结下来 <strong>至今仍未支持的功能</strong> 有：</p>\n<ul>\n<li>创建应用程序加载屏幕</li>\n<li>使用推送通知</li>\n<li>添加离线支持（iOS会在指定时间清除AppCache，因此，离线支持不是永久可用的。）</li>\n<li>创建一个初始的应用程序UI来实现即时加载</li>\n<li>通过浏览器引导对话框，提示安装到主屏幕</li>\n</ul>\n<p>所以，到这里我终于明白为什么iOS市场会有一些功能很简单但是需要付费的软件了，生态闭环，封闭了一些功能，使得开发者 <strong>不得不</strong> 采用不同的方式来实现。</p>\n<p>这也是PWA迄今为止仍无法大范围普及的原因，功能缺失，是不能作为App的 <strong>替代</strong> 来完成使用的。</p>\n<p>而小程序，能够通过宿主平台的能力（推送、缓存、以及账户共享等等），完成PWA很早就期望的一些能力，因此，小程序是目前相对“Lite”的应用形式。</p>\n<blockquote>\n<p>另外一种推送方式是FCM，即Firebase Cloud Messaging，它需要一个完全唯一的用户设备ASN，但是通过Web的方式，我们不能够获得这种ASN，因此这一条路也是不通的。</p>\n</blockquote>\n<h3 id=\"Apple，何时才能做出改变？\"><a href=\"#Apple，何时才能做出改变？\" class=\"headerlink\" title=\"Apple，何时才能做出改变？\"></a>Apple，何时才能做出改变？</h3><p>谷歌相关问题，就能够发现很多相关的提问。距离iOS开始支持standalone模式的PWA已经过去了一年多的时间（从iOS12.2发布算起，发布的时间是2019年3月25日），其实我想对于Apple而言，技术不是问题，核心问题是PWA可能会给AppStore带来或多或少的影响，这从根本影响了Apple支持PWA的愿望。</p>\n"},{"title":"HTTP的缓存机制","date":"2019-08-19T08:00:00.000Z","excerpt":"又是经典面试题，不妨花几分钟时间好好记忆下来。","thumbnail":"","_content":"#### 缓存用来做什么？\n缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。\n\n缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。\n\n虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。\n\n#### HTTP中的缓存控制\nHTTP/1.1定义的 `Cache-Control` 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。\n\n- 禁止缓存: `Cache-Control: no-store`\n- 强制确认缓存: `Cache-Control: no-cache`\n- 私有缓存和公共缓存: `Cache-Control: private/public`\n- 缓存过期机制: `Cache-Control: max-age=31536000`\n- 缓存验证确认: `Cache-Control: must-revalidate`","source":"_posts/fe/http的缓存机制.md","raw":"---\ntags:\n- HTTP\ncategories: Frontend\ntitle: HTTP的缓存机制\ndate: 2019-08-20T00:00:00.000+08:00\nexcerpt: 又是经典面试题，不妨花几分钟时间好好记忆下来。\nthumbnail: ''\n\n---\n#### 缓存用来做什么？\n缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。\n\n缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。\n\n虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。\n\n#### HTTP中的缓存控制\nHTTP/1.1定义的 `Cache-Control` 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。\n\n- 禁止缓存: `Cache-Control: no-store`\n- 强制确认缓存: `Cache-Control: no-cache`\n- 私有缓存和公共缓存: `Cache-Control: private/public`\n- 缓存过期机制: `Cache-Control: max-age=31536000`\n- 缓存验证确认: `Cache-Control: must-revalidate`","slug":"fe/http的缓存机制","published":1,"updated":"2020-08-01T18:21:52.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ia20002j1wtbfroc186","content":"<h4 id=\"缓存用来做什么？\"><a href=\"#缓存用来做什么？\" class=\"headerlink\" title=\"缓存用来做什么？\"></a>缓存用来做什么？</h4><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>\n<p>缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p>\n<p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。</p>\n<h4 id=\"HTTP中的缓存控制\"><a href=\"#HTTP中的缓存控制\" class=\"headerlink\" title=\"HTTP中的缓存控制\"></a>HTTP中的缓存控制</h4><p>HTTP/1.1定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>\n<ul>\n<li>禁止缓存: <code>Cache-Control: no-store</code></li>\n<li>强制确认缓存: <code>Cache-Control: no-cache</code></li>\n<li>私有缓存和公共缓存: <code>Cache-Control: private/public</code></li>\n<li>缓存过期机制: <code>Cache-Control: max-age=31536000</code></li>\n<li>缓存验证确认: <code>Cache-Control: must-revalidate</code></li>\n</ul>\n","site":{"data":{}},"more":"<h4 id=\"缓存用来做什么？\"><a href=\"#缓存用来做什么？\" class=\"headerlink\" title=\"缓存用来做什么？\"></a>缓存用来做什么？</h4><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>\n<p>缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p>\n<p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。</p>\n<h4 id=\"HTTP中的缓存控制\"><a href=\"#HTTP中的缓存控制\" class=\"headerlink\" title=\"HTTP中的缓存控制\"></a>HTTP中的缓存控制</h4><p>HTTP/1.1定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>\n<ul>\n<li>禁止缓存: <code>Cache-Control: no-store</code></li>\n<li>强制确认缓存: <code>Cache-Control: no-cache</code></li>\n<li>私有缓存和公共缓存: <code>Cache-Control: private/public</code></li>\n<li>缓存过期机制: <code>Cache-Control: max-age=31536000</code></li>\n<li>缓存验证确认: <code>Cache-Control: must-revalidate</code></li>\n</ul>\n"},{"title":"Javascript 基础知识点总结","date":"2019-08-11T08:00:00.000Z","excerpt":"基础知识点，不能再基础的内容，强烈建议直接前往“Speaking JavaScript”相关笔记深入了解。","thumbnail":"","_content":"#### 五种基础类型（ES5后6种）\n- number\n- string\n- boolean\n- undefined\n- null\n- Symbol\n\n对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。\n\n#### 类型判断\n- typeof 返回值\n- instanceof 操作符\n- Object.prototype.toString获取 `[[class]]`(准确)\n\n#### 关于函数\n函数声明 function foo(){}\n函数表达式 var foo = function () {}\n##### 区别\n- 函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值\n- 函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式\n```javascript\nvar getName//变量被提升，此时为undefined\n\ngetName()//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了\nvar getName = function() {\n\tconsole.log('wscat')\n}//函数表达式此时才开始覆盖函数声明的定义\ngetName()//wscat\nfunction getName() {\n\tconsole.log('oaoafly')\n}\ngetName()//wscat 这里就执行了函数表达式的值\n```\n\n#### 函数优化\n如果我们的代码中返回多个闭包的情况，如果没有手动设置null的话，内存不会被自动释放。\n\n#### 立即执行函数 & 匿名函数\n在一个表达式后面加上括号()，该表达式会立即执行, 但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。\n\n#### 闭包\n首先了解一个JavaScript变量的作用域,\n无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。但是通过闭包，可以在函数外面访问到内部的变量！比如:\n```javascript\nfunction f1(){\n　　var n=999;\n　　function f2(){\n　　　　alert(n); // 999\n　　}\n}\n```\n\n#### 事件监听\n这两种方式确定了事件执行的前后顺序，只不过后来W3C对DOM2的事件模型给出了一个规范\n[http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]：首先进入事件捕获阶段->达到元素后->进入事件冒泡阶段。\n\n#### 原型继承\n在Javascript中，每个函数都有一个原型属性prototype指向函数自身的原型，而由这个函数创建的对象也有一个`__proto__`\n属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个`__proto__`指向自己的原型，这样逐层深入直到Object对象的原型(null)，这样就形成了原型链。\n\n#### This\n除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。\n还有个例外，就是使用了`\"use strict\";`。此时this是`undefined`。\n当用调用函数时使用了new关键字，此刻this指代一个新的上下文，不再指向全局this。\n注意原型链底层函数中对`this`的操作会覆盖上层的值。\n解决方法就是传递的时候使用`bind`方法显示指明上下文，`bind`方法是所有函数或方法都具有的。同时也可以使用`apply`或`call`\n来调用该方法或函数，让它在一个新的上下文中执行。\n在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。除非你通过`bind`人为改变了事件处理器的执行上下文。\n\n#### 对象\n我们说的通过引用进行对象比较是:两个对象的值是否相同取决于它们是否指向相同的底层对象。","source":"_posts/fe/javascript-基础知识点总结.md","raw":"---\ntags: []\ncategories: Frontend\ntitle: Javascript 基础知识点总结\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: 基础知识点，不能再基础的内容，强烈建议直接前往“Speaking JavaScript”相关笔记深入了解。\nthumbnail: ''\n\n---\n#### 五种基础类型（ES5后6种）\n- number\n- string\n- boolean\n- undefined\n- null\n- Symbol\n\n对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。\n\n#### 类型判断\n- typeof 返回值\n- instanceof 操作符\n- Object.prototype.toString获取 `[[class]]`(准确)\n\n#### 关于函数\n函数声明 function foo(){}\n函数表达式 var foo = function () {}\n##### 区别\n- 函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值\n- 函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式\n```javascript\nvar getName//变量被提升，此时为undefined\n\ngetName()//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了\nvar getName = function() {\n\tconsole.log('wscat')\n}//函数表达式此时才开始覆盖函数声明的定义\ngetName()//wscat\nfunction getName() {\n\tconsole.log('oaoafly')\n}\ngetName()//wscat 这里就执行了函数表达式的值\n```\n\n#### 函数优化\n如果我们的代码中返回多个闭包的情况，如果没有手动设置null的话，内存不会被自动释放。\n\n#### 立即执行函数 & 匿名函数\n在一个表达式后面加上括号()，该表达式会立即执行, 但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。\n\n#### 闭包\n首先了解一个JavaScript变量的作用域,\n无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。但是通过闭包，可以在函数外面访问到内部的变量！比如:\n```javascript\nfunction f1(){\n　　var n=999;\n　　function f2(){\n　　　　alert(n); // 999\n　　}\n}\n```\n\n#### 事件监听\n这两种方式确定了事件执行的前后顺序，只不过后来W3C对DOM2的事件模型给出了一个规范\n[http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]：首先进入事件捕获阶段->达到元素后->进入事件冒泡阶段。\n\n#### 原型继承\n在Javascript中，每个函数都有一个原型属性prototype指向函数自身的原型，而由这个函数创建的对象也有一个`__proto__`\n属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个`__proto__`指向自己的原型，这样逐层深入直到Object对象的原型(null)，这样就形成了原型链。\n\n#### This\n除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。\n还有个例外，就是使用了`\"use strict\";`。此时this是`undefined`。\n当用调用函数时使用了new关键字，此刻this指代一个新的上下文，不再指向全局this。\n注意原型链底层函数中对`this`的操作会覆盖上层的值。\n解决方法就是传递的时候使用`bind`方法显示指明上下文，`bind`方法是所有函数或方法都具有的。同时也可以使用`apply`或`call`\n来调用该方法或函数，让它在一个新的上下文中执行。\n在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。除非你通过`bind`人为改变了事件处理器的执行上下文。\n\n#### 对象\n我们说的通过引用进行对象比较是:两个对象的值是否相同取决于它们是否指向相同的底层对象。","slug":"fe/javascript-基础知识点总结","published":1,"updated":"2020-11-17T14:15:40.852Z","_id":"ckdev5ia50005j1wt2bgl4ezl","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"五种基础类型（ES5后6种）\"><a href=\"#五种基础类型（ES5后6种）\" class=\"headerlink\" title=\"五种基础类型（ES5后6种）\"></a>五种基础类型（ES5后6种）</h4><ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n<li>Symbol</li>\n</ul>\n<p>对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。</p>\n<h4 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h4><ul>\n<li>typeof 返回值</li>\n<li>instanceof 操作符</li>\n<li>Object.prototype.toString获取 <code>[[class]]</code>(准确)</li>\n</ul>\n<h4 id=\"关于函数\"><a href=\"#关于函数\" class=\"headerlink\" title=\"关于函数\"></a>关于函数</h4><p>函数声明 function foo(){}<br>函数表达式 var foo = function () {}</p>\n<h5 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h5><ul>\n<li>函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值</li>\n<li>函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getName<span class=\"comment\">//变量被提升，此时为undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">getName()<span class=\"comment\">//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;wscat&#x27;</span>)</span><br><span class=\"line\">&#125;<span class=\"comment\">//函数表达式此时才开始覆盖函数声明的定义</span></span><br><span class=\"line\">getName()<span class=\"comment\">//wscat</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;oaoafly&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getName()<span class=\"comment\">//wscat 这里就执行了函数表达式的值</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"函数优化\"><a href=\"#函数优化\" class=\"headerlink\" title=\"函数优化\"></a>函数优化</h4><p>如果我们的代码中返回多个闭包的情况，如果没有手动设置null的话，内存不会被自动释放。</p>\n<h4 id=\"立即执行函数-amp-匿名函数\"><a href=\"#立即执行函数-amp-匿名函数\" class=\"headerlink\" title=\"立即执行函数 &amp; 匿名函数\"></a>立即执行函数 &amp; 匿名函数</h4><p>在一个表达式后面加上括号()，该表达式会立即执行, 但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。</p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>首先了解一个JavaScript变量的作用域,<br>无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。但是通过闭包，可以在函数外面访问到内部的变量！比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　　　alert(n); <span class=\"comment\">// 999</span></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h4><p>这两种方式确定了事件执行的前后顺序，只不过后来W3C对DOM2的事件模型给出了一个规范<br>[<a href=\"http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]%EF%BC%9A%E9%A6%96%E5%85%88%E8%BF%9B%E5%85%A5%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5-&gt;%E8%BE%BE%E5%88%B0%E5%85%83%E7%B4%A0%E5%90%8E-&gt;%E8%BF%9B%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E3%80%82\">http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]：首先进入事件捕获阶段-&gt;达到元素后-&gt;进入事件冒泡阶段。</a></p>\n<h4 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h4><p>在Javascript中，每个函数都有一个原型属性prototype指向函数自身的原型，而由这个函数创建的对象也有一个<code>__proto__</code><br>属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个<code>__proto__</code>指向自己的原型，这样逐层深入直到Object对象的原型(null)，这样就形成了原型链。</p>\n<h4 id=\"This\"><a href=\"#This\" class=\"headerlink\" title=\"This\"></a>This</h4><p>除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。<br>还有个例外，就是使用了<code>&quot;use strict&quot;;</code>。此时this是<code>undefined</code>。<br>当用调用函数时使用了new关键字，此刻this指代一个新的上下文，不再指向全局this。<br>注意原型链底层函数中对<code>this</code>的操作会覆盖上层的值。<br>解决方法就是传递的时候使用<code>bind</code>方法显示指明上下文，<code>bind</code>方法是所有函数或方法都具有的。同时也可以使用<code>apply</code>或<code>call</code><br>来调用该方法或函数，让它在一个新的上下文中执行。<br>在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。除非你通过<code>bind</code>人为改变了事件处理器的执行上下文。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>我们说的通过引用进行对象比较是:两个对象的值是否相同取决于它们是否指向相同的底层对象。</p>\n","site":{"data":{}},"more":"<h4 id=\"五种基础类型（ES5后6种）\"><a href=\"#五种基础类型（ES5后6种）\" class=\"headerlink\" title=\"五种基础类型（ES5后6种）\"></a>五种基础类型（ES5后6种）</h4><ul>\n<li>number</li>\n<li>string</li>\n<li>boolean</li>\n<li>undefined</li>\n<li>null</li>\n<li>Symbol</li>\n</ul>\n<p>对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。</p>\n<h4 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h4><ul>\n<li>typeof 返回值</li>\n<li>instanceof 操作符</li>\n<li>Object.prototype.toString获取 <code>[[class]]</code>(准确)</li>\n</ul>\n<h4 id=\"关于函数\"><a href=\"#关于函数\" class=\"headerlink\" title=\"关于函数\"></a>关于函数</h4><p>函数声明 function foo(){}<br>函数表达式 var foo = function () {}</p>\n<h5 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h5><ul>\n<li>函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值</li>\n<li>函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getName<span class=\"comment\">//变量被提升，此时为undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">getName()<span class=\"comment\">//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;wscat&#x27;</span>)</span><br><span class=\"line\">&#125;<span class=\"comment\">//函数表达式此时才开始覆盖函数声明的定义</span></span><br><span class=\"line\">getName()<span class=\"comment\">//wscat</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;oaoafly&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getName()<span class=\"comment\">//wscat 这里就执行了函数表达式的值</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"函数优化\"><a href=\"#函数优化\" class=\"headerlink\" title=\"函数优化\"></a>函数优化</h4><p>如果我们的代码中返回多个闭包的情况，如果没有手动设置null的话，内存不会被自动释放。</p>\n<h4 id=\"立即执行函数-amp-匿名函数\"><a href=\"#立即执行函数-amp-匿名函数\" class=\"headerlink\" title=\"立即执行函数 &amp; 匿名函数\"></a>立即执行函数 &amp; 匿名函数</h4><p>在一个表达式后面加上括号()，该表达式会立即执行, 但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。</p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>首先了解一个JavaScript变量的作用域,<br>无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。但是通过闭包，可以在函数外面访问到内部的变量！比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　<span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</span><br><span class=\"line\">　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">　　　　alert(n); <span class=\"comment\">// 999</span></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"事件监听\"><a href=\"#事件监听\" class=\"headerlink\" title=\"事件监听\"></a>事件监听</h4><p>这两种方式确定了事件执行的前后顺序，只不过后来W3C对DOM2的事件模型给出了一个规范<br>[<a href=\"http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]%EF%BC%9A%E9%A6%96%E5%85%88%E8%BF%9B%E5%85%A5%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%E9%98%B6%E6%AE%B5-&gt;%E8%BE%BE%E5%88%B0%E5%85%83%E7%B4%A0%E5%90%8E-&gt;%E8%BF%9B%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E9%98%B6%E6%AE%B5%E3%80%82\">http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]：首先进入事件捕获阶段-&gt;达到元素后-&gt;进入事件冒泡阶段。</a></p>\n<h4 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h4><p>在Javascript中，每个函数都有一个原型属性prototype指向函数自身的原型，而由这个函数创建的对象也有一个<code>__proto__</code><br>属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个<code>__proto__</code>指向自己的原型，这样逐层深入直到Object对象的原型(null)，这样就形成了原型链。</p>\n<h4 id=\"This\"><a href=\"#This\" class=\"headerlink\" title=\"This\"></a>This</h4><p>除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。<br>还有个例外，就是使用了<code>&quot;use strict&quot;;</code>。此时this是<code>undefined</code>。<br>当用调用函数时使用了new关键字，此刻this指代一个新的上下文，不再指向全局this。<br>注意原型链底层函数中对<code>this</code>的操作会覆盖上层的值。<br>解决方法就是传递的时候使用<code>bind</code>方法显示指明上下文，<code>bind</code>方法是所有函数或方法都具有的。同时也可以使用<code>apply</code>或<code>call</code><br>来调用该方法或函数，让它在一个新的上下文中执行。<br>在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。除非你通过<code>bind</code>人为改变了事件处理器的执行上下文。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>我们说的通过引用进行对象比较是:两个对象的值是否相同取决于它们是否指向相同的底层对象。</p>\n"},{"title":"HTTP状态码","date":"2019-08-19T08:00:00.000Z","excerpt":"HTTP常见的一些状态码，当然，其实有一些业务中的确用不到。","thumbnail":"","_content":"- 2XX 成功\n\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n204 No content，表示请求成功，但响应报文不含实体的主体部分\n206 Partial Content，进行范围请求\n\n- 3XX 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n307 temporary redirect，临时重定向，和302含义相同\n\n- 4XX 客户端错误\n\n400 bad request，请求报文存在语法错误\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n403 forbidden，表示对请求资源的访问被服务器拒绝\n404 not found，表示在服务器上没有找到请求的资源\n\n- 5XX 服务器错误\n\n500 internal sever error，表示服务器端在执行请求时发生了错误\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n\n> 作者：yck\n> 链接：https://juejin.im/post/5872309261ff4b005c4580d4\n> 来源：掘金","source":"_posts/fe/http状态码.md","raw":"---\ntags:\n- HTTP\ncategories: Frontend\ntitle: HTTP状态码\ndate: 2019-08-20T00:00:00.000+08:00\nexcerpt: HTTP常见的一些状态码，当然，其实有一些业务中的确用不到。\nthumbnail: ''\n\n---\n- 2XX 成功\n\n200 OK，表示从客户端发来的请求在服务器端被正确处理\n204 No content，表示请求成功，但响应报文不含实体的主体部分\n206 Partial Content，进行范围请求\n\n- 3XX 重定向\n\n301 moved permanently，永久性重定向，表示资源已被分配了新的 URL\n302 found，临时性重定向，表示资源临时被分配了新的 URL\n303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源\n304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况\n307 temporary redirect，临时重定向，和302含义相同\n\n- 4XX 客户端错误\n\n400 bad request，请求报文存在语法错误\n401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息\n403 forbidden，表示对请求资源的访问被服务器拒绝\n404 not found，表示在服务器上没有找到请求的资源\n\n- 5XX 服务器错误\n\n500 internal sever error，表示服务器端在执行请求时发生了错误\n503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求\n\n> 作者：yck\n> 链接：https://juejin.im/post/5872309261ff4b005c4580d4\n> 来源：掘金","slug":"fe/http状态码","published":1,"updated":"2020-08-01T18:21:52.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ia60006j1wt7zpwcsrj","content":"<ul>\n<li>2XX 成功</li>\n</ul>\n<p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>204 No content，表示请求成功，但响应报文不含实体的主体部分<br>206 Partial Content，进行范围请求</p>\n<ul>\n<li>3XX 重定向</li>\n</ul>\n<p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>307 temporary redirect，临时重定向，和302含义相同</p>\n<ul>\n<li>4XX 客户端错误</li>\n</ul>\n<p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p>\n<ul>\n<li>5XX 服务器错误</li>\n</ul>\n<p>500 internal sever error，表示服务器端在执行请求时发生了错误<br>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>\n<blockquote>\n<p>作者：yck<br>链接：<a href=\"https://juejin.im/post/5872309261ff4b005c4580d4\">https://juejin.im/post/5872309261ff4b005c4580d4</a><br>来源：掘金</p>\n</blockquote>\n","site":{"data":{}},"more":"<ul>\n<li>2XX 成功</li>\n</ul>\n<p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>204 No content，表示请求成功，但响应报文不含实体的主体部分<br>206 Partial Content，进行范围请求</p>\n<ul>\n<li>3XX 重定向</li>\n</ul>\n<p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>307 temporary redirect，临时重定向，和302含义相同</p>\n<ul>\n<li>4XX 客户端错误</li>\n</ul>\n<p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p>\n<ul>\n<li>5XX 服务器错误</li>\n</ul>\n<p>500 internal sever error，表示服务器端在执行请求时发生了错误<br>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>\n<blockquote>\n<p>作者：yck<br>链接：<a href=\"https://juejin.im/post/5872309261ff4b005c4580d4\">https://juejin.im/post/5872309261ff4b005c4580d4</a><br>来源：掘金</p>\n</blockquote>\n"},{"date":"2020-03-17T23:24:18.000Z","title":"JavaScript的模块机制","excerpt":"模块机制还是一个非常需要注意的细节，这里简单说明四种常见的模块机制，主要区分AMD，CMD，ES6 Module。","thumbnail":"","_content":"目前，JavaScript生态下最常见的模块机制大致分为以下四种：\n\n- AMD\n- CMD\n- CommonJS\n- ES6 Module\n\n下面逐个分析每个机制的特点。\n\n## CommonJS\n\n- 环境：Node.js\n- 全局方法：`require(module) & exports || module.exports`\n\n### exports 与 module.exports\n\n在Node.js环境中，`exports, require, module`都是node的全局对象，`exports`是`module.exports`的引用。\n\n## AMD(\"Asynchronous Module Definition\")\n\n- 环境：Browser\n- 全局方法：`require([module], callback)`\n\n> 这里需要注意，所有的浏览器环境的模块化机制，都要避免同步引入，因为不同于服务端可以直接进行磁盘读取，很快即可使用对应模块，浏览器端需要异步请求，否则会造成假死的状态。因此， __浏览器端的模块化机制都是异步加载的__ 。\n\nAMD规范通过回调机制实现了异步加载，在加载完成后执行callback。\n\n## CMD(\"Common Module Definition\")\n\n- 环境：Browser(Sea.js)\n- 全局方法：`define() & seajs.use()`\n\n## ES6 Modules\n\n- 环境：Browser(目前工具通过工具已经支持Node.js)\n- 全局方法：`export & import`\n\n与CommonJS最主要有两点区别\n\n1. ES6模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝；\n2. ES6模块编译时执行，而 CommonJS 模块总是在运行时加载。\n\n### export的使用\n\n```javascript\nexport const firstName = \"Michael\";\n// const firstName = \"Michael\";\n// export { firstName }; // 不能直接export firstName是因为export需要导出一个“接口”而不能是一个值。\n```\n\n### export default\n\n为模块指定默认输出，如果import接口时，可以用任意名称指向export default输出的方法","source":"_posts/fe/javascript的模块机制.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-03-18T15:24:18.000+08:00\ntitle: JavaScript的模块机制\nexcerpt: 模块机制还是一个非常需要注意的细节，这里简单说明四种常见的模块机制，主要区分AMD，CMD，ES6 Module。\nthumbnail: ''\n\n---\n目前，JavaScript生态下最常见的模块机制大致分为以下四种：\n\n- AMD\n- CMD\n- CommonJS\n- ES6 Module\n\n下面逐个分析每个机制的特点。\n\n## CommonJS\n\n- 环境：Node.js\n- 全局方法：`require(module) & exports || module.exports`\n\n### exports 与 module.exports\n\n在Node.js环境中，`exports, require, module`都是node的全局对象，`exports`是`module.exports`的引用。\n\n## AMD(\"Asynchronous Module Definition\")\n\n- 环境：Browser\n- 全局方法：`require([module], callback)`\n\n> 这里需要注意，所有的浏览器环境的模块化机制，都要避免同步引入，因为不同于服务端可以直接进行磁盘读取，很快即可使用对应模块，浏览器端需要异步请求，否则会造成假死的状态。因此， __浏览器端的模块化机制都是异步加载的__ 。\n\nAMD规范通过回调机制实现了异步加载，在加载完成后执行callback。\n\n## CMD(\"Common Module Definition\")\n\n- 环境：Browser(Sea.js)\n- 全局方法：`define() & seajs.use()`\n\n## ES6 Modules\n\n- 环境：Browser(目前工具通过工具已经支持Node.js)\n- 全局方法：`export & import`\n\n与CommonJS最主要有两点区别\n\n1. ES6模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝；\n2. ES6模块编译时执行，而 CommonJS 模块总是在运行时加载。\n\n### export的使用\n\n```javascript\nexport const firstName = \"Michael\";\n// const firstName = \"Michael\";\n// export { firstName }; // 不能直接export firstName是因为export需要导出一个“接口”而不能是一个值。\n```\n\n### export default\n\n为模块指定默认输出，如果import接口时，可以用任意名称指向export default输出的方法","slug":"fe/javascript的模块机制","published":1,"updated":"2020-08-01T18:21:52.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ia70007j1wt4xqvhqbw","content":"<p>目前，JavaScript生态下最常见的模块机制大致分为以下四种：</p>\n<ul>\n<li>AMD</li>\n<li>CMD</li>\n<li>CommonJS</li>\n<li>ES6 Module</li>\n</ul>\n<p>下面逐个分析每个机制的特点。</p>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><ul>\n<li>环境：Node.js</li>\n<li>全局方法：<code>require(module) &amp; exports || module.exports</code></li>\n</ul>\n<h3 id=\"exports-与-module-exports\"><a href=\"#exports-与-module-exports\" class=\"headerlink\" title=\"exports 与 module.exports\"></a>exports 与 module.exports</h3><p>在Node.js环境中，<code>exports, require, module</code>都是node的全局对象，<code>exports</code>是<code>module.exports</code>的引用。</p>\n<h2 id=\"AMD-“Asynchronous-Module-Definition”\"><a href=\"#AMD-“Asynchronous-Module-Definition”\" class=\"headerlink\" title=\"AMD(“Asynchronous Module Definition”)\"></a>AMD(“Asynchronous Module Definition”)</h2><ul>\n<li>环境：Browser</li>\n<li>全局方法：<code>require([module], callback)</code></li>\n</ul>\n<blockquote>\n<p>这里需要注意，所有的浏览器环境的模块化机制，都要避免同步引入，因为不同于服务端可以直接进行磁盘读取，很快即可使用对应模块，浏览器端需要异步请求，否则会造成假死的状态。因此， <strong>浏览器端的模块化机制都是异步加载的</strong> 。</p>\n</blockquote>\n<p>AMD规范通过回调机制实现了异步加载，在加载完成后执行callback。</p>\n<h2 id=\"CMD-“Common-Module-Definition”\"><a href=\"#CMD-“Common-Module-Definition”\" class=\"headerlink\" title=\"CMD(“Common Module Definition”)\"></a>CMD(“Common Module Definition”)</h2><ul>\n<li>环境：Browser(Sea.js)</li>\n<li>全局方法：<code>define() &amp; seajs.use()</code></li>\n</ul>\n<h2 id=\"ES6-Modules\"><a href=\"#ES6-Modules\" class=\"headerlink\" title=\"ES6 Modules\"></a>ES6 Modules</h2><ul>\n<li>环境：Browser(目前工具通过工具已经支持Node.js)</li>\n<li>全局方法：<code>export &amp; import</code></li>\n</ul>\n<p>与CommonJS最主要有两点区别</p>\n<ol>\n<li>ES6模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝；</li>\n<li>ES6模块编译时执行，而 CommonJS 模块总是在运行时加载。</li>\n</ol>\n<h3 id=\"export的使用\"><a href=\"#export的使用\" class=\"headerlink\" title=\"export的使用\"></a>export的使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> firstName = <span class=\"string\">\"Michael\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// const firstName = \"Michael\";</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; firstName &#125;; // 不能直接export firstName是因为export需要导出一个“接口”而不能是一个值。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"export-default\"><a href=\"#export-default\" class=\"headerlink\" title=\"export default\"></a>export default</h3><p>为模块指定默认输出，如果import接口时，可以用任意名称指向export default输出的方法</p>\n","site":{"data":{}},"more":"<p>目前，JavaScript生态下最常见的模块机制大致分为以下四种：</p>\n<ul>\n<li>AMD</li>\n<li>CMD</li>\n<li>CommonJS</li>\n<li>ES6 Module</li>\n</ul>\n<p>下面逐个分析每个机制的特点。</p>\n<h2 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h2><ul>\n<li>环境：Node.js</li>\n<li>全局方法：<code>require(module) &amp; exports || module.exports</code></li>\n</ul>\n<h3 id=\"exports-与-module-exports\"><a href=\"#exports-与-module-exports\" class=\"headerlink\" title=\"exports 与 module.exports\"></a>exports 与 module.exports</h3><p>在Node.js环境中，<code>exports, require, module</code>都是node的全局对象，<code>exports</code>是<code>module.exports</code>的引用。</p>\n<h2 id=\"AMD-“Asynchronous-Module-Definition”\"><a href=\"#AMD-“Asynchronous-Module-Definition”\" class=\"headerlink\" title=\"AMD(“Asynchronous Module Definition”)\"></a>AMD(“Asynchronous Module Definition”)</h2><ul>\n<li>环境：Browser</li>\n<li>全局方法：<code>require([module], callback)</code></li>\n</ul>\n<blockquote>\n<p>这里需要注意，所有的浏览器环境的模块化机制，都要避免同步引入，因为不同于服务端可以直接进行磁盘读取，很快即可使用对应模块，浏览器端需要异步请求，否则会造成假死的状态。因此， <strong>浏览器端的模块化机制都是异步加载的</strong> 。</p>\n</blockquote>\n<p>AMD规范通过回调机制实现了异步加载，在加载完成后执行callback。</p>\n<h2 id=\"CMD-“Common-Module-Definition”\"><a href=\"#CMD-“Common-Module-Definition”\" class=\"headerlink\" title=\"CMD(“Common Module Definition”)\"></a>CMD(“Common Module Definition”)</h2><ul>\n<li>环境：Browser(Sea.js)</li>\n<li>全局方法：<code>define() &amp; seajs.use()</code></li>\n</ul>\n<h2 id=\"ES6-Modules\"><a href=\"#ES6-Modules\" class=\"headerlink\" title=\"ES6 Modules\"></a>ES6 Modules</h2><ul>\n<li>环境：Browser(目前工具通过工具已经支持Node.js)</li>\n<li>全局方法：<code>export &amp; import</code></li>\n</ul>\n<p>与CommonJS最主要有两点区别</p>\n<ol>\n<li>ES6模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝；</li>\n<li>ES6模块编译时执行，而 CommonJS 模块总是在运行时加载。</li>\n</ol>\n<h3 id=\"export的使用\"><a href=\"#export的使用\" class=\"headerlink\" title=\"export的使用\"></a>export的使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> firstName = <span class=\"string\">\"Michael\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// const firstName = \"Michael\";</span></span><br><span class=\"line\"><span class=\"comment\">// export &#123; firstName &#125;; // 不能直接export firstName是因为export需要导出一个“接口”而不能是一个值。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"export-default\"><a href=\"#export-default\" class=\"headerlink\" title=\"export default\"></a>export default</h3><p>为模块指定默认输出，如果import接口时，可以用任意名称指向export default输出的方法</p>\n"},{"title":"JavaScript的原型链与继承","date":"2019-08-21T08:00:00.000Z","excerpt":"也是经典面试题与概念，简单介绍一下其中的区别与链条关系，后续可以深入再增加一篇文章。","thumbnail":"","_content":"> 感谢[JS原型链与继承别再被问倒了 - 路易斯@juejin](https://juejin.im/post/58f94c9bb123db411953691b)\n\n#### JavaScript的继承\n\n继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的.\n\n#### 构造函数、原型和实例\n\n> 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.\n\n> 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.\n\n所以我们有`constructor1.prototype = instance2`\n\n如果试图引用constructor1构造的实例instance1的某个属性p1:\n1).首先会在instance1内部属性中找一遍;\n2).接着会在instance1.**proto**(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;\n3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.**proto**(constructor2.prototype)中寻找...直至Object的原型对象\n\n![原型链与原型对象](https://cdn.sparkling.land/public/blog/images/IMG_2448_rmoxtn.jpg)","source":"_posts/fe/javascript的原型链与继承.md","raw":"---\ntags:\n- JavaScript\ncategories: Frontend\ntitle: JavaScript的原型链与继承\ndate: 2019-08-21T16:00:00.000+00:00\nexcerpt: 也是经典面试题与概念，简单介绍一下其中的区别与链条关系，后续可以深入再增加一篇文章。\nthumbnail: ''\n\n---\n> 感谢[JS原型链与继承别再被问倒了 - 路易斯@juejin](https://juejin.im/post/58f94c9bb123db411953691b)\n\n#### JavaScript的继承\n\n继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的.\n\n#### 构造函数、原型和实例\n\n> 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.\n\n> 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.\n\n所以我们有`constructor1.prototype = instance2`\n\n如果试图引用constructor1构造的实例instance1的某个属性p1:\n1).首先会在instance1内部属性中找一遍;\n2).接着会在instance1.**proto**(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;\n3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.**proto**(constructor2.prototype)中寻找...直至Object的原型对象\n\n![原型链与原型对象](https://cdn.sparkling.land/public/blog/images/IMG_2448_rmoxtn.jpg)","slug":"fe/javascript的原型链与继承","published":1,"updated":"2020-08-01T18:21:52.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iab000aj1wt5nyi8axe","content":"<blockquote>\n<p>感谢<a href=\"https://juejin.im/post/58f94c9bb123db411953691b\">JS原型链与继承别再被问倒了 - 路易斯@juejin</a></p>\n</blockquote>\n<h4 id=\"JavaScript的继承\"><a href=\"#JavaScript的继承\" class=\"headerlink\" title=\"JavaScript的继承\"></a>JavaScript的继承</h4><p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的.</p>\n<h4 id=\"构造函数、原型和实例\"><a href=\"#构造函数、原型和实例\" class=\"headerlink\" title=\"构造函数、原型和实例\"></a>构造函数、原型和实例</h4><blockquote>\n<p>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.</p>\n</blockquote>\n<blockquote>\n<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>\n</blockquote>\n<p>所以我们有<code>constructor1.prototype = instance2</code></p>\n<p>如果试图引用constructor1构造的实例instance1的某个属性p1:<br>1).首先会在instance1内部属性中找一遍;<br>2).接着会在instance1.<strong>proto</strong>(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;<br>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.<strong>proto</strong>(constructor2.prototype)中寻找…直至Object的原型对象</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/IMG_2448_rmoxtn.jpg\" alt=\"原型链与原型对象\"></p>\n","site":{"data":{}},"more":"<blockquote>\n<p>感谢<a href=\"https://juejin.im/post/58f94c9bb123db411953691b\">JS原型链与继承别再被问倒了 - 路易斯@juejin</a></p>\n</blockquote>\n<h4 id=\"JavaScript的继承\"><a href=\"#JavaScript的继承\" class=\"headerlink\" title=\"JavaScript的继承\"></a>JavaScript的继承</h4><p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的.</p>\n<h4 id=\"构造函数、原型和实例\"><a href=\"#构造函数、原型和实例\" class=\"headerlink\" title=\"构造函数、原型和实例\"></a>构造函数、原型和实例</h4><blockquote>\n<p>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针.</p>\n</blockquote>\n<blockquote>\n<p>如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性.</p>\n</blockquote>\n<p>所以我们有<code>constructor1.prototype = instance2</code></p>\n<p>如果试图引用constructor1构造的实例instance1的某个属性p1:<br>1).首先会在instance1内部属性中找一遍;<br>2).接着会在instance1.<strong>proto</strong>(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;<br>3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.<strong>proto</strong>(constructor2.prototype)中寻找…直至Object的原型对象</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/IMG_2448_rmoxtn.jpg\" alt=\"原型链与原型对象\"></p>\n"},{"title":"JS中的异步链式调用","date":"2020-02-16T08:00:00.000Z","excerpt":"经典面试题，这里给出一种思路较为直接的解法。","thumbnail":"","_content":"```javascript\nlet EatMan = function () {\n  this.task = [] // 声明一个task数组，模拟事件循环队列；\n  this.taskNum = []\n  let fn = () => {\n    this.next();\n  }\n  this.task.push(fn);\n  setTimeout(() => {\n    this.next();\n  }, 0)\n  return this;\n}\n\nEatMan.prototype.eat = function (str) { // 为了task任务队列一致性，将eat也转换为setTimeout异步\n  const _this = this\n  var fn = () => {\n    setTimeout(() => {\n      console.log(str)\n      _this.next()\n    }, 0)\n  }\n  this.task.push(fn)\n  this.taskNum.push(str)\n  return this // 返回this使得可以链式操作\n}\nEatMan.prototype.sleep = function (ms) { // setTimeout的任务，需要在完成时再调用next继续执行\n  const _this = this\n  var fn = () => {\n    setTimeout(() => {\n      console.log('this is normal sleep.')\n      _this.next()\n    }, ms * 1000)\n  }\n  this.task.push(fn)\n  this.taskNum.push('sleep')\n  return this\n}\nEatMan.prototype.firstSleep = function (ms) { // 与sleep类似，注意需要在队首加入\n  const _this = this\n  var fn = () => {\n    setTimeout(() => {\n      console.log('this is first sleep.')\n      _this.next()\n    }, ms * 1000)\n  }\n  this.task.unshift(fn)\n  this.taskNum.unshift('firstSleep')\n  return this\n}\nEatMan.prototype.next = function () { // 通过next指针完成出队列操作，使之拥有顺序\n  let fn = this.task.shift()\n  fn && fn()\n}\n\nlet eatMan = new EatMan()\neatMan.eat('apple').eat('orange').sleep(3).eat('banana').firstSleep(3)\nconsole.log(eatMan.taskNum)\n```","source":"_posts/fe/js中的异步链式调用.md","raw":"---\ntags:\n- JavaScript\ncategories: Frontend\ntitle: JS中的异步链式调用\ndate: 2020-02-16T16:00:00.000+00:00\nexcerpt: 经典面试题，这里给出一种思路较为直接的解法。\nthumbnail: ''\n\n---\n```javascript\nlet EatMan = function () {\n  this.task = [] // 声明一个task数组，模拟事件循环队列；\n  this.taskNum = []\n  let fn = () => {\n    this.next();\n  }\n  this.task.push(fn);\n  setTimeout(() => {\n    this.next();\n  }, 0)\n  return this;\n}\n\nEatMan.prototype.eat = function (str) { // 为了task任务队列一致性，将eat也转换为setTimeout异步\n  const _this = this\n  var fn = () => {\n    setTimeout(() => {\n      console.log(str)\n      _this.next()\n    }, 0)\n  }\n  this.task.push(fn)\n  this.taskNum.push(str)\n  return this // 返回this使得可以链式操作\n}\nEatMan.prototype.sleep = function (ms) { // setTimeout的任务，需要在完成时再调用next继续执行\n  const _this = this\n  var fn = () => {\n    setTimeout(() => {\n      console.log('this is normal sleep.')\n      _this.next()\n    }, ms * 1000)\n  }\n  this.task.push(fn)\n  this.taskNum.push('sleep')\n  return this\n}\nEatMan.prototype.firstSleep = function (ms) { // 与sleep类似，注意需要在队首加入\n  const _this = this\n  var fn = () => {\n    setTimeout(() => {\n      console.log('this is first sleep.')\n      _this.next()\n    }, ms * 1000)\n  }\n  this.task.unshift(fn)\n  this.taskNum.unshift('firstSleep')\n  return this\n}\nEatMan.prototype.next = function () { // 通过next指针完成出队列操作，使之拥有顺序\n  let fn = this.task.shift()\n  fn && fn()\n}\n\nlet eatMan = new EatMan()\neatMan.eat('apple').eat('orange').sleep(3).eat('banana').firstSleep(3)\nconsole.log(eatMan.taskNum)\n```","slug":"fe/js中的异步链式调用","published":1,"updated":"2020-08-01T18:21:52.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iac000bj1wt8det7fic","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> EatMan = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task = [] <span class=\"comment\">// 声明一个task数组，模拟事件循环队列；</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next();</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EatMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123; <span class=\"comment\">// 为了task任务队列一致性，将eat也转换为setTimeout异步</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(str)</span><br><span class=\"line\">      _this.next()</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum.push(str)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> <span class=\"comment\">// 返回this使得可以链式操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EatMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123; <span class=\"comment\">// setTimeout的任务，需要在完成时再调用next继续执行</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is normal sleep.'</span>)</span><br><span class=\"line\">      _this.next()</span><br><span class=\"line\">    &#125;, ms * <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum.push(<span class=\"string\">'sleep'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EatMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123; <span class=\"comment\">// 与sleep类似，注意需要在队首加入</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is first sleep.'</span>)</span><br><span class=\"line\">      _this.next()</span><br><span class=\"line\">    &#125;, ms * <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum.unshift(<span class=\"string\">'firstSleep'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EatMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 通过next指针完成出队列操作，使之拥有顺序</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> fn = <span class=\"keyword\">this</span>.task.shift()</span><br><span class=\"line\">  fn &amp;&amp; fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> eatMan = <span class=\"keyword\">new</span> EatMan()</span><br><span class=\"line\">eatMan.eat(<span class=\"string\">'apple'</span>).eat(<span class=\"string\">'orange'</span>).sleep(<span class=\"number\">3</span>).eat(<span class=\"string\">'banana'</span>).firstSleep(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(eatMan.taskNum)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> EatMan = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task = [] <span class=\"comment\">// 声明一个task数组，模拟事件循环队列；</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn);</span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next();</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EatMan.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">str</span>) </span>&#123; <span class=\"comment\">// 为了task任务队列一致性，将eat也转换为setTimeout异步</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(str)</span><br><span class=\"line\">      _this.next()</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum.push(str)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> <span class=\"comment\">// 返回this使得可以链式操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EatMan.prototype.sleep = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123; <span class=\"comment\">// setTimeout的任务，需要在完成时再调用next继续执行</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is normal sleep.'</span>)</span><br><span class=\"line\">      _this.next()</span><br><span class=\"line\">    &#125;, ms * <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.push(fn)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum.push(<span class=\"string\">'sleep'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EatMan.prototype.firstSleep = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ms</span>) </span>&#123; <span class=\"comment\">// 与sleep类似，注意需要在队首加入</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'this is first sleep.'</span>)</span><br><span class=\"line\">      _this.next()</span><br><span class=\"line\">    &#125;, ms * <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.task.unshift(fn)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.taskNum.unshift(<span class=\"string\">'firstSleep'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EatMan.prototype.next = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 通过next指针完成出队列操作，使之拥有顺序</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> fn = <span class=\"keyword\">this</span>.task.shift()</span><br><span class=\"line\">  fn &amp;&amp; fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> eatMan = <span class=\"keyword\">new</span> EatMan()</span><br><span class=\"line\">eatMan.eat(<span class=\"string\">'apple'</span>).eat(<span class=\"string\">'orange'</span>).sleep(<span class=\"number\">3</span>).eat(<span class=\"string\">'banana'</span>).firstSleep(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(eatMan.taskNum)</span><br></pre></td></tr></table></figure>"},{"title":"Async/await和Promise的一些区别","date":"2019-08-19T08:00:00.000Z","excerpt":"Promise相对更为常用，async是generate/co带来的语法糖，在Node.js环境里应用场景更加广泛，书写也更为顺手。","thumbnail":"","_content":"#### 先说说Promise\n\nPromise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。\n\n一个 Promise有以下几种状态:\n* pending: 初始状态，既不是成功，也不是失败状态。\n* fulfilled: 意味着操作成功完成。（与rejected统称为settled状态）\n* rejected: 意味着操作失败。\n\n>  Javascript中的promise代表一种 __已经发生__ 的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的\"箭头方法\":  `f = () =>表达式` 创建惰性求值的表达式，使用 `f()` 求值。\n\nPromise常用的方法有：\n- __all__: 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。\n- __race__: 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\n- __reject__: 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法.\n- __resolve__: 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。\n\n__注意：Promise直接执行的是宏任务，只有.then和.catch是微任务!__\n\n#### 再说Async/await\n`async function` 用来定义一个 __返回 AsyncFunction 对象__ 的异步函数。异步函数是指通过事件循环异步执行的函数，它会 __通过一个隐式的 Promise 返回其结果__ (如果不是通过await返回，那么返回的是一个Promise，返回值为resolve的值）。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。\n\n异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。\n\n记住，await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。\n\n注意，当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式Promise)\n\nasync/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await更像结合了generators和 promises。\n\n使用async时要注意，如果同时操作多个异步方法，要注意调用的写法：\n```javascript\nvar sequentialStart = async function() {\n  console.log('==SEQUENTIAL START==');\n\n  // 1. Execution gets here almost instantly\n  const slow = await resolveAfter2Seconds();\n  console.log(slow); // 2. this runs 2 seconds after 1.\n\n  const fast = await resolveAfter1Second();\n  console.log(fast); // 3. this runs 3 seconds after 1.\n}\n\nvar concurrentStart = async function() {\n  console.log('==CONCURRENT START with await==');\n  const slow = resolveAfter2Seconds(); // starts timer immediately\n  const fast = resolveAfter1Second(); // starts timer immediately\n\n  // 1. Execution gets here almost instantly\n  console.log(await slow); // 2. this runs 2 seconds after 1.\n  console.log(await fast); // 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved\n}\n\nvar parallel = async function() {\n  console.log('==PARALLEL with await Promise.all==');\n  \n  // Start 2 \"jobs\" in parallel and wait for both of them to complete\n  await Promise.all([\n      (async()=>console.log(await resolveAfter2Seconds()))(),\n      (async()=>console.log(await resolveAfter1Second()))()\n  ]);\n}\n```\n#### 那么async/await相比于Promise的区别（优势）？\n- 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担\n- Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅\n- 错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余\n- 调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。","source":"_posts/fe/async-await和promise的一些区别.md","raw":"---\ntags:\n- JavaScript\ncategories: Frontend\ntitle: Async/await和Promise的一些区别\ndate: 2019-08-20T00:00:00.000+08:00\nexcerpt: Promise相对更为常用，async是generate/co带来的语法糖，在Node.js环境里应用场景更加广泛，书写也更为顺手。\nthumbnail: ''\n\n---\n#### 先说说Promise\n\nPromise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。\n\n一个 Promise有以下几种状态:\n* pending: 初始状态，既不是成功，也不是失败状态。\n* fulfilled: 意味着操作成功完成。（与rejected统称为settled状态）\n* rejected: 意味着操作失败。\n\n>  Javascript中的promise代表一种 __已经发生__ 的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的\"箭头方法\":  `f = () =>表达式` 创建惰性求值的表达式，使用 `f()` 求值。\n\nPromise常用的方法有：\n- __all__: 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。\n- __race__: 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\n- __reject__: 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法.\n- __resolve__: 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。\n\n__注意：Promise直接执行的是宏任务，只有.then和.catch是微任务!__\n\n#### 再说Async/await\n`async function` 用来定义一个 __返回 AsyncFunction 对象__ 的异步函数。异步函数是指通过事件循环异步执行的函数，它会 __通过一个隐式的 Promise 返回其结果__ (如果不是通过await返回，那么返回的是一个Promise，返回值为resolve的值）。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。\n\n异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。\n\n记住，await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。\n\n注意，当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式Promise)\n\nasync/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await更像结合了generators和 promises。\n\n使用async时要注意，如果同时操作多个异步方法，要注意调用的写法：\n```javascript\nvar sequentialStart = async function() {\n  console.log('==SEQUENTIAL START==');\n\n  // 1. Execution gets here almost instantly\n  const slow = await resolveAfter2Seconds();\n  console.log(slow); // 2. this runs 2 seconds after 1.\n\n  const fast = await resolveAfter1Second();\n  console.log(fast); // 3. this runs 3 seconds after 1.\n}\n\nvar concurrentStart = async function() {\n  console.log('==CONCURRENT START with await==');\n  const slow = resolveAfter2Seconds(); // starts timer immediately\n  const fast = resolveAfter1Second(); // starts timer immediately\n\n  // 1. Execution gets here almost instantly\n  console.log(await slow); // 2. this runs 2 seconds after 1.\n  console.log(await fast); // 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved\n}\n\nvar parallel = async function() {\n  console.log('==PARALLEL with await Promise.all==');\n  \n  // Start 2 \"jobs\" in parallel and wait for both of them to complete\n  await Promise.all([\n      (async()=>console.log(await resolveAfter2Seconds()))(),\n      (async()=>console.log(await resolveAfter1Second()))()\n  ]);\n}\n```\n#### 那么async/await相比于Promise的区别（优势）？\n- 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担\n- Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅\n- 错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余\n- 调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。","slug":"fe/async-await和promise的一些区别","published":1,"updated":"2020-08-01T18:21:52.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iae000fj1wtdgwb019b","content":"<h4 id=\"先说说Promise\"><a href=\"#先说说Promise\" class=\"headerlink\" title=\"先说说Promise\"></a>先说说Promise</h4><p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>\n<p>一个 Promise有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。（与rejected统称为settled状态）</li>\n<li>rejected: 意味着操作失败。</li>\n</ul>\n<blockquote>\n<p> Javascript中的promise代表一种 <strong>已经发生</strong> 的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”箭头方法”:  <code>f = () =&gt;表达式</code> 创建惰性求值的表达式，使用 <code>f()</code> 求值。</p>\n</blockquote>\n<p>Promise常用的方法有：</p>\n<ul>\n<li><strong>all</strong>: 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。</li>\n<li><strong>race</strong>: 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</li>\n<li><strong>reject</strong>: 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法.</li>\n<li><strong>resolve</strong>: 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。</li>\n</ul>\n<p><strong>注意：Promise直接执行的是宏任务，只有.then和.catch是微任务!</strong></p>\n<h4 id=\"再说Async-await\"><a href=\"#再说Async-await\" class=\"headerlink\" title=\"再说Async/await\"></a>再说Async/await</h4><p><code>async function</code> 用来定义一个 <strong>返回 AsyncFunction 对象</strong> 的异步函数。异步函数是指通过事件循环异步执行的函数，它会 <strong>通过一个隐式的 Promise 返回其结果</strong> (如果不是通过await返回，那么返回的是一个Promise，返回值为resolve的值）。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。</p>\n<p>异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。</p>\n<p>记住，await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。</p>\n<p>注意，当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式Promise)</p>\n<p>async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await更像结合了generators和 promises。</p>\n<p>使用async时要注意，如果同时操作多个异步方法，要注意调用的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sequentialStart = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'==SEQUENTIAL START=='</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. Execution gets here almost instantly</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> slow = <span class=\"keyword\">await</span> resolveAfter2Seconds();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(slow); <span class=\"comment\">// 2. this runs 2 seconds after 1.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fast = <span class=\"keyword\">await</span> resolveAfter1Second();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(fast); <span class=\"comment\">// 3. this runs 3 seconds after 1.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> concurrentStart = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'==CONCURRENT START with await=='</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> slow = resolveAfter2Seconds(); <span class=\"comment\">// starts timer immediately</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fast = resolveAfter1Second(); <span class=\"comment\">// starts timer immediately</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. Execution gets here almost instantly</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> slow); <span class=\"comment\">// 2. this runs 2 seconds after 1.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> fast); <span class=\"comment\">// 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parallel = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'==PARALLEL with await Promise.all=='</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Start 2 \"jobs\" in parallel and wait for both of them to complete</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">      (<span class=\"keyword\">async</span>()=&gt;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> resolveAfter2Seconds()))(),</span><br><span class=\"line\">      (<span class=\"keyword\">async</span>()=&gt;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> resolveAfter1Second()))()</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"那么async-await相比于Promise的区别（优势）？\"><a href=\"#那么async-await相比于Promise的区别（优势）？\" class=\"headerlink\" title=\"那么async/await相比于Promise的区别（优势）？\"></a>那么async/await相比于Promise的区别（优势）？</h4><ul>\n<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担</li>\n<li>Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅</li>\n<li>错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余</li>\n<li>调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。</li>\n</ul>\n","site":{"data":{}},"more":"<h4 id=\"先说说Promise\"><a href=\"#先说说Promise\" class=\"headerlink\" title=\"先说说Promise\"></a>先说说Promise</h4><p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>\n<p>一个 Promise有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。（与rejected统称为settled状态）</li>\n<li>rejected: 意味着操作失败。</li>\n</ul>\n<blockquote>\n<p> Javascript中的promise代表一种 <strong>已经发生</strong> 的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”箭头方法”:  <code>f = () =&gt;表达式</code> 创建惰性求值的表达式，使用 <code>f()</code> 求值。</p>\n</blockquote>\n<p>Promise常用的方法有：</p>\n<ul>\n<li><strong>all</strong>: 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。</li>\n<li><strong>race</strong>: 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</li>\n<li><strong>reject</strong>: 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法.</li>\n<li><strong>resolve</strong>: 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。</li>\n</ul>\n<p><strong>注意：Promise直接执行的是宏任务，只有.then和.catch是微任务!</strong></p>\n<h4 id=\"再说Async-await\"><a href=\"#再说Async-await\" class=\"headerlink\" title=\"再说Async/await\"></a>再说Async/await</h4><p><code>async function</code> 用来定义一个 <strong>返回 AsyncFunction 对象</strong> 的异步函数。异步函数是指通过事件循环异步执行的函数，它会 <strong>通过一个隐式的 Promise 返回其结果</strong> (如果不是通过await返回，那么返回的是一个Promise，返回值为resolve的值）。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。</p>\n<p>异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。</p>\n<p>记住，await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。</p>\n<p>注意，当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式Promise)</p>\n<p>async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await更像结合了generators和 promises。</p>\n<p>使用async时要注意，如果同时操作多个异步方法，要注意调用的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sequentialStart = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'==SEQUENTIAL START=='</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. Execution gets here almost instantly</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> slow = <span class=\"keyword\">await</span> resolveAfter2Seconds();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(slow); <span class=\"comment\">// 2. this runs 2 seconds after 1.</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fast = <span class=\"keyword\">await</span> resolveAfter1Second();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(fast); <span class=\"comment\">// 3. this runs 3 seconds after 1.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> concurrentStart = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'==CONCURRENT START with await=='</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> slow = resolveAfter2Seconds(); <span class=\"comment\">// starts timer immediately</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fast = resolveAfter1Second(); <span class=\"comment\">// starts timer immediately</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. Execution gets here almost instantly</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> slow); <span class=\"comment\">// 2. this runs 2 seconds after 1.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> fast); <span class=\"comment\">// 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parallel = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'==PARALLEL with await Promise.all=='</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Start 2 \"jobs\" in parallel and wait for both of them to complete</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">      (<span class=\"keyword\">async</span>()=&gt;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> resolveAfter2Seconds()))(),</span><br><span class=\"line\">      (<span class=\"keyword\">async</span>()=&gt;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> resolveAfter1Second()))()</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"那么async-await相比于Promise的区别（优势）？\"><a href=\"#那么async-await相比于Promise的区别（优势）？\" class=\"headerlink\" title=\"那么async/await相比于Promise的区别（优势）？\"></a>那么async/await相比于Promise的区别（优势）？</h4><ul>\n<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担</li>\n<li>Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅</li>\n<li>错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余</li>\n<li>调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。</li>\n</ul>\n"},{"date":"2020-03-15T09:46:02.000Z","title":"JavaScript面向对象编程(ES6版本)","excerpt":"虽然目前忙的任务，对JS的OOP一点好感也没有，但还是得对OOP加深印象，毕竟也是一种经典的范式（所以说，用的好是经典，用的不好是神经，当年C++写OOP就满糟糕的……）","thumbnail":"","_content":"> 写在最前面，为什么已经入行一年半才写这样一篇文章呢？其实并不是自己平时开发没有使用，但是很多时候自己的代码会有些“四不像”，各种风格糅杂在一起，因此写这么一篇文章，从编程范式的角度规范自己的代码。\n\n### 面向对象的特性\n\n面向对象就要提到以下的“名词”，那么JavaScript应该如何实现这些呢？\n\n- 类与对象\n- 封装性\n- 继承\n- 多态\n- 抽象性\n\n### 类与对象\n\n> 基于原型的编程不是面向对象编程中体现的风格，且行为重用（在基于类的语言中也称为继承）是通过装饰它作为原型的现有对象的过程实现的。这种模式也被称为弱类化，原型化，或基于实例的编程。\n\n而在JavaScript中，实现的方式就是通过函数内置的Prototype属性完成这种 __原型继承__ 。\n\n#### 对象\n\nJavaScript内的对象，其实就是Object，那么Object有两种方法可以用来创建：\n\n```javascript\nvar Person = {}; // 字面量\nvar Person = new Object(); // 使用new运算符\n```\n\n那么他们有什么区别呢？首先要说的就是new，new做了哪些呢？这里引用MDN的解释：\n\n> 1. 创建一个空的简单JavaScript对象（即{}）；\n> 2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n> 3. 将步骤1新创建的对象作为this的上下文 ；\n> 4. 如果该函数没有返回对象，则返回this。\n\n不难发现，new的第一步其实和字面量方式完全一致，所以，new运算符的链接与设定this其实是最核心的不同点。\n\n我们一般不常用`new Object()`，而直接用字面量方式的原因，其实是因为他们的prototype都指向了null。\n\n正是因为这样，我们在日常的使用中，如果希望通过OOP实现逻辑，应该通过new的方式来进行，因为他可以继承我们期望的对象。\n\n##### 代码风格\n\nJavaScript有很多的引用类型数据，因此在面向对象时，要注意分离自有的部分与暴露的方法。\n\n```javascript\nfunction Person (name){\n\tthis.name = name;\n}\nPerson.prototype.sayIntro = function() {\n\treturn 'Hello, my name is ' + name + '.'\n}\nvar person1 = new Person('peter'); // Person是一个构造器。\nperson1.sayIntro(); // 为什么可以调用prototype上的方法呢？参见“原型链”\n```\n\n##### `Object.create()`\n\n> Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\nObject.create()是ES2015规范内的新方法，同时在ES5.1进行了加强，它可以polyfill使得我们可以在生产中尽可能使用来让我们的代码更为清晰。\n\n其内部核心的实现其实在JS高程有对应的代码：\n\n```javascript\n// 在自己的实现里要注意当前环境是否支持create，以及目标是否可以作为create的对象。\nObject.create = function (proto, propertiesObject) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n};\n```\n\n那么如果使用`Object.create`应该如何实现继承呢？下面是MDN的一个例子：\n\n```javascript\n// Shape - 父类(superclass)\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\n// 父类的方法\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n\n// Rectangle - 子类(subclass)\nfunction Rectangle() {\n  Shape.call(this); // call super constructor.\n}\n\n// 子类续承父类\nRectangle.prototype = Object.create(Shape.prototype); // create的目标是父类的prototype，注意，JS的继承是原型继承。\nRectangle.prototype.constructor = Rectangle; // 修复constructor指向\n```\n\n上面是一个单继承的例子，如果我们希望做多继承，其实只需要修改Rectangle.prototype，让其的赋值为其多继承的对象的prototype的合并(Object.assign)。需要注意需要在子类内部显式绑定this。\n\n#### 类\n\nES6最大的变化就是对Class的支持，虽然JS只能通过原型继承，但是Class的出现使得JS的OOP“看起来更像那么回事了”。\n\n为什么说看起来呢？目前还没有实现私有与公有特性，它只是原来构造模式的一个语法糖，但是，它也有它的不同之处。\n\n- Class内部只是原型的实现，在实际使用时还是需要通过new运算符执行构造函数；\n- 类声明不能被提升；\n- 类声明中的代码自动运行在严格模式下；\n- __类中的所有方法都是不可枚举的__ ；\n- 每个类都有一个`[[construct]]`的方法，constructor方法默认返回实例对象（即this）；\n\n##### 派生类\n\n```javascript\nclass HelloWorld extends React.Component {}\n```\n\n上面这种写法在React的开发中非常常见，extends是一个派生类， __在派生类中，如果使用了构造方法，就必须使用super()__ ，在构造函数中访问this之前要调用super()， __负责初始化this__ 。\n\n```javascript\nclass Shape {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor() {\n    super();  // 这里的super可以作为函数，也可以作为特殊的对象（无法直接输出，但是可以设置属性）。\n  }\n}\n```\n\n### 继承\n\n见上面对“类与对象”内继承的实现，核心在于prototype __原型继承模式__ 。\n\n### 抽象\n\n> 抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。\n> JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。\n\n> JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。\n\n### 多态\n\n其实多态并没有太多好说的，核心在于“原型链”：如果你在子类声明了同名的属性和方法，那么就不会在原型链上向上查找。","source":"_posts/fe/javascript面向对象编程-es6版本.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-03-16T01:46:02.000+08:00\ntitle: JavaScript面向对象编程(ES6版本)\nexcerpt: 虽然目前忙的任务，对JS的OOP一点好感也没有，但还是得对OOP加深印象，毕竟也是一种经典的范式（所以说，用的好是经典，用的不好是神经，当年C++写OOP就满糟糕的……）\nthumbnail: ''\n\n---\n> 写在最前面，为什么已经入行一年半才写这样一篇文章呢？其实并不是自己平时开发没有使用，但是很多时候自己的代码会有些“四不像”，各种风格糅杂在一起，因此写这么一篇文章，从编程范式的角度规范自己的代码。\n\n### 面向对象的特性\n\n面向对象就要提到以下的“名词”，那么JavaScript应该如何实现这些呢？\n\n- 类与对象\n- 封装性\n- 继承\n- 多态\n- 抽象性\n\n### 类与对象\n\n> 基于原型的编程不是面向对象编程中体现的风格，且行为重用（在基于类的语言中也称为继承）是通过装饰它作为原型的现有对象的过程实现的。这种模式也被称为弱类化，原型化，或基于实例的编程。\n\n而在JavaScript中，实现的方式就是通过函数内置的Prototype属性完成这种 __原型继承__ 。\n\n#### 对象\n\nJavaScript内的对象，其实就是Object，那么Object有两种方法可以用来创建：\n\n```javascript\nvar Person = {}; // 字面量\nvar Person = new Object(); // 使用new运算符\n```\n\n那么他们有什么区别呢？首先要说的就是new，new做了哪些呢？这里引用MDN的解释：\n\n> 1. 创建一个空的简单JavaScript对象（即{}）；\n> 2. 链接该对象（即设置该对象的构造函数）到另一个对象 ；\n> 3. 将步骤1新创建的对象作为this的上下文 ；\n> 4. 如果该函数没有返回对象，则返回this。\n\n不难发现，new的第一步其实和字面量方式完全一致，所以，new运算符的链接与设定this其实是最核心的不同点。\n\n我们一般不常用`new Object()`，而直接用字面量方式的原因，其实是因为他们的prototype都指向了null。\n\n正是因为这样，我们在日常的使用中，如果希望通过OOP实现逻辑，应该通过new的方式来进行，因为他可以继承我们期望的对象。\n\n##### 代码风格\n\nJavaScript有很多的引用类型数据，因此在面向对象时，要注意分离自有的部分与暴露的方法。\n\n```javascript\nfunction Person (name){\n\tthis.name = name;\n}\nPerson.prototype.sayIntro = function() {\n\treturn 'Hello, my name is ' + name + '.'\n}\nvar person1 = new Person('peter'); // Person是一个构造器。\nperson1.sayIntro(); // 为什么可以调用prototype上的方法呢？参见“原型链”\n```\n\n##### `Object.create()`\n\n> Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n\nObject.create()是ES2015规范内的新方法，同时在ES5.1进行了加强，它可以polyfill使得我们可以在生产中尽可能使用来让我们的代码更为清晰。\n\n其内部核心的实现其实在JS高程有对应的代码：\n\n```javascript\n// 在自己的实现里要注意当前环境是否支持create，以及目标是否可以作为create的对象。\nObject.create = function (proto, propertiesObject) {\n  function F() {}\n  F.prototype = proto;\n  return new F();\n};\n```\n\n那么如果使用`Object.create`应该如何实现继承呢？下面是MDN的一个例子：\n\n```javascript\n// Shape - 父类(superclass)\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\n// 父类的方法\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n\n// Rectangle - 子类(subclass)\nfunction Rectangle() {\n  Shape.call(this); // call super constructor.\n}\n\n// 子类续承父类\nRectangle.prototype = Object.create(Shape.prototype); // create的目标是父类的prototype，注意，JS的继承是原型继承。\nRectangle.prototype.constructor = Rectangle; // 修复constructor指向\n```\n\n上面是一个单继承的例子，如果我们希望做多继承，其实只需要修改Rectangle.prototype，让其的赋值为其多继承的对象的prototype的合并(Object.assign)。需要注意需要在子类内部显式绑定this。\n\n#### 类\n\nES6最大的变化就是对Class的支持，虽然JS只能通过原型继承，但是Class的出现使得JS的OOP“看起来更像那么回事了”。\n\n为什么说看起来呢？目前还没有实现私有与公有特性，它只是原来构造模式的一个语法糖，但是，它也有它的不同之处。\n\n- Class内部只是原型的实现，在实际使用时还是需要通过new运算符执行构造函数；\n- 类声明不能被提升；\n- 类声明中的代码自动运行在严格模式下；\n- __类中的所有方法都是不可枚举的__ ；\n- 每个类都有一个`[[construct]]`的方法，constructor方法默认返回实例对象（即this）；\n\n##### 派生类\n\n```javascript\nclass HelloWorld extends React.Component {}\n```\n\n上面这种写法在React的开发中非常常见，extends是一个派生类， __在派生类中，如果使用了构造方法，就必须使用super()__ ，在构造函数中访问this之前要调用super()， __负责初始化this__ 。\n\n```javascript\nclass Shape {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor() {\n    super();  // 这里的super可以作为函数，也可以作为特殊的对象（无法直接输出，但是可以设置属性）。\n  }\n}\n```\n\n### 继承\n\n见上面对“类与对象”内继承的实现，核心在于prototype __原型继承模式__ 。\n\n### 抽象\n\n> 抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。\n> JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。\n\n> JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。\n\n### 多态\n\n其实多态并没有太多好说的，核心在于“原型链”：如果你在子类声明了同名的属性和方法，那么就不会在原型链上向上查找。","slug":"fe/javascript面向对象编程-es6版本","published":1,"updated":"2020-08-01T18:21:52.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iaf000ij1wt5n1wh1hr","content":"<blockquote>\n<p>写在最前面，为什么已经入行一年半才写这样一篇文章呢？其实并不是自己平时开发没有使用，但是很多时候自己的代码会有些“四不像”，各种风格糅杂在一起，因此写这么一篇文章，从编程范式的角度规范自己的代码。</p>\n</blockquote>\n<h3 id=\"面向对象的特性\"><a href=\"#面向对象的特性\" class=\"headerlink\" title=\"面向对象的特性\"></a>面向对象的特性</h3><p>面向对象就要提到以下的“名词”，那么JavaScript应该如何实现这些呢？</p>\n<ul>\n<li>类与对象</li>\n<li>封装性</li>\n<li>继承</li>\n<li>多态</li>\n<li>抽象性</li>\n</ul>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><blockquote>\n<p>基于原型的编程不是面向对象编程中体现的风格，且行为重用（在基于类的语言中也称为继承）是通过装饰它作为原型的现有对象的过程实现的。这种模式也被称为弱类化，原型化，或基于实例的编程。</p>\n</blockquote>\n<p>而在JavaScript中，实现的方式就是通过函数内置的Prototype属性完成这种 <strong>原型继承</strong> 。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>JavaScript内的对象，其实就是Object，那么Object有两种方法可以用来创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = &#123;&#125;; <span class=\"comment\">// 字面量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(); <span class=\"comment\">// 使用new运算符</span></span><br></pre></td></tr></table></figure>\n\n<p>那么他们有什么区别呢？首先要说的就是new，new做了哪些呢？这里引用MDN的解释：</p>\n<blockquote>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为this的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回this。</li>\n</ol>\n</blockquote>\n<p>不难发现，new的第一步其实和字面量方式完全一致，所以，new运算符的链接与设定this其实是最核心的不同点。</p>\n<p>我们一般不常用<code>new Object()</code>，而直接用字面量方式的原因，其实是因为他们的prototype都指向了null。</p>\n<p>正是因为这样，我们在日常的使用中，如果希望通过OOP实现逻辑，应该通过new的方式来进行，因为他可以继承我们期望的对象。</p>\n<h5 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h5><p>JavaScript有很多的引用类型数据，因此在面向对象时，要注意分离自有的部分与暴露的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sayIntro = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'peter'</span>); <span class=\"comment\">// Person是一个构造器。</span></span><br><span class=\"line\">person1.sayIntro(); <span class=\"comment\">// 为什么可以调用prototype上的方法呢？参见“原型链”</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a><code>Object.create()</code></h5><blockquote>\n<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p>\n</blockquote>\n<p>Object.create()是ES2015规范内的新方法，同时在ES5.1进行了加强，它可以polyfill使得我们可以在生产中尽可能使用来让我们的代码更为清晰。</p>\n<p>其内部核心的实现其实在JS高程有对应的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在自己的实现里要注意当前环境是否支持create，以及目标是否可以作为create的对象。</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">proto, propertiesObject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>那么如果使用<code>Object.create</code>应该如何实现继承呢？下面是MDN的一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Shape - 父类(superclass)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Shape</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类的方法</span></span><br><span class=\"line\">Shape.prototype.move = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x += x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y += y;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'Shape moved.'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Rectangle - 子类(subclass)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Rectangle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Shape.call(<span class=\"keyword\">this</span>); <span class=\"comment\">// call super constructor.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类续承父类</span></span><br><span class=\"line\">Rectangle.prototype = <span class=\"built_in\">Object</span>.create(Shape.prototype); <span class=\"comment\">// create的目标是父类的prototype，注意，JS的继承是原型继承。</span></span><br><span class=\"line\">Rectangle.prototype.constructor = Rectangle; <span class=\"comment\">// 修复constructor指向</span></span><br></pre></td></tr></table></figure>\n\n<p>上面是一个单继承的例子，如果我们希望做多继承，其实只需要修改Rectangle.prototype，让其的赋值为其多继承的对象的prototype的合并(Object.assign)。需要注意需要在子类内部显式绑定this。</p>\n<h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><p>ES6最大的变化就是对Class的支持，虽然JS只能通过原型继承，但是Class的出现使得JS的OOP“看起来更像那么回事了”。</p>\n<p>为什么说看起来呢？目前还没有实现私有与公有特性，它只是原来构造模式的一个语法糖，但是，它也有它的不同之处。</p>\n<ul>\n<li>Class内部只是原型的实现，在实际使用时还是需要通过new运算符执行构造函数；</li>\n<li>类声明不能被提升；</li>\n<li>类声明中的代码自动运行在严格模式下；</li>\n<li><strong>类中的所有方法都是不可枚举的</strong> ；</li>\n<li>每个类都有一个<code>[[construct]]</code>的方法，constructor方法默认返回实例对象（即this）；</li>\n</ul>\n<h5 id=\"派生类\"><a href=\"#派生类\" class=\"headerlink\" title=\"派生类\"></a>派生类</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法在React的开发中非常常见，extends是一个派生类， <strong>在派生类中，如果使用了构造方法，就必须使用super()</strong> ，在构造函数中访问this之前要调用super()， <strong>负责初始化this</strong> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();  <span class=\"comment\">// 这里的super可以作为函数，也可以作为特殊的对象（无法直接输出，但是可以设置属性）。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>见上面对“类与对象”内继承的实现，核心在于prototype <strong>原型继承模式</strong> 。</p>\n<h3 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h3><blockquote>\n<p>抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。<br>JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。</p>\n</blockquote>\n<blockquote>\n<p>JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。</p>\n</blockquote>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>其实多态并没有太多好说的，核心在于“原型链”：如果你在子类声明了同名的属性和方法，那么就不会在原型链上向上查找。</p>\n","site":{"data":{}},"more":"<blockquote>\n<p>写在最前面，为什么已经入行一年半才写这样一篇文章呢？其实并不是自己平时开发没有使用，但是很多时候自己的代码会有些“四不像”，各种风格糅杂在一起，因此写这么一篇文章，从编程范式的角度规范自己的代码。</p>\n</blockquote>\n<h3 id=\"面向对象的特性\"><a href=\"#面向对象的特性\" class=\"headerlink\" title=\"面向对象的特性\"></a>面向对象的特性</h3><p>面向对象就要提到以下的“名词”，那么JavaScript应该如何实现这些呢？</p>\n<ul>\n<li>类与对象</li>\n<li>封装性</li>\n<li>继承</li>\n<li>多态</li>\n<li>抽象性</li>\n</ul>\n<h3 id=\"类与对象\"><a href=\"#类与对象\" class=\"headerlink\" title=\"类与对象\"></a>类与对象</h3><blockquote>\n<p>基于原型的编程不是面向对象编程中体现的风格，且行为重用（在基于类的语言中也称为继承）是通过装饰它作为原型的现有对象的过程实现的。这种模式也被称为弱类化，原型化，或基于实例的编程。</p>\n</blockquote>\n<p>而在JavaScript中，实现的方式就是通过函数内置的Prototype属性完成这种 <strong>原型继承</strong> 。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>JavaScript内的对象，其实就是Object，那么Object有两种方法可以用来创建：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = &#123;&#125;; <span class=\"comment\">// 字面量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(); <span class=\"comment\">// 使用new运算符</span></span><br></pre></td></tr></table></figure>\n\n<p>那么他们有什么区别呢？首先要说的就是new，new做了哪些呢？这里引用MDN的解释：</p>\n<blockquote>\n<ol>\n<li>创建一个空的简单JavaScript对象（即{}）；</li>\n<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li>\n<li>将步骤1新创建的对象作为this的上下文 ；</li>\n<li>如果该函数没有返回对象，则返回this。</li>\n</ol>\n</blockquote>\n<p>不难发现，new的第一步其实和字面量方式完全一致，所以，new运算符的链接与设定this其实是最核心的不同点。</p>\n<p>我们一般不常用<code>new Object()</code>，而直接用字面量方式的原因，其实是因为他们的prototype都指向了null。</p>\n<p>正是因为这样，我们在日常的使用中，如果希望通过OOP实现逻辑，应该通过new的方式来进行，因为他可以继承我们期望的对象。</p>\n<h5 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h5><p>JavaScript有很多的引用类型数据，因此在面向对象时，要注意分离自有的部分与暴露的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span> (<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sayIntro = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">'Hello, my name is '</span> + name + <span class=\"string\">'.'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'peter'</span>); <span class=\"comment\">// Person是一个构造器。</span></span><br><span class=\"line\">person1.sayIntro(); <span class=\"comment\">// 为什么可以调用prototype上的方法呢？参见“原型链”</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a><code>Object.create()</code></h5><blockquote>\n<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p>\n</blockquote>\n<p>Object.create()是ES2015规范内的新方法，同时在ES5.1进行了加强，它可以polyfill使得我们可以在生产中尽可能使用来让我们的代码更为清晰。</p>\n<p>其内部核心的实现其实在JS高程有对应的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在自己的实现里要注意当前环境是否支持create，以及目标是否可以作为create的对象。</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.create = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">proto, propertiesObject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">  F.prototype = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>那么如果使用<code>Object.create</code>应该如何实现继承呢？下面是MDN的一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Shape - 父类(superclass)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Shape</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父类的方法</span></span><br><span class=\"line\">Shape.prototype.move = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.x += x;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.y += y;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.info(<span class=\"string\">'Shape moved.'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Rectangle - 子类(subclass)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Rectangle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  Shape.call(<span class=\"keyword\">this</span>); <span class=\"comment\">// call super constructor.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类续承父类</span></span><br><span class=\"line\">Rectangle.prototype = <span class=\"built_in\">Object</span>.create(Shape.prototype); <span class=\"comment\">// create的目标是父类的prototype，注意，JS的继承是原型继承。</span></span><br><span class=\"line\">Rectangle.prototype.constructor = Rectangle; <span class=\"comment\">// 修复constructor指向</span></span><br></pre></td></tr></table></figure>\n\n<p>上面是一个单继承的例子，如果我们希望做多继承，其实只需要修改Rectangle.prototype，让其的赋值为其多继承的对象的prototype的合并(Object.assign)。需要注意需要在子类内部显式绑定this。</p>\n<h4 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h4><p>ES6最大的变化就是对Class的支持，虽然JS只能通过原型继承，但是Class的出现使得JS的OOP“看起来更像那么回事了”。</p>\n<p>为什么说看起来呢？目前还没有实现私有与公有特性，它只是原来构造模式的一个语法糖，但是，它也有它的不同之处。</p>\n<ul>\n<li>Class内部只是原型的实现，在实际使用时还是需要通过new运算符执行构造函数；</li>\n<li>类声明不能被提升；</li>\n<li>类声明中的代码自动运行在严格模式下；</li>\n<li><strong>类中的所有方法都是不可枚举的</strong> ；</li>\n<li>每个类都有一个<code>[[construct]]</code>的方法，constructor方法默认返回实例对象（即this）；</li>\n</ul>\n<h5 id=\"派生类\"><a href=\"#派生类\" class=\"headerlink\" title=\"派生类\"></a>派生类</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这种写法在React的开发中非常常见，extends是一个派生类， <strong>在派生类中，如果使用了构造方法，就必须使用super()</strong> ，在构造函数中访问this之前要调用super()， <strong>负责初始化this</strong> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();  <span class=\"comment\">// 这里的super可以作为函数，也可以作为特殊的对象（无法直接输出，但是可以设置属性）。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>见上面对“类与对象”内继承的实现，核心在于prototype <strong>原型继承模式</strong> 。</p>\n<h3 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h3><blockquote>\n<p>抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。<br>JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。</p>\n</blockquote>\n<blockquote>\n<p>JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。</p>\n</blockquote>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>其实多态并没有太多好说的，核心在于“原型链”：如果你在子类声明了同名的属性和方法，那么就不会在原型链上向上查找。</p>\n"},{"title":"script标签有几种写法","date":"2019-08-16T08:00:00.000Z","excerpt":"老梗新用，“茴”字有几种写法？其实 `script`标签也有很多写法，用这篇文章再梳理一遍加深印象。","thumbnail":"","_content":"#### script 标签有哪些属性\n\n* async\n* defer\n* integrity\n* src\n* type\n* text\n* crossorigin\n\n区别如下\n\n![script标签属性区别](https://cdn.sparkling.land/public/blog/images/16285181c4ab990d_goqvkh.png)\n\n如图可知，async不影响页面解析过程，但是加载完成执行过程会终止parsing；\n而defer是在过程中加载，等到页面解析完成后才执行。\n\n**要注意，async无法确定顺序，比较适合不依赖dom结构的，而defer则是顺序执行**\n\n#### 其他的方式\n\n1. 动态创建script标签\n\n```javascript\nvar script = document.createElement('script');\nscript.type = \"text/javascript\";\nscript.src = \"file1.js\";\ndocument.getElementByTagName(\"head\")[0].appendChild(script);\n```\n\n动态创建的script无论在何时执行创建，其源js均会在最后执行","source":"_posts/fe/script标签有几种写法.md","raw":"---\ntags:\n- HTML\ncategories: Frontend\ntitle: script标签有几种写法\ndate: 2019-08-16T16:00:00.000+00:00\nexcerpt: 老梗新用，“茴”字有几种写法？其实 `script`标签也有很多写法，用这篇文章再梳理一遍加深印象。\nthumbnail: ''\n\n---\n#### script 标签有哪些属性\n\n* async\n* defer\n* integrity\n* src\n* type\n* text\n* crossorigin\n\n区别如下\n\n![script标签属性区别](https://cdn.sparkling.land/public/blog/images/16285181c4ab990d_goqvkh.png)\n\n如图可知，async不影响页面解析过程，但是加载完成执行过程会终止parsing；\n而defer是在过程中加载，等到页面解析完成后才执行。\n\n**要注意，async无法确定顺序，比较适合不依赖dom结构的，而defer则是顺序执行**\n\n#### 其他的方式\n\n1. 动态创建script标签\n\n```javascript\nvar script = document.createElement('script');\nscript.type = \"text/javascript\";\nscript.src = \"file1.js\";\ndocument.getElementByTagName(\"head\")[0].appendChild(script);\n```\n\n动态创建的script无论在何时执行创建，其源js均会在最后执行","slug":"fe/script标签有几种写法","published":1,"updated":"2020-08-01T18:21:52.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iag000mj1wt5dvzhkd1","content":"<h4 id=\"script-标签有哪些属性\"><a href=\"#script-标签有哪些属性\" class=\"headerlink\" title=\"script 标签有哪些属性\"></a>script 标签有哪些属性</h4><ul>\n<li>async</li>\n<li>defer</li>\n<li>integrity</li>\n<li>src</li>\n<li>type</li>\n<li>text</li>\n<li>crossorigin</li>\n</ul>\n<p>区别如下</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/16285181c4ab990d_goqvkh.png\" alt=\"script标签属性区别\"></p>\n<p>如图可知，async不影响页面解析过程，但是加载完成执行过程会终止parsing；<br>而defer是在过程中加载，等到页面解析完成后才执行。</p>\n<p><strong>要注意，async无法确定顺序，比较适合不依赖dom结构的，而defer则是顺序执行</strong></p>\n<h4 id=\"其他的方式\"><a href=\"#其他的方式\" class=\"headerlink\" title=\"其他的方式\"></a>其他的方式</h4><ol>\n<li>动态创建script标签</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">script.src = <span class=\"string\">\"file1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n\n<p>动态创建的script无论在何时执行创建，其源js均会在最后执行</p>\n","site":{"data":{}},"more":"<h4 id=\"script-标签有哪些属性\"><a href=\"#script-标签有哪些属性\" class=\"headerlink\" title=\"script 标签有哪些属性\"></a>script 标签有哪些属性</h4><ul>\n<li>async</li>\n<li>defer</li>\n<li>integrity</li>\n<li>src</li>\n<li>type</li>\n<li>text</li>\n<li>crossorigin</li>\n</ul>\n<p>区别如下</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/16285181c4ab990d_goqvkh.png\" alt=\"script标签属性区别\"></p>\n<p>如图可知，async不影响页面解析过程，但是加载完成执行过程会终止parsing；<br>而defer是在过程中加载，等到页面解析完成后才执行。</p>\n<p><strong>要注意，async无法确定顺序，比较适合不依赖dom结构的，而defer则是顺序执行</strong></p>\n<h4 id=\"其他的方式\"><a href=\"#其他的方式\" class=\"headerlink\" title=\"其他的方式\"></a>其他的方式</h4><ol>\n<li>动态创建script标签</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);</span><br><span class=\"line\">script.type = <span class=\"string\">\"text/javascript\"</span>;</span><br><span class=\"line\">script.src = <span class=\"string\">\"file1.js\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementByTagName(<span class=\"string\">\"head\"</span>)[<span class=\"number\">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>\n\n<p>动态创建的script无论在何时执行创建，其源js均会在最后执行</p>\n"},{"title":"React 组件中 state 和生命周期","date":"2019-08-18T08:00:00.000Z","excerpt":"React在面试中曾经也有碰到，这里简单记录加深印象。","thumbnail":"","_content":"#### React的生命周期图谱\n\nv16.3和v16.4+版本的生命周期有着比较大的区别，感谢大神制作了一个[React生命周期图谱](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/) 这里截图说明：\n\n![React生命周期](https://cdn.sparkling.land/public/blog/images/React生命周期_jp8yqw.jpg)\n\n* constructor\n  **如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。**\n\n  在 React 组件挂载之前，会调用它的构造函数。在为 `React.Component` 子类实现构造函数时，应在其他语句之前前调用 `super(props)`。否则，`this.props` 在构造函数中可能会出现未定义的 bug。\n\n  通常，在 React 中，构造函数仅用于以下两种情况：\n  \\- 通过给 `this.state` 赋值对象来初始化内部 state。\n  \\- 为事件处理函数绑定实例\n  在 `constructor()` 函数中不要调用 `setState()` 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 `this.state` 赋值初始 state\n* `static getDerivedStateFromProps(props, state)`\n\n`getDerivedStateFromProps` 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。\n\n此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 `<Transition>` 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。\n\n**请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。**\n\n* shouldComponentUpdate\n\n根据 `shouldComponentUpdate()` 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。\n\n当 props 或 state 发生变化时，`shouldComponentUpdate()` 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 `forceUpdate()` 时不会调用该方法。\n\n此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 `PureComponent` 组件，而不是手动编写 `shouldComponentUpdate()`。`PureComponent` 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。\n\n* getSnapshotBeforeUpdate\n\n`getSnapshotBeforeUpdate()` 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 `componentDidUpdate()`。\n\n此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。\n\n应返回 snapshot 的值（或 `null`）。\n\n* componentDidMount\n\n`componentDidMount()` 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。\n\n这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 `componentWillUnmount()` 里取消订阅\n\n你可以在 `componentDidMount()` 里可以直接调用 `setState()`。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 `render()` 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 `constructor()` 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理\n\n* componentDidUpdate\n\n`componentDidUpdate()` 会在更新后会被立即调用。首次渲染不会执行此方法。\n\n当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。\n\n你也可以在 `componentDidUpdate()` 中直接调用 `setState()`，但请注意 **它必须被包裹在一个条件语件里** ，正如上述的例子那样进行处理，**否则会导致死循环**。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。\n\n* componentWillUnmount\n\n`componentWillUnmount()` 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 `componentDidMount()` 中创建的订阅等。\n\n`componentWillUnmount()` 中不应调用 `setState()`，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。","source":"_posts/fe/react-组件中-state-和生命周期.md","raw":"---\ntags:\n- React.js\ncategories: Frontend\ntitle: React 组件中 state 和生命周期\ndate: 2019-08-18T16:00:00.000+00:00\nexcerpt: React在面试中曾经也有碰到，这里简单记录加深印象。\nthumbnail: ''\n\n---\n#### React的生命周期图谱\n\nv16.3和v16.4+版本的生命周期有着比较大的区别，感谢大神制作了一个[React生命周期图谱](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/) 这里截图说明：\n\n![React生命周期](https://cdn.sparkling.land/public/blog/images/React生命周期_jp8yqw.jpg)\n\n* constructor\n  **如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。**\n\n  在 React 组件挂载之前，会调用它的构造函数。在为 `React.Component` 子类实现构造函数时，应在其他语句之前前调用 `super(props)`。否则，`this.props` 在构造函数中可能会出现未定义的 bug。\n\n  通常，在 React 中，构造函数仅用于以下两种情况：\n  \\- 通过给 `this.state` 赋值对象来初始化内部 state。\n  \\- 为事件处理函数绑定实例\n  在 `constructor()` 函数中不要调用 `setState()` 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 `this.state` 赋值初始 state\n* `static getDerivedStateFromProps(props, state)`\n\n`getDerivedStateFromProps` 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。\n\n此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 `<Transition>` 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。\n\n**请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。**\n\n* shouldComponentUpdate\n\n根据 `shouldComponentUpdate()` 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。\n\n当 props 或 state 发生变化时，`shouldComponentUpdate()` 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 `forceUpdate()` 时不会调用该方法。\n\n此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 `PureComponent` 组件，而不是手动编写 `shouldComponentUpdate()`。`PureComponent` 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。\n\n* getSnapshotBeforeUpdate\n\n`getSnapshotBeforeUpdate()` 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 `componentDidUpdate()`。\n\n此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。\n\n应返回 snapshot 的值（或 `null`）。\n\n* componentDidMount\n\n`componentDidMount()` 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。\n\n这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 `componentWillUnmount()` 里取消订阅\n\n你可以在 `componentDidMount()` 里可以直接调用 `setState()`。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 `render()` 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 `constructor()` 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理\n\n* componentDidUpdate\n\n`componentDidUpdate()` 会在更新后会被立即调用。首次渲染不会执行此方法。\n\n当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。\n\n你也可以在 `componentDidUpdate()` 中直接调用 `setState()`，但请注意 **它必须被包裹在一个条件语件里** ，正如上述的例子那样进行处理，**否则会导致死循环**。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。\n\n* componentWillUnmount\n\n`componentWillUnmount()` 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 `componentDidMount()` 中创建的订阅等。\n\n`componentWillUnmount()` 中不应调用 `setState()`，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。","slug":"fe/react-组件中-state-和生命周期","published":1,"updated":"2020-08-01T18:21:52.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iah000pj1wt3k2n04j0","content":"<h4 id=\"React的生命周期图谱\"><a href=\"#React的生命周期图谱\" class=\"headerlink\" title=\"React的生命周期图谱\"></a>React的生命周期图谱</h4><p>v16.3和v16.4+版本的生命周期有着比较大的区别，感谢大神制作了一个<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React生命周期图谱</a> 这里截图说明：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_jp8yqw.jpg\" alt=\"React生命周期\"></p>\n<ul>\n<li><p>constructor<br><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p>\n<p>在 React 组件挂载之前，会调用它的构造函数。在为 <code>React.Component</code> 子类实现构造函数时，应在其他语句之前前调用 <code>super(props)</code>。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p>\n<p>通常，在 React 中，构造函数仅用于以下两种情况：<br>- 通过给 <code>this.state</code> 赋值对象来初始化内部 state。<br>- 为事件处理函数绑定实例<br>在 <code>constructor()</code> 函数中不要调用 <code>setState()</code> 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 <code>this.state</code> 赋值初始 state</p>\n</li>\n<li><p><code>static getDerivedStateFromProps(props, state)</code></p>\n</li>\n</ul>\n<p><code>getDerivedStateFromProps</code> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p>\n<p>此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 <code>&lt;Transition&gt;</code> 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。</p>\n<p><strong>请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。</strong></p>\n<ul>\n<li>shouldComponentUpdate</li>\n</ul>\n<p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p>\n<p>当 props 或 state 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p>\n<p>此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 <code>PureComponent</code> 组件，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p>\n<ul>\n<li>getSnapshotBeforeUpdate</li>\n</ul>\n<p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p>\n<p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>\n<p>应返回 snapshot 的值（或 <code>null</code>）。</p>\n<ul>\n<li>componentDidMount</li>\n</ul>\n<p><code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>\n<p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅</p>\n<p>你可以在 <code>componentDidMount()</code> 里可以直接调用 <code>setState()</code>。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 <code>constructor()</code> 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理</p>\n<ul>\n<li>componentDidUpdate</li>\n</ul>\n<p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</p>\n<p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p>\n<p>你也可以在 <code>componentDidUpdate()</code> 中直接调用 <code>setState()</code>，但请注意 <strong>它必须被包裹在一个条件语件里</strong> ，正如上述的例子那样进行处理，<strong>否则会导致死循环</strong>。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。</p>\n<ul>\n<li>componentWillUnmount</li>\n</ul>\n<p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p>\n<p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>\n","site":{"data":{}},"more":"<h4 id=\"React的生命周期图谱\"><a href=\"#React的生命周期图谱\" class=\"headerlink\" title=\"React的生命周期图谱\"></a>React的生命周期图谱</h4><p>v16.3和v16.4+版本的生命周期有着比较大的区别，感谢大神制作了一个<a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">React生命周期图谱</a> 这里截图说明：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_jp8yqw.jpg\" alt=\"React生命周期\"></p>\n<ul>\n<li><p>constructor<br><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p>\n<p>在 React 组件挂载之前，会调用它的构造函数。在为 <code>React.Component</code> 子类实现构造函数时，应在其他语句之前前调用 <code>super(props)</code>。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p>\n<p>通常，在 React 中，构造函数仅用于以下两种情况：<br>- 通过给 <code>this.state</code> 赋值对象来初始化内部 state。<br>- 为事件处理函数绑定实例<br>在 <code>constructor()</code> 函数中不要调用 <code>setState()</code> 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 <code>this.state</code> 赋值初始 state</p>\n</li>\n<li><p><code>static getDerivedStateFromProps(props, state)</code></p>\n</li>\n</ul>\n<p><code>getDerivedStateFromProps</code> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p>\n<p>此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 <code>&lt;Transition&gt;</code> 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。</p>\n<p><strong>请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。</strong></p>\n<ul>\n<li>shouldComponentUpdate</li>\n</ul>\n<p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p>\n<p>当 props 或 state 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p>\n<p>此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 <code>PureComponent</code> 组件，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p>\n<ul>\n<li>getSnapshotBeforeUpdate</li>\n</ul>\n<p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p>\n<p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>\n<p>应返回 snapshot 的值（或 <code>null</code>）。</p>\n<ul>\n<li>componentDidMount</li>\n</ul>\n<p><code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>\n<p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅</p>\n<p>你可以在 <code>componentDidMount()</code> 里可以直接调用 <code>setState()</code>。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 <code>constructor()</code> 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理</p>\n<ul>\n<li>componentDidUpdate</li>\n</ul>\n<p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</p>\n<p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p>\n<p>你也可以在 <code>componentDidUpdate()</code> 中直接调用 <code>setState()</code>，但请注意 <strong>它必须被包裹在一个条件语件里</strong> ，正如上述的例子那样进行处理，<strong>否则会导致死循环</strong>。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。</p>\n<ul>\n<li>componentWillUnmount</li>\n</ul>\n<p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p>\n<p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>\n"},{"title":"meta标签的使用","date":"2019-08-16T08:00:00.000Z","excerpt":"meta标签我们总是一键生成，但是忽略了里面一些特殊属性值所能带来方便，这篇文章简单列出一些常用但缺少注意的标签值。","thumbnail":"","_content":"平时使用时最常见的用法：\n```html\n<meta charset=\"UTF-8\">\n```\n\n但是通过meta我们可以实现很多特别的功能。\n\n#### meta是什么\n\n>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.\n\n换句话来说，就是页面里对用户不可见，但是可供浏览器解析的页面信息。\n\n#### meta的类型\n\n##### http-equiv\n\n这一类使用格式为`<meta http-equiv=\"参数\" content=\"具体的描述\">`\n\n- content-Type\n可以设置html的字符集和格式，但是被`<meta charset=\"utf-8\">`取代\n\n- X-UA-Compatible\n设置浏览器渲染模式，一般采取最新的：\n```html\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/>\n```\n\n- cache-control\n设置浏览器缓存，一般设置为`<meta http-equiv=\"cache-control\" content=\"no-cache\">`\n可设置为以下属性：\n\t- no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。\n\t- no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）\n\t- public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果\n\t- private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）\n\t- maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。\n    - no-siteapp: 禁止百度默认的移动端转码。\n    \n- expires\n设置网页过期时间，超时需要重新从服务器获取。\n```html\n<meta http-equiv=\"expires\" content=\"Sunday 26 October 2016 01:00 GMT\" />\n```\n\n- refresh\n网页将在设定的时间内，自动刷新并调向设定的网址。\n```html\n<meta http-equiv=\"refresh\" content=\"2;URL=https://blog.sparkinglemon.me\">\n```\n设置为2s后自动转向到网址\n\n- Set-Cookie\n配置页面cookie\n\n##### name\nname属性的配置格式\n```html\n<meta name=\"参数\" content=\"具体的描述\">\n```\n\n- keywords\n设置页面关键词，SEO收录常用\n\n- description\n页面描述，SEO常用\n\n- viewport\n__移动端__ 设置视口。后续会在移动端适配详细补充。\n\n- robots\n告知爬虫具体需要爬取的页面，默认是all ，可以设置none，noindex（非本页），nofollow（通过本页索引其他页）\n\n- author\n页面作者，不常用\n\n- generator\n页面制作于\n\n- copyright\n页面版权信息\n\n- revisit-after\n设置爬虫重访时间\n\n\n> 部分内容参考了 [Lxxyx-“HTML meta标签总结与属性使用介绍”](https://segmentfault.com/a/1190000004279791)","source":"_posts/fe/meta标签的使用.md","raw":"---\ntags:\n- HTML\ncategories: Frontend\ntitle: meta标签的使用\ndate: 2019-08-17T00:00:00.000+08:00\nexcerpt: meta标签我们总是一键生成，但是忽略了里面一些特殊属性值所能带来方便，这篇文章简单列出一些常用但缺少注意的标签值。\nthumbnail: ''\n\n---\n平时使用时最常见的用法：\n```html\n<meta charset=\"UTF-8\">\n```\n\n但是通过meta我们可以实现很多特别的功能。\n\n#### meta是什么\n\n>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.\n\n换句话来说，就是页面里对用户不可见，但是可供浏览器解析的页面信息。\n\n#### meta的类型\n\n##### http-equiv\n\n这一类使用格式为`<meta http-equiv=\"参数\" content=\"具体的描述\">`\n\n- content-Type\n可以设置html的字符集和格式，但是被`<meta charset=\"utf-8\">`取代\n\n- X-UA-Compatible\n设置浏览器渲染模式，一般采取最新的：\n```html\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/>\n```\n\n- cache-control\n设置浏览器缓存，一般设置为`<meta http-equiv=\"cache-control\" content=\"no-cache\">`\n可设置为以下属性：\n\t- no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。\n\t- no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）\n\t- public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果\n\t- private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）\n\t- maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。\n    - no-siteapp: 禁止百度默认的移动端转码。\n    \n- expires\n设置网页过期时间，超时需要重新从服务器获取。\n```html\n<meta http-equiv=\"expires\" content=\"Sunday 26 October 2016 01:00 GMT\" />\n```\n\n- refresh\n网页将在设定的时间内，自动刷新并调向设定的网址。\n```html\n<meta http-equiv=\"refresh\" content=\"2;URL=https://blog.sparkinglemon.me\">\n```\n设置为2s后自动转向到网址\n\n- Set-Cookie\n配置页面cookie\n\n##### name\nname属性的配置格式\n```html\n<meta name=\"参数\" content=\"具体的描述\">\n```\n\n- keywords\n设置页面关键词，SEO收录常用\n\n- description\n页面描述，SEO常用\n\n- viewport\n__移动端__ 设置视口。后续会在移动端适配详细补充。\n\n- robots\n告知爬虫具体需要爬取的页面，默认是all ，可以设置none，noindex（非本页），nofollow（通过本页索引其他页）\n\n- author\n页面作者，不常用\n\n- generator\n页面制作于\n\n- copyright\n页面版权信息\n\n- revisit-after\n设置爬虫重访时间\n\n\n> 部分内容参考了 [Lxxyx-“HTML meta标签总结与属性使用介绍”](https://segmentfault.com/a/1190000004279791)","slug":"fe/meta标签的使用","published":1,"updated":"2020-08-01T18:21:52.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iai000sj1wth0hxhc9t","content":"<p>平时使用时最常见的用法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是通过meta我们可以实现很多特别的功能。</p>\n<h4 id=\"meta是什么\"><a href=\"#meta是什么\" class=\"headerlink\" title=\"meta是什么\"></a>meta是什么</h4><blockquote>\n<p>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p>\n</blockquote>\n<p>换句话来说，就是页面里对用户不可见，但是可供浏览器解析的页面信息。</p>\n<h4 id=\"meta的类型\"><a href=\"#meta的类型\" class=\"headerlink\" title=\"meta的类型\"></a>meta的类型</h4><h5 id=\"http-equiv\"><a href=\"#http-equiv\" class=\"headerlink\" title=\"http-equiv\"></a>http-equiv</h5><p>这一类使用格式为<code>&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;</code></p>\n<ul>\n<li><p>content-Type<br>可以设置html的字符集和格式，但是被<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>取代</p>\n</li>\n<li><p>X-UA-Compatible<br>设置浏览器渲染模式，一般采取最新的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"IE=edge,chrome=1\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cache-control<br>设置浏览器缓存，一般设置为<code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code><br>可设置为以下属性：</p>\n<ul>\n<li>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</li>\n<li>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</li>\n<li>public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</li>\n<li>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</li>\n<li>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</li>\n<li>no-siteapp: 禁止百度默认的移动端转码。</li>\n</ul>\n</li>\n<li><p>expires<br>设置网页过期时间，超时需要重新从服务器获取。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"expires\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Sunday 26 October 2016 01:00 GMT\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>refresh<br>网页将在设定的时间内，自动刷新并调向设定的网址。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"refresh\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"2;URL=https://blog.sparkinglemon.me\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>设置为2s后自动转向到网址</p>\n</li>\n<li><p>Set-Cookie<br>配置页面cookie</p>\n</li>\n</ul>\n<h5 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h5><p>name属性的配置格式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"参数\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"具体的描述\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>keywords<br>设置页面关键词，SEO收录常用</p>\n</li>\n<li><p>description<br>页面描述，SEO常用</p>\n</li>\n<li><p>viewport<br><strong>移动端</strong> 设置视口。后续会在移动端适配详细补充。</p>\n</li>\n<li><p>robots<br>告知爬虫具体需要爬取的页面，默认是all ，可以设置none，noindex（非本页），nofollow（通过本页索引其他页）</p>\n</li>\n<li><p>author<br>页面作者，不常用</p>\n</li>\n<li><p>generator<br>页面制作于</p>\n</li>\n<li><p>copyright<br>页面版权信息</p>\n</li>\n<li><p>revisit-after<br>设置爬虫重访时间</p>\n</li>\n</ul>\n<blockquote>\n<p>部分内容参考了 <a href=\"https://segmentfault.com/a/1190000004279791\">Lxxyx-“HTML meta标签总结与属性使用介绍”</a></p>\n</blockquote>\n","site":{"data":{}},"more":"<p>平时使用时最常见的用法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是通过meta我们可以实现很多特别的功能。</p>\n<h4 id=\"meta是什么\"><a href=\"#meta是什么\" class=\"headerlink\" title=\"meta是什么\"></a>meta是什么</h4><blockquote>\n<p>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p>\n</blockquote>\n<p>换句话来说，就是页面里对用户不可见，但是可供浏览器解析的页面信息。</p>\n<h4 id=\"meta的类型\"><a href=\"#meta的类型\" class=\"headerlink\" title=\"meta的类型\"></a>meta的类型</h4><h5 id=\"http-equiv\"><a href=\"#http-equiv\" class=\"headerlink\" title=\"http-equiv\"></a>http-equiv</h5><p>这一类使用格式为<code>&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;</code></p>\n<ul>\n<li><p>content-Type<br>可以设置html的字符集和格式，但是被<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>取代</p>\n</li>\n<li><p>X-UA-Compatible<br>设置浏览器渲染模式，一般采取最新的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"IE=edge,chrome=1\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>cache-control<br>设置浏览器缓存，一般设置为<code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code><br>可设置为以下属性：</p>\n<ul>\n<li>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</li>\n<li>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</li>\n<li>public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</li>\n<li>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</li>\n<li>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</li>\n<li>no-siteapp: 禁止百度默认的移动端转码。</li>\n</ul>\n</li>\n<li><p>expires<br>设置网页过期时间，超时需要重新从服务器获取。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"expires\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Sunday 26 October 2016 01:00 GMT\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>refresh<br>网页将在设定的时间内，自动刷新并调向设定的网址。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"refresh\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"2;URL=https://blog.sparkinglemon.me\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>设置为2s后自动转向到网址</p>\n</li>\n<li><p>Set-Cookie<br>配置页面cookie</p>\n</li>\n</ul>\n<h5 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h5><p>name属性的配置格式</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"参数\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"具体的描述\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>keywords<br>设置页面关键词，SEO收录常用</p>\n</li>\n<li><p>description<br>页面描述，SEO常用</p>\n</li>\n<li><p>viewport<br><strong>移动端</strong> 设置视口。后续会在移动端适配详细补充。</p>\n</li>\n<li><p>robots<br>告知爬虫具体需要爬取的页面，默认是all ，可以设置none，noindex（非本页），nofollow（通过本页索引其他页）</p>\n</li>\n<li><p>author<br>页面作者，不常用</p>\n</li>\n<li><p>generator<br>页面制作于</p>\n</li>\n<li><p>copyright<br>页面版权信息</p>\n</li>\n<li><p>revisit-after<br>设置爬虫重访时间</p>\n</li>\n</ul>\n<blockquote>\n<p>部分内容参考了 <a href=\"https://segmentfault.com/a/1190000004279791\">Lxxyx-“HTML meta标签总结与属性使用介绍”</a></p>\n</blockquote>\n"},{"date":"2020-02-29T10:57:46.000Z","title":"\"Speaking JavaScript\"阅读笔记（二）","excerpt":"JavaScript阅读笔记第二部分，这部分是JS的一些基本内容。","thumbnail":"","_content":"### 2. JavaScript相关的一些事\n\n#### 2.1. JavaScript的性质\n\n- 它是动态的；\n- 它是动态类型； _（即便引入TypeScript协助开发也只能协助推导类型。）_\n- 它是函数式和面向对象的；\n\n### 3. JavaScript语言深入\n\n#### 3.1 语句\n\n凡是在JavaScript期望语句的地方都可以写表达式，不能在需要表达式的地方使用语句。\n\n如果使用二义表达式（语法类型是二义的），为了避免二义性，在解析过程中，JavaScript不能使用对象字面和函数表达式作为语句，即不能以下面的内容开头：\n- '{}'；\n- function关键词； _(所以IIFE模式需要将匿名函数放在一个括号内，如果不使用这个括号， JS会认为这是一个函数声明，而函数声明是不可以匿名的，而函数定义又不能立即执行。)_\n\n#### 3.2 数字\n\n刷题曾经遇到过一个这样的问题：\n\n```javascript\n// 以下那种写法能够正确输出？\n1.toString()  // 唯一一种不能正常输出的。\n1..toString()\n1 .toString()\n(1).toString()\n1.0.toString()\n```\n\n之所以存在这种问题，是因为JS内所有数字都是以浮点数存储的，这里紧跟的'.'会被认为是小数点。\n\n### 4. 值\n\n> 在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”，动态是指“运行时”。\n\n#### 4.1 强制转换\n\nJavaScript内置的转换机制只支持布尔值、数字、字符串和对象。\n\n怪异的两个转换：\n\n- `Number(null) === 0`\n- `Number(undefined); // NaN`\n\n两个约定的转换方式：\n\n- 乘法运算符会强制转换为数字；\n- 加法运算中如果一个是字符串，运算符会将另一个运算数转换为字符串。\n\n引擎内自带一个转换算法，ToPrimitive()，根据情景的不同偏好，先后完成：\n\n- 如果输入的是原始值，返回；\n- 如果输入是对象，偏好为数值，调用valueOf（偏好为字符串时优先调用toString)；\n- 否则，调用toString（valueOf）；\n- 否则，抛出一个TypeError。\n\n#### 4.2 null\n\nnull表示 __没有对象__ 。\n\nnull是原型链最顶端的元素。\n\n```javascript\nObject.getPrototypeOf(Object.prototype) // null\n```\n\n#### 4.3 原始值的包装对象（装箱）\n\n布尔值，数字和字符串这三种原始值都有响应的构造函数。它们的实例包含原始值。原始值可以从包装器借调方法。\n\n### 5. 运算符\n\nJavaScript中无法重载或自定义运算符，包括等号。\n\nNaN与本身不相等（宽松 & 严格）。\n\n#### 5.1 比较\n\n在比较包装实例和原始值的时候，原始值和包装的原始值是宽松相等的，（但两个相同的原始值它们的包装实例不相等）\n\n### 6. 数字\n\nNumber()在转换时一般优于parseFloat(), 原因：\n\n- 对非字符串使用parseFloat效率较低，因为在解析之前它会将参数强制转换为字符串；\n- parseFloat()会将空字符串解析成NaN；\n- parseFloat()会一直解析到最后一个合法的字符，这意味着最后可能得到的不是想要的结果，比如`parseFloat(123.45#)`\n\n### 7. 字符\n\n字符串是由JavaScript字符组成的不可变序列，其中每个字符是一个16位的UTF-16编码单元。（一个Unicode字符相当于一个或两个JavaScript字符）\n\n优化：新版本JavaScript引擎通过加号+优化字符串拼接并在内部使用相似的方法（array.push()）。\n\n### 8. 数组\n\n不要用for-in来遍历数组，因为for-in只会遍历索引，而不是数组元素，其次还会遍历所有的（非索引）属性值。\n\n注意，for-in遍历对象所有的可枚举属性，其中包括了继承来的属性，因此需要判断是否为自身的：\n\n```javascript\nfor(var key in person) {\n\tif(Object.prototype.hasOwnProperty.call(person, key) { // 为了避免person自身有hasOwnProperty方法\n    \tconsole.log(key)   \n    }\n}\n```\n\n### 9. 错误处理\n\n对于异常捕获有两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。\n\nError是通用的异常构造器，所有其他的异常构造器都是它的子构造器，因此我们可以自定义错误构造器。","source":"_posts/fe/speaking-javascript-阅读笔记-二.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-02-29T18:57:46.000+00:00\ntitle: '\"Speaking JavaScript\"阅读笔记（二）'\nexcerpt: JavaScript阅读笔记第二部分，这部分是JS的一些基本内容。\nthumbnail: ''\n\n---\n### 2. JavaScript相关的一些事\n\n#### 2.1. JavaScript的性质\n\n- 它是动态的；\n- 它是动态类型； _（即便引入TypeScript协助开发也只能协助推导类型。）_\n- 它是函数式和面向对象的；\n\n### 3. JavaScript语言深入\n\n#### 3.1 语句\n\n凡是在JavaScript期望语句的地方都可以写表达式，不能在需要表达式的地方使用语句。\n\n如果使用二义表达式（语法类型是二义的），为了避免二义性，在解析过程中，JavaScript不能使用对象字面和函数表达式作为语句，即不能以下面的内容开头：\n- '{}'；\n- function关键词； _(所以IIFE模式需要将匿名函数放在一个括号内，如果不使用这个括号， JS会认为这是一个函数声明，而函数声明是不可以匿名的，而函数定义又不能立即执行。)_\n\n#### 3.2 数字\n\n刷题曾经遇到过一个这样的问题：\n\n```javascript\n// 以下那种写法能够正确输出？\n1.toString()  // 唯一一种不能正常输出的。\n1..toString()\n1 .toString()\n(1).toString()\n1.0.toString()\n```\n\n之所以存在这种问题，是因为JS内所有数字都是以浮点数存储的，这里紧跟的'.'会被认为是小数点。\n\n### 4. 值\n\n> 在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”，动态是指“运行时”。\n\n#### 4.1 强制转换\n\nJavaScript内置的转换机制只支持布尔值、数字、字符串和对象。\n\n怪异的两个转换：\n\n- `Number(null) === 0`\n- `Number(undefined); // NaN`\n\n两个约定的转换方式：\n\n- 乘法运算符会强制转换为数字；\n- 加法运算中如果一个是字符串，运算符会将另一个运算数转换为字符串。\n\n引擎内自带一个转换算法，ToPrimitive()，根据情景的不同偏好，先后完成：\n\n- 如果输入的是原始值，返回；\n- 如果输入是对象，偏好为数值，调用valueOf（偏好为字符串时优先调用toString)；\n- 否则，调用toString（valueOf）；\n- 否则，抛出一个TypeError。\n\n#### 4.2 null\n\nnull表示 __没有对象__ 。\n\nnull是原型链最顶端的元素。\n\n```javascript\nObject.getPrototypeOf(Object.prototype) // null\n```\n\n#### 4.3 原始值的包装对象（装箱）\n\n布尔值，数字和字符串这三种原始值都有响应的构造函数。它们的实例包含原始值。原始值可以从包装器借调方法。\n\n### 5. 运算符\n\nJavaScript中无法重载或自定义运算符，包括等号。\n\nNaN与本身不相等（宽松 & 严格）。\n\n#### 5.1 比较\n\n在比较包装实例和原始值的时候，原始值和包装的原始值是宽松相等的，（但两个相同的原始值它们的包装实例不相等）\n\n### 6. 数字\n\nNumber()在转换时一般优于parseFloat(), 原因：\n\n- 对非字符串使用parseFloat效率较低，因为在解析之前它会将参数强制转换为字符串；\n- parseFloat()会将空字符串解析成NaN；\n- parseFloat()会一直解析到最后一个合法的字符，这意味着最后可能得到的不是想要的结果，比如`parseFloat(123.45#)`\n\n### 7. 字符\n\n字符串是由JavaScript字符组成的不可变序列，其中每个字符是一个16位的UTF-16编码单元。（一个Unicode字符相当于一个或两个JavaScript字符）\n\n优化：新版本JavaScript引擎通过加号+优化字符串拼接并在内部使用相似的方法（array.push()）。\n\n### 8. 数组\n\n不要用for-in来遍历数组，因为for-in只会遍历索引，而不是数组元素，其次还会遍历所有的（非索引）属性值。\n\n注意，for-in遍历对象所有的可枚举属性，其中包括了继承来的属性，因此需要判断是否为自身的：\n\n```javascript\nfor(var key in person) {\n\tif(Object.prototype.hasOwnProperty.call(person, key) { // 为了避免person自身有hasOwnProperty方法\n    \tconsole.log(key)   \n    }\n}\n```\n\n### 9. 错误处理\n\n对于异常捕获有两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。\n\nError是通用的异常构造器，所有其他的异常构造器都是它的子构造器，因此我们可以自定义错误构造器。","slug":"fe/speaking-javascript-阅读笔记-二","published":1,"updated":"2020-08-01T18:21:52.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iaj000vj1wth4n56w1e","content":"<h3 id=\"2-JavaScript相关的一些事\"><a href=\"#2-JavaScript相关的一些事\" class=\"headerlink\" title=\"2. JavaScript相关的一些事\"></a>2. JavaScript相关的一些事</h3><h4 id=\"2-1-JavaScript的性质\"><a href=\"#2-1-JavaScript的性质\" class=\"headerlink\" title=\"2.1. JavaScript的性质\"></a>2.1. JavaScript的性质</h4><ul>\n<li>它是动态的；</li>\n<li>它是动态类型； <em>（即便引入TypeScript协助开发也只能协助推导类型。）</em></li>\n<li>它是函数式和面向对象的；</li>\n</ul>\n<h3 id=\"3-JavaScript语言深入\"><a href=\"#3-JavaScript语言深入\" class=\"headerlink\" title=\"3. JavaScript语言深入\"></a>3. JavaScript语言深入</h3><h4 id=\"3-1-语句\"><a href=\"#3-1-语句\" class=\"headerlink\" title=\"3.1 语句\"></a>3.1 语句</h4><p>凡是在JavaScript期望语句的地方都可以写表达式，不能在需要表达式的地方使用语句。</p>\n<p>如果使用二义表达式（语法类型是二义的），为了避免二义性，在解析过程中，JavaScript不能使用对象字面和函数表达式作为语句，即不能以下面的内容开头：</p>\n<ul>\n<li>‘{}’；</li>\n<li>function关键词； <em>(所以IIFE模式需要将匿名函数放在一个括号内，如果不使用这个括号， JS会认为这是一个函数声明，而函数声明是不可以匿名的，而函数定义又不能立即执行。)</em></li>\n</ul>\n<h4 id=\"3-2-数字\"><a href=\"#3-2-数字\" class=\"headerlink\" title=\"3.2 数字\"></a>3.2 数字</h4><p>刷题曾经遇到过一个这样的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下那种写法能够正确输出？</span></span><br><span class=\"line\"><span class=\"number\">1.</span>toString()  <span class=\"comment\">// 唯一一种不能正常输出的。</span></span><br><span class=\"line\"><span class=\"number\">1.</span>.toString()</span><br><span class=\"line\"><span class=\"number\">1</span> .toString()</span><br><span class=\"line\">(<span class=\"number\">1</span>).toString()</span><br><span class=\"line\"><span class=\"number\">1.0</span>.toString()</span><br></pre></td></tr></table></figure>\n\n<p>之所以存在这种问题，是因为JS内所有数字都是以浮点数存储的，这里紧跟的’.’会被认为是小数点。</p>\n<h3 id=\"4-值\"><a href=\"#4-值\" class=\"headerlink\" title=\"4. 值\"></a>4. 值</h3><blockquote>\n<p>在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”，动态是指“运行时”。</p>\n</blockquote>\n<h4 id=\"4-1-强制转换\"><a href=\"#4-1-强制转换\" class=\"headerlink\" title=\"4.1 强制转换\"></a>4.1 强制转换</h4><p>JavaScript内置的转换机制只支持布尔值、数字、字符串和对象。</p>\n<p>怪异的两个转换：</p>\n<ul>\n<li><code>Number(null) === 0</code></li>\n<li><code>Number(undefined); // NaN</code></li>\n</ul>\n<p>两个约定的转换方式：</p>\n<ul>\n<li>乘法运算符会强制转换为数字；</li>\n<li>加法运算中如果一个是字符串，运算符会将另一个运算数转换为字符串。</li>\n</ul>\n<p>引擎内自带一个转换算法，ToPrimitive()，根据情景的不同偏好，先后完成：</p>\n<ul>\n<li>如果输入的是原始值，返回；</li>\n<li>如果输入是对象，偏好为数值，调用valueOf（偏好为字符串时优先调用toString)；</li>\n<li>否则，调用toString（valueOf）；</li>\n<li>否则，抛出一个TypeError。</li>\n</ul>\n<h4 id=\"4-2-null\"><a href=\"#4-2-null\" class=\"headerlink\" title=\"4.2 null\"></a>4.2 null</h4><p>null表示 <strong>没有对象</strong> 。</p>\n<p>null是原型链最顶端的元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype) <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-原始值的包装对象（装箱）\"><a href=\"#4-3-原始值的包装对象（装箱）\" class=\"headerlink\" title=\"4.3 原始值的包装对象（装箱）\"></a>4.3 原始值的包装对象（装箱）</h4><p>布尔值，数字和字符串这三种原始值都有响应的构造函数。它们的实例包含原始值。原始值可以从包装器借调方法。</p>\n<h3 id=\"5-运算符\"><a href=\"#5-运算符\" class=\"headerlink\" title=\"5. 运算符\"></a>5. 运算符</h3><p>JavaScript中无法重载或自定义运算符，包括等号。</p>\n<p>NaN与本身不相等（宽松 &amp; 严格）。</p>\n<h4 id=\"5-1-比较\"><a href=\"#5-1-比较\" class=\"headerlink\" title=\"5.1 比较\"></a>5.1 比较</h4><p>在比较包装实例和原始值的时候，原始值和包装的原始值是宽松相等的，（但两个相同的原始值它们的包装实例不相等）</p>\n<h3 id=\"6-数字\"><a href=\"#6-数字\" class=\"headerlink\" title=\"6. 数字\"></a>6. 数字</h3><p>Number()在转换时一般优于parseFloat(), 原因：</p>\n<ul>\n<li>对非字符串使用parseFloat效率较低，因为在解析之前它会将参数强制转换为字符串；</li>\n<li>parseFloat()会将空字符串解析成NaN；</li>\n<li>parseFloat()会一直解析到最后一个合法的字符，这意味着最后可能得到的不是想要的结果，比如<code>parseFloat(123.45#)</code></li>\n</ul>\n<h3 id=\"7-字符\"><a href=\"#7-字符\" class=\"headerlink\" title=\"7. 字符\"></a>7. 字符</h3><p>字符串是由JavaScript字符组成的不可变序列，其中每个字符是一个16位的UTF-16编码单元。（一个Unicode字符相当于一个或两个JavaScript字符）</p>\n<p>优化：新版本JavaScript引擎通过加号+优化字符串拼接并在内部使用相似的方法（array.push()）。</p>\n<h3 id=\"8-数组\"><a href=\"#8-数组\" class=\"headerlink\" title=\"8. 数组\"></a>8. 数组</h3><p>不要用for-in来遍历数组，因为for-in只会遍历索引，而不是数组元素，其次还会遍历所有的（非索引）属性值。</p>\n<p>注意，for-in遍历对象所有的可枚举属性，其中包括了继承来的属性，因此需要判断是否为自身的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> person) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(person, key) &#123; <span class=\"comment\">// 为了避免person自身有hasOwnProperty方法</span></span><br><span class=\"line\">    \t<span class=\"built_in\">console</span>.log(key)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-错误处理\"><a href=\"#9-错误处理\" class=\"headerlink\" title=\"9. 错误处理\"></a>9. 错误处理</h3><p>对于异常捕获有两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。</p>\n<p>Error是通用的异常构造器，所有其他的异常构造器都是它的子构造器，因此我们可以自定义错误构造器。</p>\n","site":{"data":{}},"more":"<h3 id=\"2-JavaScript相关的一些事\"><a href=\"#2-JavaScript相关的一些事\" class=\"headerlink\" title=\"2. JavaScript相关的一些事\"></a>2. JavaScript相关的一些事</h3><h4 id=\"2-1-JavaScript的性质\"><a href=\"#2-1-JavaScript的性质\" class=\"headerlink\" title=\"2.1. JavaScript的性质\"></a>2.1. JavaScript的性质</h4><ul>\n<li>它是动态的；</li>\n<li>它是动态类型； <em>（即便引入TypeScript协助开发也只能协助推导类型。）</em></li>\n<li>它是函数式和面向对象的；</li>\n</ul>\n<h3 id=\"3-JavaScript语言深入\"><a href=\"#3-JavaScript语言深入\" class=\"headerlink\" title=\"3. JavaScript语言深入\"></a>3. JavaScript语言深入</h3><h4 id=\"3-1-语句\"><a href=\"#3-1-语句\" class=\"headerlink\" title=\"3.1 语句\"></a>3.1 语句</h4><p>凡是在JavaScript期望语句的地方都可以写表达式，不能在需要表达式的地方使用语句。</p>\n<p>如果使用二义表达式（语法类型是二义的），为了避免二义性，在解析过程中，JavaScript不能使用对象字面和函数表达式作为语句，即不能以下面的内容开头：</p>\n<ul>\n<li>‘{}’；</li>\n<li>function关键词； <em>(所以IIFE模式需要将匿名函数放在一个括号内，如果不使用这个括号， JS会认为这是一个函数声明，而函数声明是不可以匿名的，而函数定义又不能立即执行。)</em></li>\n</ul>\n<h4 id=\"3-2-数字\"><a href=\"#3-2-数字\" class=\"headerlink\" title=\"3.2 数字\"></a>3.2 数字</h4><p>刷题曾经遇到过一个这样的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下那种写法能够正确输出？</span></span><br><span class=\"line\"><span class=\"number\">1.</span>toString()  <span class=\"comment\">// 唯一一种不能正常输出的。</span></span><br><span class=\"line\"><span class=\"number\">1.</span>.toString()</span><br><span class=\"line\"><span class=\"number\">1</span> .toString()</span><br><span class=\"line\">(<span class=\"number\">1</span>).toString()</span><br><span class=\"line\"><span class=\"number\">1.0</span>.toString()</span><br></pre></td></tr></table></figure>\n\n<p>之所以存在这种问题，是因为JS内所有数字都是以浮点数存储的，这里紧跟的’.’会被认为是小数点。</p>\n<h3 id=\"4-值\"><a href=\"#4-值\" class=\"headerlink\" title=\"4. 值\"></a>4. 值</h3><blockquote>\n<p>在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”，动态是指“运行时”。</p>\n</blockquote>\n<h4 id=\"4-1-强制转换\"><a href=\"#4-1-强制转换\" class=\"headerlink\" title=\"4.1 强制转换\"></a>4.1 强制转换</h4><p>JavaScript内置的转换机制只支持布尔值、数字、字符串和对象。</p>\n<p>怪异的两个转换：</p>\n<ul>\n<li><code>Number(null) === 0</code></li>\n<li><code>Number(undefined); // NaN</code></li>\n</ul>\n<p>两个约定的转换方式：</p>\n<ul>\n<li>乘法运算符会强制转换为数字；</li>\n<li>加法运算中如果一个是字符串，运算符会将另一个运算数转换为字符串。</li>\n</ul>\n<p>引擎内自带一个转换算法，ToPrimitive()，根据情景的不同偏好，先后完成：</p>\n<ul>\n<li>如果输入的是原始值，返回；</li>\n<li>如果输入是对象，偏好为数值，调用valueOf（偏好为字符串时优先调用toString)；</li>\n<li>否则，调用toString（valueOf）；</li>\n<li>否则，抛出一个TypeError。</li>\n</ul>\n<h4 id=\"4-2-null\"><a href=\"#4-2-null\" class=\"headerlink\" title=\"4.2 null\"></a>4.2 null</h4><p>null表示 <strong>没有对象</strong> 。</p>\n<p>null是原型链最顶端的元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"built_in\">Object</span>.prototype) <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-原始值的包装对象（装箱）\"><a href=\"#4-3-原始值的包装对象（装箱）\" class=\"headerlink\" title=\"4.3 原始值的包装对象（装箱）\"></a>4.3 原始值的包装对象（装箱）</h4><p>布尔值，数字和字符串这三种原始值都有响应的构造函数。它们的实例包含原始值。原始值可以从包装器借调方法。</p>\n<h3 id=\"5-运算符\"><a href=\"#5-运算符\" class=\"headerlink\" title=\"5. 运算符\"></a>5. 运算符</h3><p>JavaScript中无法重载或自定义运算符，包括等号。</p>\n<p>NaN与本身不相等（宽松 &amp; 严格）。</p>\n<h4 id=\"5-1-比较\"><a href=\"#5-1-比较\" class=\"headerlink\" title=\"5.1 比较\"></a>5.1 比较</h4><p>在比较包装实例和原始值的时候，原始值和包装的原始值是宽松相等的，（但两个相同的原始值它们的包装实例不相等）</p>\n<h3 id=\"6-数字\"><a href=\"#6-数字\" class=\"headerlink\" title=\"6. 数字\"></a>6. 数字</h3><p>Number()在转换时一般优于parseFloat(), 原因：</p>\n<ul>\n<li>对非字符串使用parseFloat效率较低，因为在解析之前它会将参数强制转换为字符串；</li>\n<li>parseFloat()会将空字符串解析成NaN；</li>\n<li>parseFloat()会一直解析到最后一个合法的字符，这意味着最后可能得到的不是想要的结果，比如<code>parseFloat(123.45#)</code></li>\n</ul>\n<h3 id=\"7-字符\"><a href=\"#7-字符\" class=\"headerlink\" title=\"7. 字符\"></a>7. 字符</h3><p>字符串是由JavaScript字符组成的不可变序列，其中每个字符是一个16位的UTF-16编码单元。（一个Unicode字符相当于一个或两个JavaScript字符）</p>\n<p>优化：新版本JavaScript引擎通过加号+优化字符串拼接并在内部使用相似的方法（array.push()）。</p>\n<h3 id=\"8-数组\"><a href=\"#8-数组\" class=\"headerlink\" title=\"8. 数组\"></a>8. 数组</h3><p>不要用for-in来遍历数组，因为for-in只会遍历索引，而不是数组元素，其次还会遍历所有的（非索引）属性值。</p>\n<p>注意，for-in遍历对象所有的可枚举属性，其中包括了继承来的属性，因此需要判断是否为自身的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> person) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(person, key) &#123; <span class=\"comment\">// 为了避免person自身有hasOwnProperty方法</span></span><br><span class=\"line\">    \t<span class=\"built_in\">console</span>.log(key)   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-错误处理\"><a href=\"#9-错误处理\" class=\"headerlink\" title=\"9. 错误处理\"></a>9. 错误处理</h3><p>对于异常捕获有两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。</p>\n<p>Error是通用的异常构造器，所有其他的异常构造器都是它的子构造器，因此我们可以自定义错误构造器。</p>\n"},{"date":"2020-02-27T23:31:08.000Z","title":"\"Speaking JavaScript\"阅读笔记（一）","excerpt":"Speaking JavaScript，忘记捡起这本书的原因了，但是这一轮把欠下的债认真还了一边，收获良多，这一篇大部分都是铺垫的内容。","thumbnail":"","_content":"### 写在前面\n\n由于疫情的原因，这次离职比以往多了许多准备和复习的时间，也能沉下心好好复习一下基础知识点，本篇是我自己在阅读“Speaking JavaScript”时做出的摘录与笔记，在整理的过程中会加入一些自己想到的代码示例，并综合《JavaScript高级程序设计（第3版）》整理，如果有一些错误欢迎在下方的Disqus评论区指正，感谢！\n\n~~为什么没有用最新的第四版高程呢？因为2019.10.16才正式有英文版，而且作者和第三版不是同一位……等到出了正式中文版再做一次补充吧~~\n\n![Speaking JavaScript](https://cdn.sparkling.land/public/blog/images/orm_front_cover.jpg \"中文名：深入理解JavaScript\")\n\n# 0. JavaScript背景知识\n\n### 0.1. JavaScript与ECMAScript的关系\n\nECMAScript是JavaScript的官方命名，因为Java已经是一个商标。JavaScript指编程语言，ECMAScript是语言规范的名字。\n\n### 0.2. ECMAScript历程\n\n* 1th Edition (1997-01)\n* 2th Edition (1998-08)\n* 3th Edition (1999-12, 4th Edition has been abandoned at 2008-07)\n* 5th Edition (2009-12)\n* 6th Edition - ECMAScript 2015\n* 7th Edition - ECMAScript 2016\n* 8th Edition - ECMAScript 2017\n* 9th Edition - ECMAScript 2018\n* 10th Edition - ECMAScript 2019\n* ES.Next\n\n# 1. JavaScript的一些特性\n\n### 1.1 语法类别：语句和表达式\n\n```javascript\nvar foo; // 语句, do something\n3 * 7 // 表达式, 产生“值”\n```\n\n常见的一种情形是：三目表达式 与 `if-else`块。\n\n### 1.2 分号：建议使用\n\n分号用于结束语句，缺少的分号会通过分号自动插入机制(ASI)完成，什么是ASI呢？\n\n> ASI的目标是使分号对于行结束来说是可选的，也有说法是帮助解析器来确定语句的结束。\n\n__但是，在以下的情况下也会认定为语句结束: __\n\n* 行结束符后（如换行符）跟着一个非法token；\n* 遇到一个结束的花括号；\n* 文件已达结尾；\n\n```javascript\nif(a<0) a = 0\nconsole.log(a) // 0后跟console属于非法token\n```\n\n```javascript\nfunction foo(a, b) {\n\treturn // return意味着会自动插入一个分号，下文不再执行\n  \t{\n    \ta + b\n    }\n}\n```\n\n### 1.3 变量名\n\n一个合法的变量名规则：第一个字符可以是任意的Unicode字符、美元符号($)、或者下划线( _ )，后面还可以是任意的Unicode数字。\n\n> ECMAScript中的一切都区分大小写。\n\n但是保留字不能作为变量名，除保留字外以下变量也不建议：\n\n* `Infinity`\n* `NaN`\n* `undefined`\n\n### 1.4 值\n\n原始值：\n\n* true、false\n* 数字（均为浮点）\n* 字符串\n* “空值”: undefined, null\n\n除以上外，其他的值都是对象，特殊的，通过“装箱”我们可以得到非原始值的“字符串”、“布尔”、“数字”。\n\n> 当复制引用类型的值的时候，会复制一份值的副本到新变量分配的空间中，然而，**这个值的副本实际上是一个指针，指向存储在堆中的一个对象**。\n\n#### 1.4.1 如何对值分类\n\n1. typeof\n\ntypeof主要用于原始值，除`typeof null === 'object'`外，其他都有正确的输出。\n\n> typeof null是一个不能修正的bug，因为这会破坏现有的代码。~~直到目前的标准也不能修改~~\n\n1. instanceof\n\ninstanceof主要用于对象，用来判断 **value是否是一个通过Constr构造器创建的对象。**\n\n### 1.5 布尔值\n\n#### 1.5.1 假值\n\n以下值会被解释为假值：\n\n* undefined, null\n* false\n* ~~-0~~ , NaN (经过测试，目前浏览器对+0，-0均判断为false)\n* ''\n\n#### 1.5.2 二元操作符\n\nJavaScript的二元逻辑运算符是 **短路** 的，也就是说我们可以利用这个特点优化代码，尽量将大概率发生的优先判断。\n\n'&&'，'||'符号返回的是第一个运算数的 **假（真）值** 或者第二个运算数，也就是说其实际返回的是执行后的值。\n\n### 1.6 数字\n\nJavaScript中的所有的数字都是浮点数。\n\n### 1.7 字符串\n\n### 1.8 语句\n\n* 多条件情况下，switch的运行效率要高于if-else；\n* break可以跳离循环，continue会开始一个新的循环迭代，可以用来优化循环内的执行过程；\n\n### 1.9 函数\n\n#### 1.9.1 函数声明的提升特性\n\n注意与变量声明之间的区别，函数声明 **的实体会被移动到所在作用域的开始处** 。\n\n> 而变量声明会变成如下的代码：\n>\n> ```javascript\n>     var a; // undefined\n>     console.log(a); // undefined\n>     a = 3; // 3\n> ```\n\n但是要注意函数声明与函数表达式不同，后者只符合变量声明的提升规则。\n\n```javascript\nconsole.log(a); // undefined\nconsole.log(b); // Uncaught ReferenceError: b is not defined. stopped.\nvar a = function b() {\n    return 3;\n} \nconsole.log(a);\nconsole.log(b);\n```\n\n#### 1.9.2 特殊变量arguments\n\n所有参数变量——`arguments`看起来像一个数组，但是却不具备数组的方法。(Array-like)\n\n如果想将arguments转换为数组，代码如下：\n\n```javascript\nArray.prototype.slice.call(arrayLikeObject);\n```\n\n### 1.10 变量作用域\n\n一个变量的作用域总是完整的函数。\n\n#### 1.10.1 提升\n\n所有变量声明都会被提升，**声明** 会被移动到函数的开始处，而赋值仍然会在原来的位置。通常来说，优先提升`var a;`，然后再提升`function a`，然后再赋值。\n\n#### 1.10.2 闭包\n\n> 闭包是指有权访问另一个函数作用域中的变量的函数。 —— JS高程(第3版),后文简称高程\n\n一般外层函数内部存在一些变量，然后以返回一个函数的形式完成闭包，最常见的模式即“IIFE”\n\n#### 1.10.3 IIFE\n\n```javascript\n// 关于为什么这种写法可以完成IIFE，后续会补充在此。\n(function () {\n\tvar foo = 'test'\n}());\n```\n\n这里要注意闭包有时会存在并 **保持** 与外界变量的联系，如下：\n\n```javascript\nfor(var i=0;i<5;i++) {\n\tresult.push(function () { return i; }) // result[1]()执行后仍然是i = 5赋值的时候\n}\n```\n\n_与对象等有关的点单独总结一章详细说明_","source":"_posts/fe/speaking-javascript-阅读笔记-一.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-02-28T07:31:08.000+00:00\ntitle: '\"Speaking JavaScript\"阅读笔记（一）'\nexcerpt: Speaking JavaScript，忘记捡起这本书的原因了，但是这一轮把欠下的债认真还了一边，收获良多，这一篇大部分都是铺垫的内容。\nthumbnail: ''\n\n---\n### 写在前面\n\n由于疫情的原因，这次离职比以往多了许多准备和复习的时间，也能沉下心好好复习一下基础知识点，本篇是我自己在阅读“Speaking JavaScript”时做出的摘录与笔记，在整理的过程中会加入一些自己想到的代码示例，并综合《JavaScript高级程序设计（第3版）》整理，如果有一些错误欢迎在下方的Disqus评论区指正，感谢！\n\n~~为什么没有用最新的第四版高程呢？因为2019.10.16才正式有英文版，而且作者和第三版不是同一位……等到出了正式中文版再做一次补充吧~~\n\n![Speaking JavaScript](https://cdn.sparkling.land/public/blog/images/orm_front_cover.jpg \"中文名：深入理解JavaScript\")\n\n# 0. JavaScript背景知识\n\n### 0.1. JavaScript与ECMAScript的关系\n\nECMAScript是JavaScript的官方命名，因为Java已经是一个商标。JavaScript指编程语言，ECMAScript是语言规范的名字。\n\n### 0.2. ECMAScript历程\n\n* 1th Edition (1997-01)\n* 2th Edition (1998-08)\n* 3th Edition (1999-12, 4th Edition has been abandoned at 2008-07)\n* 5th Edition (2009-12)\n* 6th Edition - ECMAScript 2015\n* 7th Edition - ECMAScript 2016\n* 8th Edition - ECMAScript 2017\n* 9th Edition - ECMAScript 2018\n* 10th Edition - ECMAScript 2019\n* ES.Next\n\n# 1. JavaScript的一些特性\n\n### 1.1 语法类别：语句和表达式\n\n```javascript\nvar foo; // 语句, do something\n3 * 7 // 表达式, 产生“值”\n```\n\n常见的一种情形是：三目表达式 与 `if-else`块。\n\n### 1.2 分号：建议使用\n\n分号用于结束语句，缺少的分号会通过分号自动插入机制(ASI)完成，什么是ASI呢？\n\n> ASI的目标是使分号对于行结束来说是可选的，也有说法是帮助解析器来确定语句的结束。\n\n__但是，在以下的情况下也会认定为语句结束: __\n\n* 行结束符后（如换行符）跟着一个非法token；\n* 遇到一个结束的花括号；\n* 文件已达结尾；\n\n```javascript\nif(a<0) a = 0\nconsole.log(a) // 0后跟console属于非法token\n```\n\n```javascript\nfunction foo(a, b) {\n\treturn // return意味着会自动插入一个分号，下文不再执行\n  \t{\n    \ta + b\n    }\n}\n```\n\n### 1.3 变量名\n\n一个合法的变量名规则：第一个字符可以是任意的Unicode字符、美元符号($)、或者下划线( _ )，后面还可以是任意的Unicode数字。\n\n> ECMAScript中的一切都区分大小写。\n\n但是保留字不能作为变量名，除保留字外以下变量也不建议：\n\n* `Infinity`\n* `NaN`\n* `undefined`\n\n### 1.4 值\n\n原始值：\n\n* true、false\n* 数字（均为浮点）\n* 字符串\n* “空值”: undefined, null\n\n除以上外，其他的值都是对象，特殊的，通过“装箱”我们可以得到非原始值的“字符串”、“布尔”、“数字”。\n\n> 当复制引用类型的值的时候，会复制一份值的副本到新变量分配的空间中，然而，**这个值的副本实际上是一个指针，指向存储在堆中的一个对象**。\n\n#### 1.4.1 如何对值分类\n\n1. typeof\n\ntypeof主要用于原始值，除`typeof null === 'object'`外，其他都有正确的输出。\n\n> typeof null是一个不能修正的bug，因为这会破坏现有的代码。~~直到目前的标准也不能修改~~\n\n1. instanceof\n\ninstanceof主要用于对象，用来判断 **value是否是一个通过Constr构造器创建的对象。**\n\n### 1.5 布尔值\n\n#### 1.5.1 假值\n\n以下值会被解释为假值：\n\n* undefined, null\n* false\n* ~~-0~~ , NaN (经过测试，目前浏览器对+0，-0均判断为false)\n* ''\n\n#### 1.5.2 二元操作符\n\nJavaScript的二元逻辑运算符是 **短路** 的，也就是说我们可以利用这个特点优化代码，尽量将大概率发生的优先判断。\n\n'&&'，'||'符号返回的是第一个运算数的 **假（真）值** 或者第二个运算数，也就是说其实际返回的是执行后的值。\n\n### 1.6 数字\n\nJavaScript中的所有的数字都是浮点数。\n\n### 1.7 字符串\n\n### 1.8 语句\n\n* 多条件情况下，switch的运行效率要高于if-else；\n* break可以跳离循环，continue会开始一个新的循环迭代，可以用来优化循环内的执行过程；\n\n### 1.9 函数\n\n#### 1.9.1 函数声明的提升特性\n\n注意与变量声明之间的区别，函数声明 **的实体会被移动到所在作用域的开始处** 。\n\n> 而变量声明会变成如下的代码：\n>\n> ```javascript\n>     var a; // undefined\n>     console.log(a); // undefined\n>     a = 3; // 3\n> ```\n\n但是要注意函数声明与函数表达式不同，后者只符合变量声明的提升规则。\n\n```javascript\nconsole.log(a); // undefined\nconsole.log(b); // Uncaught ReferenceError: b is not defined. stopped.\nvar a = function b() {\n    return 3;\n} \nconsole.log(a);\nconsole.log(b);\n```\n\n#### 1.9.2 特殊变量arguments\n\n所有参数变量——`arguments`看起来像一个数组，但是却不具备数组的方法。(Array-like)\n\n如果想将arguments转换为数组，代码如下：\n\n```javascript\nArray.prototype.slice.call(arrayLikeObject);\n```\n\n### 1.10 变量作用域\n\n一个变量的作用域总是完整的函数。\n\n#### 1.10.1 提升\n\n所有变量声明都会被提升，**声明** 会被移动到函数的开始处，而赋值仍然会在原来的位置。通常来说，优先提升`var a;`，然后再提升`function a`，然后再赋值。\n\n#### 1.10.2 闭包\n\n> 闭包是指有权访问另一个函数作用域中的变量的函数。 —— JS高程(第3版),后文简称高程\n\n一般外层函数内部存在一些变量，然后以返回一个函数的形式完成闭包，最常见的模式即“IIFE”\n\n#### 1.10.3 IIFE\n\n```javascript\n// 关于为什么这种写法可以完成IIFE，后续会补充在此。\n(function () {\n\tvar foo = 'test'\n}());\n```\n\n这里要注意闭包有时会存在并 **保持** 与外界变量的联系，如下：\n\n```javascript\nfor(var i=0;i<5;i++) {\n\tresult.push(function () { return i; }) // result[1]()执行后仍然是i = 5赋值的时候\n}\n```\n\n_与对象等有关的点单独总结一章详细说明_","slug":"fe/speaking-javascript-阅读笔记-一","published":1,"updated":"2020-08-01T18:21:52.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iak000yj1wth5ya71ar","content":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>由于疫情的原因，这次离职比以往多了许多准备和复习的时间，也能沉下心好好复习一下基础知识点，本篇是我自己在阅读“Speaking JavaScript”时做出的摘录与笔记，在整理的过程中会加入一些自己想到的代码示例，并综合《JavaScript高级程序设计（第3版）》整理，如果有一些错误欢迎在下方的Disqus评论区指正，感谢！</p>\n<p><del>为什么没有用最新的第四版高程呢？因为2019.10.16才正式有英文版，而且作者和第三版不是同一位……等到出了正式中文版再做一次补充吧</del></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/orm_front_cover.jpg\" alt=\"Speaking JavaScript\" title=\"中文名：深入理解JavaScript\"></p>\n<h1 id=\"0-JavaScript背景知识\"><a href=\"#0-JavaScript背景知识\" class=\"headerlink\" title=\"0. JavaScript背景知识\"></a>0. JavaScript背景知识</h1><h3 id=\"0-1-JavaScript与ECMAScript的关系\"><a href=\"#0-1-JavaScript与ECMAScript的关系\" class=\"headerlink\" title=\"0.1. JavaScript与ECMAScript的关系\"></a>0.1. JavaScript与ECMAScript的关系</h3><p>ECMAScript是JavaScript的官方命名，因为Java已经是一个商标。JavaScript指编程语言，ECMAScript是语言规范的名字。</p>\n<h3 id=\"0-2-ECMAScript历程\"><a href=\"#0-2-ECMAScript历程\" class=\"headerlink\" title=\"0.2. ECMAScript历程\"></a>0.2. ECMAScript历程</h3><ul>\n<li>1th Edition (1997-01)</li>\n<li>2th Edition (1998-08)</li>\n<li>3th Edition (1999-12, 4th Edition has been abandoned at 2008-07)</li>\n<li>5th Edition (2009-12)</li>\n<li>6th Edition - ECMAScript 2015</li>\n<li>7th Edition - ECMAScript 2016</li>\n<li>8th Edition - ECMAScript 2017</li>\n<li>9th Edition - ECMAScript 2018</li>\n<li>10th Edition - ECMAScript 2019</li>\n<li>ES.Next</li>\n</ul>\n<h1 id=\"1-JavaScript的一些特性\"><a href=\"#1-JavaScript的一些特性\" class=\"headerlink\" title=\"1. JavaScript的一些特性\"></a>1. JavaScript的一些特性</h1><h3 id=\"1-1-语法类别：语句和表达式\"><a href=\"#1-1-语法类别：语句和表达式\" class=\"headerlink\" title=\"1.1 语法类别：语句和表达式\"></a>1.1 语法类别：语句和表达式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo; <span class=\"comment\">// 语句, do something</span></span><br><span class=\"line\"><span class=\"number\">3</span> * <span class=\"number\">7</span> <span class=\"comment\">// 表达式, 产生“值”</span></span><br></pre></td></tr></table></figure>\n\n<p>常见的一种情形是：三目表达式 与 <code>if-else</code>块。</p>\n<h3 id=\"1-2-分号：建议使用\"><a href=\"#1-2-分号：建议使用\" class=\"headerlink\" title=\"1.2 分号：建议使用\"></a>1.2 分号：建议使用</h3><p>分号用于结束语句，缺少的分号会通过分号自动插入机制(ASI)完成，什么是ASI呢？</p>\n<blockquote>\n<p>ASI的目标是使分号对于行结束来说是可选的，也有说法是帮助解析器来确定语句的结束。</p>\n</blockquote>\n<p>__但是，在以下的情况下也会认定为语句结束: __</p>\n<ul>\n<li>行结束符后（如换行符）跟着一个非法token；</li>\n<li>遇到一个结束的花括号；</li>\n<li>文件已达结尾；</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(a&lt;<span class=\"number\">0</span>) a = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 0后跟console属于非法token</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"comment\">// return意味着会自动插入一个分号，下文不再执行</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">    \ta + b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-变量名\"><a href=\"#1-3-变量名\" class=\"headerlink\" title=\"1.3 变量名\"></a>1.3 变量名</h3><p>一个合法的变量名规则：第一个字符可以是任意的Unicode字符、美元符号($)、或者下划线( _ )，后面还可以是任意的Unicode数字。</p>\n<blockquote>\n<p>ECMAScript中的一切都区分大小写。</p>\n</blockquote>\n<p>但是保留字不能作为变量名，除保留字外以下变量也不建议：</p>\n<ul>\n<li><code>Infinity</code></li>\n<li><code>NaN</code></li>\n<li><code>undefined</code></li>\n</ul>\n<h3 id=\"1-4-值\"><a href=\"#1-4-值\" class=\"headerlink\" title=\"1.4 值\"></a>1.4 值</h3><p>原始值：</p>\n<ul>\n<li>true、false</li>\n<li>数字（均为浮点）</li>\n<li>字符串</li>\n<li>“空值”: undefined, null</li>\n</ul>\n<p>除以上外，其他的值都是对象，特殊的，通过“装箱”我们可以得到非原始值的“字符串”、“布尔”、“数字”。</p>\n<blockquote>\n<p>当复制引用类型的值的时候，会复制一份值的副本到新变量分配的空间中，然而，<strong>这个值的副本实际上是一个指针，指向存储在堆中的一个对象</strong>。</p>\n</blockquote>\n<h4 id=\"1-4-1-如何对值分类\"><a href=\"#1-4-1-如何对值分类\" class=\"headerlink\" title=\"1.4.1 如何对值分类\"></a>1.4.1 如何对值分类</h4><ol>\n<li>typeof</li>\n</ol>\n<p>typeof主要用于原始值，除<code>typeof null === &#39;object&#39;</code>外，其他都有正确的输出。</p>\n<blockquote>\n<p>typeof null是一个不能修正的bug，因为这会破坏现有的代码。<del>直到目前的标准也不能修改</del></p>\n</blockquote>\n<ol>\n<li>instanceof</li>\n</ol>\n<p>instanceof主要用于对象，用来判断 <strong>value是否是一个通过Constr构造器创建的对象。</strong></p>\n<h3 id=\"1-5-布尔值\"><a href=\"#1-5-布尔值\" class=\"headerlink\" title=\"1.5 布尔值\"></a>1.5 布尔值</h3><h4 id=\"1-5-1-假值\"><a href=\"#1-5-1-假值\" class=\"headerlink\" title=\"1.5.1 假值\"></a>1.5.1 假值</h4><p>以下值会被解释为假值：</p>\n<ul>\n<li>undefined, null</li>\n<li>false</li>\n<li><del>-0</del> , NaN (经过测试，目前浏览器对+0，-0均判断为false)</li>\n<li>‘’</li>\n</ul>\n<h4 id=\"1-5-2-二元操作符\"><a href=\"#1-5-2-二元操作符\" class=\"headerlink\" title=\"1.5.2 二元操作符\"></a>1.5.2 二元操作符</h4><p>JavaScript的二元逻辑运算符是 <strong>短路</strong> 的，也就是说我们可以利用这个特点优化代码，尽量将大概率发生的优先判断。</p>\n<p>‘&amp;&amp;’，’||’符号返回的是第一个运算数的 <strong>假（真）值</strong> 或者第二个运算数，也就是说其实际返回的是执行后的值。</p>\n<h3 id=\"1-6-数字\"><a href=\"#1-6-数字\" class=\"headerlink\" title=\"1.6 数字\"></a>1.6 数字</h3><p>JavaScript中的所有的数字都是浮点数。</p>\n<h3 id=\"1-7-字符串\"><a href=\"#1-7-字符串\" class=\"headerlink\" title=\"1.7 字符串\"></a>1.7 字符串</h3><h3 id=\"1-8-语句\"><a href=\"#1-8-语句\" class=\"headerlink\" title=\"1.8 语句\"></a>1.8 语句</h3><ul>\n<li>多条件情况下，switch的运行效率要高于if-else；</li>\n<li>break可以跳离循环，continue会开始一个新的循环迭代，可以用来优化循环内的执行过程；</li>\n</ul>\n<h3 id=\"1-9-函数\"><a href=\"#1-9-函数\" class=\"headerlink\" title=\"1.9 函数\"></a>1.9 函数</h3><h4 id=\"1-9-1-函数声明的提升特性\"><a href=\"#1-9-1-函数声明的提升特性\" class=\"headerlink\" title=\"1.9.1 函数声明的提升特性\"></a>1.9.1 函数声明的提升特性</h4><p>注意与变量声明之间的区别，函数声明 <strong>的实体会被移动到所在作用域的开始处</strong> 。</p>\n<blockquote>\n<p>而变量声明会变成如下的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">3</span>; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>但是要注意函数声明与函数表达式不同，后者只符合变量声明的提升规则。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// Uncaught ReferenceError: b is not defined. stopped.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-9-2-特殊变量arguments\"><a href=\"#1-9-2-特殊变量arguments\" class=\"headerlink\" title=\"1.9.2 特殊变量arguments\"></a>1.9.2 特殊变量arguments</h4><p>所有参数变量——<code>arguments</code>看起来像一个数组，但是却不具备数组的方法。(Array-like)</p>\n<p>如果想将arguments转换为数组，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.slice.call(arrayLikeObject);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-变量作用域\"><a href=\"#1-10-变量作用域\" class=\"headerlink\" title=\"1.10 变量作用域\"></a>1.10 变量作用域</h3><p>一个变量的作用域总是完整的函数。</p>\n<h4 id=\"1-10-1-提升\"><a href=\"#1-10-1-提升\" class=\"headerlink\" title=\"1.10.1 提升\"></a>1.10.1 提升</h4><p>所有变量声明都会被提升，<strong>声明</strong> 会被移动到函数的开始处，而赋值仍然会在原来的位置。通常来说，优先提升<code>var a;</code>，然后再提升<code>function a</code>，然后再赋值。</p>\n<h4 id=\"1-10-2-闭包\"><a href=\"#1-10-2-闭包\" class=\"headerlink\" title=\"1.10.2 闭包\"></a>1.10.2 闭包</h4><blockquote>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数。 —— JS高程(第3版),后文简称高程</p>\n</blockquote>\n<p>一般外层函数内部存在一些变量，然后以返回一个函数的形式完成闭包，最常见的模式即“IIFE”</p>\n<h4 id=\"1-10-3-IIFE\"><a href=\"#1-10-3-IIFE\" class=\"headerlink\" title=\"1.10.3 IIFE\"></a>1.10.3 IIFE</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关于为什么这种写法可以完成IIFE，后续会补充在此。</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> foo = <span class=\"string\">'test'</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>这里要注意闭包有时会存在并 <strong>保持</strong> 与外界变量的联系，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++) &#123;</span><br><span class=\"line\">\tresult.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> i; &#125;) <span class=\"comment\">// result[1]()执行后仍然是i = 5赋值的时候</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>与对象等有关的点单独总结一章详细说明</em></p>\n","site":{"data":{}},"more":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>由于疫情的原因，这次离职比以往多了许多准备和复习的时间，也能沉下心好好复习一下基础知识点，本篇是我自己在阅读“Speaking JavaScript”时做出的摘录与笔记，在整理的过程中会加入一些自己想到的代码示例，并综合《JavaScript高级程序设计（第3版）》整理，如果有一些错误欢迎在下方的Disqus评论区指正，感谢！</p>\n<p><del>为什么没有用最新的第四版高程呢？因为2019.10.16才正式有英文版，而且作者和第三版不是同一位……等到出了正式中文版再做一次补充吧</del></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/orm_front_cover.jpg\" alt=\"Speaking JavaScript\" title=\"中文名：深入理解JavaScript\"></p>\n<h1 id=\"0-JavaScript背景知识\"><a href=\"#0-JavaScript背景知识\" class=\"headerlink\" title=\"0. JavaScript背景知识\"></a>0. JavaScript背景知识</h1><h3 id=\"0-1-JavaScript与ECMAScript的关系\"><a href=\"#0-1-JavaScript与ECMAScript的关系\" class=\"headerlink\" title=\"0.1. JavaScript与ECMAScript的关系\"></a>0.1. JavaScript与ECMAScript的关系</h3><p>ECMAScript是JavaScript的官方命名，因为Java已经是一个商标。JavaScript指编程语言，ECMAScript是语言规范的名字。</p>\n<h3 id=\"0-2-ECMAScript历程\"><a href=\"#0-2-ECMAScript历程\" class=\"headerlink\" title=\"0.2. ECMAScript历程\"></a>0.2. ECMAScript历程</h3><ul>\n<li>1th Edition (1997-01)</li>\n<li>2th Edition (1998-08)</li>\n<li>3th Edition (1999-12, 4th Edition has been abandoned at 2008-07)</li>\n<li>5th Edition (2009-12)</li>\n<li>6th Edition - ECMAScript 2015</li>\n<li>7th Edition - ECMAScript 2016</li>\n<li>8th Edition - ECMAScript 2017</li>\n<li>9th Edition - ECMAScript 2018</li>\n<li>10th Edition - ECMAScript 2019</li>\n<li>ES.Next</li>\n</ul>\n<h1 id=\"1-JavaScript的一些特性\"><a href=\"#1-JavaScript的一些特性\" class=\"headerlink\" title=\"1. JavaScript的一些特性\"></a>1. JavaScript的一些特性</h1><h3 id=\"1-1-语法类别：语句和表达式\"><a href=\"#1-1-语法类别：语句和表达式\" class=\"headerlink\" title=\"1.1 语法类别：语句和表达式\"></a>1.1 语法类别：语句和表达式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo; <span class=\"comment\">// 语句, do something</span></span><br><span class=\"line\"><span class=\"number\">3</span> * <span class=\"number\">7</span> <span class=\"comment\">// 表达式, 产生“值”</span></span><br></pre></td></tr></table></figure>\n\n<p>常见的一种情形是：三目表达式 与 <code>if-else</code>块。</p>\n<h3 id=\"1-2-分号：建议使用\"><a href=\"#1-2-分号：建议使用\" class=\"headerlink\" title=\"1.2 分号：建议使用\"></a>1.2 分号：建议使用</h3><p>分号用于结束语句，缺少的分号会通过分号自动插入机制(ASI)完成，什么是ASI呢？</p>\n<blockquote>\n<p>ASI的目标是使分号对于行结束来说是可选的，也有说法是帮助解析器来确定语句的结束。</p>\n</blockquote>\n<p>__但是，在以下的情况下也会认定为语句结束: __</p>\n<ul>\n<li>行结束符后（如换行符）跟着一个非法token；</li>\n<li>遇到一个结束的花括号；</li>\n<li>文件已达结尾；</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(a&lt;<span class=\"number\">0</span>) a = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// 0后跟console属于非法token</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"comment\">// return意味着会自动插入一个分号，下文不再执行</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">    \ta + b</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-变量名\"><a href=\"#1-3-变量名\" class=\"headerlink\" title=\"1.3 变量名\"></a>1.3 变量名</h3><p>一个合法的变量名规则：第一个字符可以是任意的Unicode字符、美元符号($)、或者下划线( _ )，后面还可以是任意的Unicode数字。</p>\n<blockquote>\n<p>ECMAScript中的一切都区分大小写。</p>\n</blockquote>\n<p>但是保留字不能作为变量名，除保留字外以下变量也不建议：</p>\n<ul>\n<li><code>Infinity</code></li>\n<li><code>NaN</code></li>\n<li><code>undefined</code></li>\n</ul>\n<h3 id=\"1-4-值\"><a href=\"#1-4-值\" class=\"headerlink\" title=\"1.4 值\"></a>1.4 值</h3><p>原始值：</p>\n<ul>\n<li>true、false</li>\n<li>数字（均为浮点）</li>\n<li>字符串</li>\n<li>“空值”: undefined, null</li>\n</ul>\n<p>除以上外，其他的值都是对象，特殊的，通过“装箱”我们可以得到非原始值的“字符串”、“布尔”、“数字”。</p>\n<blockquote>\n<p>当复制引用类型的值的时候，会复制一份值的副本到新变量分配的空间中，然而，<strong>这个值的副本实际上是一个指针，指向存储在堆中的一个对象</strong>。</p>\n</blockquote>\n<h4 id=\"1-4-1-如何对值分类\"><a href=\"#1-4-1-如何对值分类\" class=\"headerlink\" title=\"1.4.1 如何对值分类\"></a>1.4.1 如何对值分类</h4><ol>\n<li>typeof</li>\n</ol>\n<p>typeof主要用于原始值，除<code>typeof null === &#39;object&#39;</code>外，其他都有正确的输出。</p>\n<blockquote>\n<p>typeof null是一个不能修正的bug，因为这会破坏现有的代码。<del>直到目前的标准也不能修改</del></p>\n</blockquote>\n<ol>\n<li>instanceof</li>\n</ol>\n<p>instanceof主要用于对象，用来判断 <strong>value是否是一个通过Constr构造器创建的对象。</strong></p>\n<h3 id=\"1-5-布尔值\"><a href=\"#1-5-布尔值\" class=\"headerlink\" title=\"1.5 布尔值\"></a>1.5 布尔值</h3><h4 id=\"1-5-1-假值\"><a href=\"#1-5-1-假值\" class=\"headerlink\" title=\"1.5.1 假值\"></a>1.5.1 假值</h4><p>以下值会被解释为假值：</p>\n<ul>\n<li>undefined, null</li>\n<li>false</li>\n<li><del>-0</del> , NaN (经过测试，目前浏览器对+0，-0均判断为false)</li>\n<li>‘’</li>\n</ul>\n<h4 id=\"1-5-2-二元操作符\"><a href=\"#1-5-2-二元操作符\" class=\"headerlink\" title=\"1.5.2 二元操作符\"></a>1.5.2 二元操作符</h4><p>JavaScript的二元逻辑运算符是 <strong>短路</strong> 的，也就是说我们可以利用这个特点优化代码，尽量将大概率发生的优先判断。</p>\n<p>‘&amp;&amp;’，’||’符号返回的是第一个运算数的 <strong>假（真）值</strong> 或者第二个运算数，也就是说其实际返回的是执行后的值。</p>\n<h3 id=\"1-6-数字\"><a href=\"#1-6-数字\" class=\"headerlink\" title=\"1.6 数字\"></a>1.6 数字</h3><p>JavaScript中的所有的数字都是浮点数。</p>\n<h3 id=\"1-7-字符串\"><a href=\"#1-7-字符串\" class=\"headerlink\" title=\"1.7 字符串\"></a>1.7 字符串</h3><h3 id=\"1-8-语句\"><a href=\"#1-8-语句\" class=\"headerlink\" title=\"1.8 语句\"></a>1.8 语句</h3><ul>\n<li>多条件情况下，switch的运行效率要高于if-else；</li>\n<li>break可以跳离循环，continue会开始一个新的循环迭代，可以用来优化循环内的执行过程；</li>\n</ul>\n<h3 id=\"1-9-函数\"><a href=\"#1-9-函数\" class=\"headerlink\" title=\"1.9 函数\"></a>1.9 函数</h3><h4 id=\"1-9-1-函数声明的提升特性\"><a href=\"#1-9-1-函数声明的提升特性\" class=\"headerlink\" title=\"1.9.1 函数声明的提升特性\"></a>1.9.1 函数声明的提升特性</h4><p>注意与变量声明之间的区别，函数声明 <strong>的实体会被移动到所在作用域的开始处</strong> 。</p>\n<blockquote>\n<p>而变量声明会变成如下的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a; <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a = <span class=\"number\">3</span>; <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>但是要注意函数声明与函数表达式不同，后者只符合变量声明的提升规则。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">// Uncaught ReferenceError: b is not defined. stopped.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-9-2-特殊变量arguments\"><a href=\"#1-9-2-特殊变量arguments\" class=\"headerlink\" title=\"1.9.2 特殊变量arguments\"></a>1.9.2 特殊变量arguments</h4><p>所有参数变量——<code>arguments</code>看起来像一个数组，但是却不具备数组的方法。(Array-like)</p>\n<p>如果想将arguments转换为数组，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.slice.call(arrayLikeObject);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-10-变量作用域\"><a href=\"#1-10-变量作用域\" class=\"headerlink\" title=\"1.10 变量作用域\"></a>1.10 变量作用域</h3><p>一个变量的作用域总是完整的函数。</p>\n<h4 id=\"1-10-1-提升\"><a href=\"#1-10-1-提升\" class=\"headerlink\" title=\"1.10.1 提升\"></a>1.10.1 提升</h4><p>所有变量声明都会被提升，<strong>声明</strong> 会被移动到函数的开始处，而赋值仍然会在原来的位置。通常来说，优先提升<code>var a;</code>，然后再提升<code>function a</code>，然后再赋值。</p>\n<h4 id=\"1-10-2-闭包\"><a href=\"#1-10-2-闭包\" class=\"headerlink\" title=\"1.10.2 闭包\"></a>1.10.2 闭包</h4><blockquote>\n<p>闭包是指有权访问另一个函数作用域中的变量的函数。 —— JS高程(第3版),后文简称高程</p>\n</blockquote>\n<p>一般外层函数内部存在一些变量，然后以返回一个函数的形式完成闭包，最常见的模式即“IIFE”</p>\n<h4 id=\"1-10-3-IIFE\"><a href=\"#1-10-3-IIFE\" class=\"headerlink\" title=\"1.10.3 IIFE\"></a>1.10.3 IIFE</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关于为什么这种写法可以完成IIFE，后续会补充在此。</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> foo = <span class=\"string\">'test'</span></span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>这里要注意闭包有时会存在并 <strong>保持</strong> 与外界变量的联系，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++) &#123;</span><br><span class=\"line\">\tresult.push(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> i; &#125;) <span class=\"comment\">// result[1]()执行后仍然是i = 5赋值的时候</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><em>与对象等有关的点单独总结一章详细说明</em></p>\n"},{"date":"2020-03-02T01:48:00.000Z","title":"\"Speaking JavaScript\"阅读笔记（附加篇）","excerpt":"JavaScript阅读笔记最终篇，一些额外的内容。","thumbnail":"","_content":"_本篇开始将一部分浏览器与Node.js环境相关的知识点补充进来_\n\n### 超时与间歇调用\n\n> JavaScript是单线程语言（后期加入额外线程Worker）\n\n需要注意的是，使用定时器对于队列而言，不是在指定时间立即执行，而是 __在指定时间被加入到队列中__ ，如果队列内没有其他任务，则表现为“立即执行”\n\n如果在浏览器端，需要效果比较好的定时执行，可以通过rAF实现。\n\n### DocumentFragment\n\n使用DocumentFragment优化DOM操作。\n\n### 浏览器的重绘与重排\n\n详见另一篇[文章](https://blog.sparking.app/post?id=fe%252F%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E7%259A%2584%25E9%2587%258D%25E7%25BB%2598-repaint-%25E4%25B8%258E%25E9%2587%258D%25E6%258E%2592-reflow-%25E6%259C%25BA%25E5%2588%25B6 \"重绘与重排\")\n\n### 事件\n\n现在使用MVVM框架多了，减少了直接操作事件，但是还是有必要列出复习的。\n\n#### 1. 事件流\n\n三个阶段：\n\n* 事件捕获\n* 处于目标\n* 事件冒泡\n\n#### 2. DOM2级事件处理程序\n\n* `addEventListener(eventName, fn, needCapture?)`\n* `removeEventListener`\n\nremove操作需要注意，fn不能是一个匿名函数，这时remove才有效。\n\n#### 3. 事件对象\n\nevent对象通常包括以下：\n\n* bubbles\n* cancelable\n* currentTarget\n* defaultPrevented(DOM Level-3)\n* detail\n* eventPhase(处于流的阶段，1-捕获，2-处于目标，3-冒泡)\n* preventDefault() (取消默认行为，注意区分)\n* stopImmediatePropagation() (DOM Level-3)\n* stopPropagation() (取消事件的进一步捕获或冒泡)\n* target\n* trusted\n* type\n* view\n\n#### 4. 事件委托\n\n事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n\n面试题：\n\nQ：用原生JS实现jQuery的on和off效果？\n\nA:\n\n#### 5. 事件模拟\n\n可以用 `document.createEvent` 模拟一些鼠标或者键盘事件，但是需要实机测试，例如Chrome对模拟的点击事件就有比较严格的限制。\n\n#### 6. 拖放事件\n\nHTML5 新增的事件，可以用来作为一些特殊的交互，比如拖放上传等。\n\n#### 7. JSON\n\n注意，以下都是 **合法的** JSON：\n\n* **简单值**\n* 对象\n* 数组\n\n> `JSON.stringify(value[, replacer [, space]])` 可以通过传入第二个参数进行JSON过滤，第二个参数支持数组或者函数。第三个参数不常用，一般用于控制缩进。\n\n### XHR(XMLHttpRequest)\n\n状态值：\n\n* 0，未初始化；\n* 1，启动（已经调用open但是未send）；\n* 2，发送；\n* 3，接收；\n* 4，完成。\n\n#### 1. FormData\n\n表单提交，可以上传文件。\n\n#### 2. Progress事件\n\n用于监测进度，可以用HTML5实现上传进度。\n\n#### 3. 跨域CORS\n\n> 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n> 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。\n\n1. 不会引发CORS的简单请求：\n\n   ![MDN-CORS](https://cdn.sparkling.land/public/blog/images/CORS_simple-request.png)\n2. 需要进行预检（Preflight）的请求：\n\n   ![MDN-CORS](https://cdn.sparkling.land/public/blog/images/CORS_preflight-request.png)\n3. 携带身份凭证（Cookie）：\n\n   ![MDN-CORS](https://cdn.sparkling.land/public/blog/images/CORS_with-credit.png)\n   \n### 高级技巧：节流与防抖\n\n节流：节约流量——无论触发多少次，指定间隔内只能触发一次；\n防抖：防止抖动——中间触发N次都以最后一次开始计算时间，待指定间隔后触发。\n\n### 数据存储\n\n#### 1. Cookie\n\nCookie数量限制不一，在20-50之间，尺寸一般在4096B\n\n#### 2. Storage\n\nlocalStorage一般会设置每个来源5MB，部分浏览器只有2.5MB；\n\nSessionStorage同样一般为5MB，部分浏览器为2.5MB；\n\n#### 3. IndexedDB & WebSQL\n\n浏览器支持情况不定，需要根据具体需求使用。","source":"_posts/fe/speaking-javascript-阅读笔记-附加篇.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-03-02T17:48:00.000+08:00\ntitle: '\"Speaking JavaScript\"阅读笔记（附加篇）'\nexcerpt: JavaScript阅读笔记最终篇，一些额外的内容。\nthumbnail: ''\n\n---\n_本篇开始将一部分浏览器与Node.js环境相关的知识点补充进来_\n\n### 超时与间歇调用\n\n> JavaScript是单线程语言（后期加入额外线程Worker）\n\n需要注意的是，使用定时器对于队列而言，不是在指定时间立即执行，而是 __在指定时间被加入到队列中__ ，如果队列内没有其他任务，则表现为“立即执行”\n\n如果在浏览器端，需要效果比较好的定时执行，可以通过rAF实现。\n\n### DocumentFragment\n\n使用DocumentFragment优化DOM操作。\n\n### 浏览器的重绘与重排\n\n详见另一篇[文章](https://blog.sparking.app/post?id=fe%252F%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E7%259A%2584%25E9%2587%258D%25E7%25BB%2598-repaint-%25E4%25B8%258E%25E9%2587%258D%25E6%258E%2592-reflow-%25E6%259C%25BA%25E5%2588%25B6 \"重绘与重排\")\n\n### 事件\n\n现在使用MVVM框架多了，减少了直接操作事件，但是还是有必要列出复习的。\n\n#### 1. 事件流\n\n三个阶段：\n\n* 事件捕获\n* 处于目标\n* 事件冒泡\n\n#### 2. DOM2级事件处理程序\n\n* `addEventListener(eventName, fn, needCapture?)`\n* `removeEventListener`\n\nremove操作需要注意，fn不能是一个匿名函数，这时remove才有效。\n\n#### 3. 事件对象\n\nevent对象通常包括以下：\n\n* bubbles\n* cancelable\n* currentTarget\n* defaultPrevented(DOM Level-3)\n* detail\n* eventPhase(处于流的阶段，1-捕获，2-处于目标，3-冒泡)\n* preventDefault() (取消默认行为，注意区分)\n* stopImmediatePropagation() (DOM Level-3)\n* stopPropagation() (取消事件的进一步捕获或冒泡)\n* target\n* trusted\n* type\n* view\n\n#### 4. 事件委托\n\n事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n\n面试题：\n\nQ：用原生JS实现jQuery的on和off效果？\n\nA:\n\n#### 5. 事件模拟\n\n可以用 `document.createEvent` 模拟一些鼠标或者键盘事件，但是需要实机测试，例如Chrome对模拟的点击事件就有比较严格的限制。\n\n#### 6. 拖放事件\n\nHTML5 新增的事件，可以用来作为一些特殊的交互，比如拖放上传等。\n\n#### 7. JSON\n\n注意，以下都是 **合法的** JSON：\n\n* **简单值**\n* 对象\n* 数组\n\n> `JSON.stringify(value[, replacer [, space]])` 可以通过传入第二个参数进行JSON过滤，第二个参数支持数组或者函数。第三个参数不常用，一般用于控制缩进。\n\n### XHR(XMLHttpRequest)\n\n状态值：\n\n* 0，未初始化；\n* 1，启动（已经调用open但是未send）；\n* 2，发送；\n* 3，接收；\n* 4，完成。\n\n#### 1. FormData\n\n表单提交，可以上传文件。\n\n#### 2. Progress事件\n\n用于监测进度，可以用HTML5实现上传进度。\n\n#### 3. 跨域CORS\n\n> 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n\n> 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。\n\n1. 不会引发CORS的简单请求：\n\n   ![MDN-CORS](https://cdn.sparkling.land/public/blog/images/CORS_simple-request.png)\n2. 需要进行预检（Preflight）的请求：\n\n   ![MDN-CORS](https://cdn.sparkling.land/public/blog/images/CORS_preflight-request.png)\n3. 携带身份凭证（Cookie）：\n\n   ![MDN-CORS](https://cdn.sparkling.land/public/blog/images/CORS_with-credit.png)\n   \n### 高级技巧：节流与防抖\n\n节流：节约流量——无论触发多少次，指定间隔内只能触发一次；\n防抖：防止抖动——中间触发N次都以最后一次开始计算时间，待指定间隔后触发。\n\n### 数据存储\n\n#### 1. Cookie\n\nCookie数量限制不一，在20-50之间，尺寸一般在4096B\n\n#### 2. Storage\n\nlocalStorage一般会设置每个来源5MB，部分浏览器只有2.5MB；\n\nSessionStorage同样一般为5MB，部分浏览器为2.5MB；\n\n#### 3. IndexedDB & WebSQL\n\n浏览器支持情况不定，需要根据具体需求使用。","slug":"fe/speaking-javascript-阅读笔记-附加篇","published":1,"updated":"2020-08-01T18:21:52.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ial0011j1wt6aws70y1","content":"<p><em>本篇开始将一部分浏览器与Node.js环境相关的知识点补充进来</em></p>\n<h3 id=\"超时与间歇调用\"><a href=\"#超时与间歇调用\" class=\"headerlink\" title=\"超时与间歇调用\"></a>超时与间歇调用</h3><blockquote>\n<p>JavaScript是单线程语言（后期加入额外线程Worker）</p>\n</blockquote>\n<p>需要注意的是，使用定时器对于队列而言，不是在指定时间立即执行，而是 <strong>在指定时间被加入到队列中</strong> ，如果队列内没有其他任务，则表现为“立即执行”</p>\n<p>如果在浏览器端，需要效果比较好的定时执行，可以通过rAF实现。</p>\n<h3 id=\"DocumentFragment\"><a href=\"#DocumentFragment\" class=\"headerlink\" title=\"DocumentFragment\"></a>DocumentFragment</h3><p>使用DocumentFragment优化DOM操作。</p>\n<h3 id=\"浏览器的重绘与重排\"><a href=\"#浏览器的重绘与重排\" class=\"headerlink\" title=\"浏览器的重绘与重排\"></a>浏览器的重绘与重排</h3><p>详见另一篇<a href=\"https://blog.sparking.app/post?id=fe%252F%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E7%259A%2584%25E9%2587%258D%25E7%25BB%2598-repaint-%25E4%25B8%258E%25E9%2587%258D%25E6%258E%2592-reflow-%25E6%259C%25BA%25E5%2588%25B6\" title=\"重绘与重排\">文章</a></p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>现在使用MVVM框架多了，减少了直接操作事件，但是还是有必要列出复习的。</p>\n<h4 id=\"1-事件流\"><a href=\"#1-事件流\" class=\"headerlink\" title=\"1. 事件流\"></a>1. 事件流</h4><p>三个阶段：</p>\n<ul>\n<li>事件捕获</li>\n<li>处于目标</li>\n<li>事件冒泡</li>\n</ul>\n<h4 id=\"2-DOM2级事件处理程序\"><a href=\"#2-DOM2级事件处理程序\" class=\"headerlink\" title=\"2. DOM2级事件处理程序\"></a>2. DOM2级事件处理程序</h4><ul>\n<li><code>addEventListener(eventName, fn, needCapture?)</code></li>\n<li><code>removeEventListener</code></li>\n</ul>\n<p>remove操作需要注意，fn不能是一个匿名函数，这时remove才有效。</p>\n<h4 id=\"3-事件对象\"><a href=\"#3-事件对象\" class=\"headerlink\" title=\"3. 事件对象\"></a>3. 事件对象</h4><p>event对象通常包括以下：</p>\n<ul>\n<li>bubbles</li>\n<li>cancelable</li>\n<li>currentTarget</li>\n<li>defaultPrevented(DOM Level-3)</li>\n<li>detail</li>\n<li>eventPhase(处于流的阶段，1-捕获，2-处于目标，3-冒泡)</li>\n<li>preventDefault() (取消默认行为，注意区分)</li>\n<li>stopImmediatePropagation() (DOM Level-3)</li>\n<li>stopPropagation() (取消事件的进一步捕获或冒泡)</li>\n<li>target</li>\n<li>trusted</li>\n<li>type</li>\n<li>view</li>\n</ul>\n<h4 id=\"4-事件委托\"><a href=\"#4-事件委托\" class=\"headerlink\" title=\"4. 事件委托\"></a>4. 事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>\n<p>面试题：</p>\n<p>Q：用原生JS实现jQuery的on和off效果？</p>\n<p>A:</p>\n<h4 id=\"5-事件模拟\"><a href=\"#5-事件模拟\" class=\"headerlink\" title=\"5. 事件模拟\"></a>5. 事件模拟</h4><p>可以用 <code>document.createEvent</code> 模拟一些鼠标或者键盘事件，但是需要实机测试，例如Chrome对模拟的点击事件就有比较严格的限制。</p>\n<h4 id=\"6-拖放事件\"><a href=\"#6-拖放事件\" class=\"headerlink\" title=\"6. 拖放事件\"></a>6. 拖放事件</h4><p>HTML5 新增的事件，可以用来作为一些特殊的交互，比如拖放上传等。</p>\n<h4 id=\"7-JSON\"><a href=\"#7-JSON\" class=\"headerlink\" title=\"7. JSON\"></a>7. JSON</h4><p>注意，以下都是 <strong>合法的</strong> JSON：</p>\n<ul>\n<li><strong>简单值</strong></li>\n<li>对象</li>\n<li>数组</li>\n</ul>\n<blockquote>\n<p><code>JSON.stringify(value[, replacer [, space]])</code> 可以通过传入第二个参数进行JSON过滤，第二个参数支持数组或者函数。第三个参数不常用，一般用于控制缩进。</p>\n</blockquote>\n<h3 id=\"XHR-XMLHttpRequest\"><a href=\"#XHR-XMLHttpRequest\" class=\"headerlink\" title=\"XHR(XMLHttpRequest)\"></a>XHR(XMLHttpRequest)</h3><p>状态值：</p>\n<ul>\n<li>0，未初始化；</li>\n<li>1，启动（已经调用open但是未send）；</li>\n<li>2，发送；</li>\n<li>3，接收；</li>\n<li>4，完成。</li>\n</ul>\n<h4 id=\"1-FormData\"><a href=\"#1-FormData\" class=\"headerlink\" title=\"1. FormData\"></a>1. FormData</h4><p>表单提交，可以上传文件。</p>\n<h4 id=\"2-Progress事件\"><a href=\"#2-Progress事件\" class=\"headerlink\" title=\"2. Progress事件\"></a>2. Progress事件</h4><p>用于监测进度，可以用HTML5实现上传进度。</p>\n<h4 id=\"3-跨域CORS\"><a href=\"#3-跨域CORS\" class=\"headerlink\" title=\"3. 跨域CORS\"></a>3. 跨域CORS</h4><blockquote>\n<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n</blockquote>\n<blockquote>\n<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。</p>\n</blockquote>\n<ol>\n<li><p>不会引发CORS的简单请求：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/CORS_simple-request.png\" alt=\"MDN-CORS\"></p>\n</li>\n<li><p>需要进行预检（Preflight）的请求：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/CORS_preflight-request.png\" alt=\"MDN-CORS\"></p>\n</li>\n<li><p>携带身份凭证（Cookie）：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/CORS_with-credit.png\" alt=\"MDN-CORS\"></p>\n</li>\n</ol>\n<h3 id=\"高级技巧：节流与防抖\"><a href=\"#高级技巧：节流与防抖\" class=\"headerlink\" title=\"高级技巧：节流与防抖\"></a>高级技巧：节流与防抖</h3><p>节流：节约流量——无论触发多少次，指定间隔内只能触发一次；<br>防抖：防止抖动——中间触发N次都以最后一次开始计算时间，待指定间隔后触发。</p>\n<h3 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h3><h4 id=\"1-Cookie\"><a href=\"#1-Cookie\" class=\"headerlink\" title=\"1. Cookie\"></a>1. Cookie</h4><p>Cookie数量限制不一，在20-50之间，尺寸一般在4096B</p>\n<h4 id=\"2-Storage\"><a href=\"#2-Storage\" class=\"headerlink\" title=\"2. Storage\"></a>2. Storage</h4><p>localStorage一般会设置每个来源5MB，部分浏览器只有2.5MB；</p>\n<p>SessionStorage同样一般为5MB，部分浏览器为2.5MB；</p>\n<h4 id=\"3-IndexedDB-amp-WebSQL\"><a href=\"#3-IndexedDB-amp-WebSQL\" class=\"headerlink\" title=\"3. IndexedDB &amp; WebSQL\"></a>3. IndexedDB &amp; WebSQL</h4><p>浏览器支持情况不定，需要根据具体需求使用。</p>\n","site":{"data":{}},"more":"<p><em>本篇开始将一部分浏览器与Node.js环境相关的知识点补充进来</em></p>\n<h3 id=\"超时与间歇调用\"><a href=\"#超时与间歇调用\" class=\"headerlink\" title=\"超时与间歇调用\"></a>超时与间歇调用</h3><blockquote>\n<p>JavaScript是单线程语言（后期加入额外线程Worker）</p>\n</blockquote>\n<p>需要注意的是，使用定时器对于队列而言，不是在指定时间立即执行，而是 <strong>在指定时间被加入到队列中</strong> ，如果队列内没有其他任务，则表现为“立即执行”</p>\n<p>如果在浏览器端，需要效果比较好的定时执行，可以通过rAF实现。</p>\n<h3 id=\"DocumentFragment\"><a href=\"#DocumentFragment\" class=\"headerlink\" title=\"DocumentFragment\"></a>DocumentFragment</h3><p>使用DocumentFragment优化DOM操作。</p>\n<h3 id=\"浏览器的重绘与重排\"><a href=\"#浏览器的重绘与重排\" class=\"headerlink\" title=\"浏览器的重绘与重排\"></a>浏览器的重绘与重排</h3><p>详见另一篇<a href=\"https://blog.sparking.app/post?id=fe%252F%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E7%259A%2584%25E9%2587%258D%25E7%25BB%2598-repaint-%25E4%25B8%258E%25E9%2587%258D%25E6%258E%2592-reflow-%25E6%259C%25BA%25E5%2588%25B6\" title=\"重绘与重排\">文章</a></p>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>现在使用MVVM框架多了，减少了直接操作事件，但是还是有必要列出复习的。</p>\n<h4 id=\"1-事件流\"><a href=\"#1-事件流\" class=\"headerlink\" title=\"1. 事件流\"></a>1. 事件流</h4><p>三个阶段：</p>\n<ul>\n<li>事件捕获</li>\n<li>处于目标</li>\n<li>事件冒泡</li>\n</ul>\n<h4 id=\"2-DOM2级事件处理程序\"><a href=\"#2-DOM2级事件处理程序\" class=\"headerlink\" title=\"2. DOM2级事件处理程序\"></a>2. DOM2级事件处理程序</h4><ul>\n<li><code>addEventListener(eventName, fn, needCapture?)</code></li>\n<li><code>removeEventListener</code></li>\n</ul>\n<p>remove操作需要注意，fn不能是一个匿名函数，这时remove才有效。</p>\n<h4 id=\"3-事件对象\"><a href=\"#3-事件对象\" class=\"headerlink\" title=\"3. 事件对象\"></a>3. 事件对象</h4><p>event对象通常包括以下：</p>\n<ul>\n<li>bubbles</li>\n<li>cancelable</li>\n<li>currentTarget</li>\n<li>defaultPrevented(DOM Level-3)</li>\n<li>detail</li>\n<li>eventPhase(处于流的阶段，1-捕获，2-处于目标，3-冒泡)</li>\n<li>preventDefault() (取消默认行为，注意区分)</li>\n<li>stopImmediatePropagation() (DOM Level-3)</li>\n<li>stopPropagation() (取消事件的进一步捕获或冒泡)</li>\n<li>target</li>\n<li>trusted</li>\n<li>type</li>\n<li>view</li>\n</ul>\n<h4 id=\"4-事件委托\"><a href=\"#4-事件委托\" class=\"headerlink\" title=\"4. 事件委托\"></a>4. 事件委托</h4><p>事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>\n<p>面试题：</p>\n<p>Q：用原生JS实现jQuery的on和off效果？</p>\n<p>A:</p>\n<h4 id=\"5-事件模拟\"><a href=\"#5-事件模拟\" class=\"headerlink\" title=\"5. 事件模拟\"></a>5. 事件模拟</h4><p>可以用 <code>document.createEvent</code> 模拟一些鼠标或者键盘事件，但是需要实机测试，例如Chrome对模拟的点击事件就有比较严格的限制。</p>\n<h4 id=\"6-拖放事件\"><a href=\"#6-拖放事件\" class=\"headerlink\" title=\"6. 拖放事件\"></a>6. 拖放事件</h4><p>HTML5 新增的事件，可以用来作为一些特殊的交互，比如拖放上传等。</p>\n<h4 id=\"7-JSON\"><a href=\"#7-JSON\" class=\"headerlink\" title=\"7. JSON\"></a>7. JSON</h4><p>注意，以下都是 <strong>合法的</strong> JSON：</p>\n<ul>\n<li><strong>简单值</strong></li>\n<li>对象</li>\n<li>数组</li>\n</ul>\n<blockquote>\n<p><code>JSON.stringify(value[, replacer [, space]])</code> 可以通过传入第二个参数进行JSON过滤，第二个参数支持数组或者函数。第三个参数不常用，一般用于控制缩进。</p>\n</blockquote>\n<h3 id=\"XHR-XMLHttpRequest\"><a href=\"#XHR-XMLHttpRequest\" class=\"headerlink\" title=\"XHR(XMLHttpRequest)\"></a>XHR(XMLHttpRequest)</h3><p>状态值：</p>\n<ul>\n<li>0，未初始化；</li>\n<li>1，启动（已经调用open但是未send）；</li>\n<li>2，发送；</li>\n<li>3，接收；</li>\n<li>4，完成。</li>\n</ul>\n<h4 id=\"1-FormData\"><a href=\"#1-FormData\" class=\"headerlink\" title=\"1. FormData\"></a>1. FormData</h4><p>表单提交，可以上传文件。</p>\n<h4 id=\"2-Progress事件\"><a href=\"#2-Progress事件\" class=\"headerlink\" title=\"2. Progress事件\"></a>2. Progress事件</h4><p>用于监测进度，可以用HTML5实现上传进度。</p>\n<h4 id=\"3-跨域CORS\"><a href=\"#3-跨域CORS\" class=\"headerlink\" title=\"3. 跨域CORS\"></a>3. 跨域CORS</h4><blockquote>\n<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p>\n</blockquote>\n<blockquote>\n<p>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。</p>\n</blockquote>\n<ol>\n<li><p>不会引发CORS的简单请求：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/CORS_simple-request.png\" alt=\"MDN-CORS\"></p>\n</li>\n<li><p>需要进行预检（Preflight）的请求：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/CORS_preflight-request.png\" alt=\"MDN-CORS\"></p>\n</li>\n<li><p>携带身份凭证（Cookie）：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/CORS_with-credit.png\" alt=\"MDN-CORS\"></p>\n</li>\n</ol>\n<h3 id=\"高级技巧：节流与防抖\"><a href=\"#高级技巧：节流与防抖\" class=\"headerlink\" title=\"高级技巧：节流与防抖\"></a>高级技巧：节流与防抖</h3><p>节流：节约流量——无论触发多少次，指定间隔内只能触发一次；<br>防抖：防止抖动——中间触发N次都以最后一次开始计算时间，待指定间隔后触发。</p>\n<h3 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h3><h4 id=\"1-Cookie\"><a href=\"#1-Cookie\" class=\"headerlink\" title=\"1. Cookie\"></a>1. Cookie</h4><p>Cookie数量限制不一，在20-50之间，尺寸一般在4096B</p>\n<h4 id=\"2-Storage\"><a href=\"#2-Storage\" class=\"headerlink\" title=\"2. Storage\"></a>2. Storage</h4><p>localStorage一般会设置每个来源5MB，部分浏览器只有2.5MB；</p>\n<p>SessionStorage同样一般为5MB，部分浏览器为2.5MB；</p>\n<h4 id=\"3-IndexedDB-amp-WebSQL\"><a href=\"#3-IndexedDB-amp-WebSQL\" class=\"headerlink\" title=\"3. IndexedDB &amp; WebSQL\"></a>3. IndexedDB &amp; WebSQL</h4><p>浏览器支持情况不定，需要根据具体需求使用。</p>\n"},{"date":"2020-04-21T06:27:05.000Z","title":"\"Vue 3.0 Beta\"B站直播内容速记","excerpt":"通过B站直播，整体的重新了解了Vue3的概况，虽然一年内可能不会常用，但还是尽量了解尤大的开发思想，便于后续快速升级。","thumbnail":"","_content":"## 直播内容\n\n> 直播使用的PPT[Google文档地址, 需要科学上网](https://docs.google.com/presentation/d/1LHp-8hEtXEMSE1fd6YLAhYmtndQelQKbWlGggZKe4y8/edit#slide=id.g31e95ee831_0_92)\n\n- 3.0 Beta特性介绍\n\t- 性能表现\n    - “摇树”支持\n    - Composition API\n    - Fragment, Teleport, Suspense\n    - 更好的TypeScript支持\n    - 自定义Render\n- 何时才能使用Vue 3.0（生态进度）\n    \n## 性能表现\n\n### 重写V-dom实现\n\n> 本节内容结合 [_vue-next-template-explorer.netlify.app_](https://vue-next-template-explorer.netlify.app/) 食用更佳。\n\n2.0版本的的v-dom实现参考了[snabbdom](https://github.com/snabbdom/snabbdom)，加入了一部分Vue相关的特性属性如Static标记等。3.0大幅度修改了其实现，并对标记等进行了优化。\n\n### Compiler-informed fast paths（个人理解：更快的编译/render路径）\n\n> 本节内容结合 [_vue-next-template-explorer.netlify.app_](https://vue-next-template-explorer.netlify.app/) 食用更佳。\n\n这一部分主要体现在最终的render函数上，利用上述工具，我们发现静态节点标记以及属性（绑定）被归为不同的部分，其中静态节点甚至可以通过开启提升来进行复用，未绑定的属性与进行了绑定的也可以直接标记出来，减少了对比与diff压力，从而得到更快的速度。\n\n### 更高效的组件初始化\n\n### 更新性能提高1.3～2倍\n\n> 参考（下同）：based on benchmarks that simulates typical scenarios, may vary based on actual application.\n\n### 2～3倍更快的SSR（服务端渲染）\n\nSSR下，可以将静态节点作为Buffer的一部分直接推入最终的请求返回中，从而获得更快的速度。\n\n## “摇树”Tree-shaking\n\n> 本节内容结合 [_vue-next-template-explorer.netlify.app_](https://vue-next-template-explorer.netlify.app/) 食用更佳。\n\n### 大部分可选特性目前可被“摇树”\n\n在“next-template-explorer”中，如果你使用了例如v-on或者v-model等选项，可以在右侧清楚的发现对应选项通过摇树的方式单独打包进入最终的代码，相比于2.x版本需要包含完整runtime而言是非常大的优化。\n\n### 最基本的HelloWorld示例打包大小约为13.5kb\n\n> 如果选择只包含Composition API支持的模式，打包体积可以减小至11.75kb。\n\n### 包含所有Runtime的打包体积约为22.5kb\n\n## Fragment, Teleport, Suspense\n\n### Fragment\n\n碎片的概念有些类似于[React的Fragment概念](https://zh-hans.reactjs.org/docs/fragments.html)，Vue 3版本支持更多的使用方式，比如可以只有字符串，或者利用数组构成一段Fragment。\n\n### Teleport(有译为：占位传递组件）\n\nTeleport与[React的Portals概念](https://zh-hans.reactjs.org/docs/portals.html)类似。\n\n> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\n\n> 尤大在直播中提到，为何没有直接使用Portal来命名还有另外一个原因：Chrome的iframe“替代方案”——[Portal](https://www.chromestatus.com/feature/4828882419056640)\n\nTeleport功能可以用来将部分组件代码传递到DOM树的其他位置，可以在很多场景下使用，比如窗口resize等，简单说明：\n\n```javascript\n<!-- In some nested Vue component -->\n<NestedComponent>\n  <v-fragment target=\"#popup-target\">\n    <PopUp />\n  </v-fragment>\n</NestedComponent>\n<!-- before closing body tag -->\n<div id=\"popup-target\"></div>\n```\n\n### Suspense\n\n同样的，其对应了[React的Suspense概念](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html)，要注意的是，__当前Suspense特性在React中同样也是试验性功能，暂时不适合投入生产环境__ 。\n\nReact社区中有一些第三方库对其进行了实现，比如zeit.co推出的[swr库](https://github.com/zeit/swr)，主要是用于作为等待与实现异步，Suspense部分会进行等待，直到异步任务完成继续，非常适合用来实现loading态。\n\n## 何时才能使用Vue 3.0（生态进度）\n\n> 建议随时参考官方的[Vue-next仓库](https://github.com/vuejs/vue-next)，了解生态各部分的开发进展。\n\n目前Vue 3.0已经进入了Beta版本，预计年中会推出可以投入生产的版本。\n\n- Vue Router：已知会 __有部分API改动__ ，目前alpha阶段；\n- Vuex：目前已知没有API改动，同样处于alpha阶段；\n- Vetur：其作者预计在五月份会进行跟进开发工作；\n- Nuxt：目前已经实现了demo版本，正在跟进中；\n- vue-cli：目前实验性支持；\n\n需要注意的是，Vue 3.0 __beta目前不支持IE11__，在未来会推出针对IE11的专用build，如果需要兼容则需要开启对应的开关，会在最终打包时加入部分的fallback策略。\n\n## 2.x版本的未来\n\n2.x版本会在3.0稳定后推出一个Minor版本，之后会进入为期18个月的LTS，LTS过后只进行安全修复不会做版本更新。这个版本会包括部分2.x版本可兼容的3.0新特性。","source":"_posts/fe/vue-3-0-beta-b站直播内容速记.md","raw":"---\ncategories: Frontend\ntags:\n- Vue.js\ndate: 2020-04-21T22:27:05.000+08:00\ntitle: '\"Vue 3.0 Beta\"B站直播内容速记'\nexcerpt: 通过B站直播，整体的重新了解了Vue3的概况，虽然一年内可能不会常用，但还是尽量了解尤大的开发思想，便于后续快速升级。\nthumbnail: ''\n\n---\n## 直播内容\n\n> 直播使用的PPT[Google文档地址, 需要科学上网](https://docs.google.com/presentation/d/1LHp-8hEtXEMSE1fd6YLAhYmtndQelQKbWlGggZKe4y8/edit#slide=id.g31e95ee831_0_92)\n\n- 3.0 Beta特性介绍\n\t- 性能表现\n    - “摇树”支持\n    - Composition API\n    - Fragment, Teleport, Suspense\n    - 更好的TypeScript支持\n    - 自定义Render\n- 何时才能使用Vue 3.0（生态进度）\n    \n## 性能表现\n\n### 重写V-dom实现\n\n> 本节内容结合 [_vue-next-template-explorer.netlify.app_](https://vue-next-template-explorer.netlify.app/) 食用更佳。\n\n2.0版本的的v-dom实现参考了[snabbdom](https://github.com/snabbdom/snabbdom)，加入了一部分Vue相关的特性属性如Static标记等。3.0大幅度修改了其实现，并对标记等进行了优化。\n\n### Compiler-informed fast paths（个人理解：更快的编译/render路径）\n\n> 本节内容结合 [_vue-next-template-explorer.netlify.app_](https://vue-next-template-explorer.netlify.app/) 食用更佳。\n\n这一部分主要体现在最终的render函数上，利用上述工具，我们发现静态节点标记以及属性（绑定）被归为不同的部分，其中静态节点甚至可以通过开启提升来进行复用，未绑定的属性与进行了绑定的也可以直接标记出来，减少了对比与diff压力，从而得到更快的速度。\n\n### 更高效的组件初始化\n\n### 更新性能提高1.3～2倍\n\n> 参考（下同）：based on benchmarks that simulates typical scenarios, may vary based on actual application.\n\n### 2～3倍更快的SSR（服务端渲染）\n\nSSR下，可以将静态节点作为Buffer的一部分直接推入最终的请求返回中，从而获得更快的速度。\n\n## “摇树”Tree-shaking\n\n> 本节内容结合 [_vue-next-template-explorer.netlify.app_](https://vue-next-template-explorer.netlify.app/) 食用更佳。\n\n### 大部分可选特性目前可被“摇树”\n\n在“next-template-explorer”中，如果你使用了例如v-on或者v-model等选项，可以在右侧清楚的发现对应选项通过摇树的方式单独打包进入最终的代码，相比于2.x版本需要包含完整runtime而言是非常大的优化。\n\n### 最基本的HelloWorld示例打包大小约为13.5kb\n\n> 如果选择只包含Composition API支持的模式，打包体积可以减小至11.75kb。\n\n### 包含所有Runtime的打包体积约为22.5kb\n\n## Fragment, Teleport, Suspense\n\n### Fragment\n\n碎片的概念有些类似于[React的Fragment概念](https://zh-hans.reactjs.org/docs/fragments.html)，Vue 3版本支持更多的使用方式，比如可以只有字符串，或者利用数组构成一段Fragment。\n\n### Teleport(有译为：占位传递组件）\n\nTeleport与[React的Portals概念](https://zh-hans.reactjs.org/docs/portals.html)类似。\n\n> Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。\n\n> 尤大在直播中提到，为何没有直接使用Portal来命名还有另外一个原因：Chrome的iframe“替代方案”——[Portal](https://www.chromestatus.com/feature/4828882419056640)\n\nTeleport功能可以用来将部分组件代码传递到DOM树的其他位置，可以在很多场景下使用，比如窗口resize等，简单说明：\n\n```javascript\n<!-- In some nested Vue component -->\n<NestedComponent>\n  <v-fragment target=\"#popup-target\">\n    <PopUp />\n  </v-fragment>\n</NestedComponent>\n<!-- before closing body tag -->\n<div id=\"popup-target\"></div>\n```\n\n### Suspense\n\n同样的，其对应了[React的Suspense概念](https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html)，要注意的是，__当前Suspense特性在React中同样也是试验性功能，暂时不适合投入生产环境__ 。\n\nReact社区中有一些第三方库对其进行了实现，比如zeit.co推出的[swr库](https://github.com/zeit/swr)，主要是用于作为等待与实现异步，Suspense部分会进行等待，直到异步任务完成继续，非常适合用来实现loading态。\n\n## 何时才能使用Vue 3.0（生态进度）\n\n> 建议随时参考官方的[Vue-next仓库](https://github.com/vuejs/vue-next)，了解生态各部分的开发进展。\n\n目前Vue 3.0已经进入了Beta版本，预计年中会推出可以投入生产的版本。\n\n- Vue Router：已知会 __有部分API改动__ ，目前alpha阶段；\n- Vuex：目前已知没有API改动，同样处于alpha阶段；\n- Vetur：其作者预计在五月份会进行跟进开发工作；\n- Nuxt：目前已经实现了demo版本，正在跟进中；\n- vue-cli：目前实验性支持；\n\n需要注意的是，Vue 3.0 __beta目前不支持IE11__，在未来会推出针对IE11的专用build，如果需要兼容则需要开启对应的开关，会在最终打包时加入部分的fallback策略。\n\n## 2.x版本的未来\n\n2.x版本会在3.0稳定后推出一个Minor版本，之后会进入为期18个月的LTS，LTS过后只进行安全修复不会做版本更新。这个版本会包括部分2.x版本可兼容的3.0新特性。","slug":"fe/vue-3-0-beta-b站直播内容速记","published":1,"updated":"2020-08-01T18:21:52.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iam0013j1wtb1780le9","content":"<h2 id=\"直播内容\"><a href=\"#直播内容\" class=\"headerlink\" title=\"直播内容\"></a>直播内容</h2><blockquote>\n<p>直播使用的PPT<a href=\"https://docs.google.com/presentation/d/1LHp-8hEtXEMSE1fd6YLAhYmtndQelQKbWlGggZKe4y8/edit#slide=id.g31e95ee831_0_92\">Google文档地址, 需要科学上网</a></p>\n</blockquote>\n<ul>\n<li>3.0 Beta特性介绍<ul>\n<li>性能表现</li>\n<li>“摇树”支持</li>\n<li>Composition API</li>\n<li>Fragment, Teleport, Suspense</li>\n<li>更好的TypeScript支持</li>\n<li>自定义Render</li>\n</ul>\n</li>\n<li>何时才能使用Vue 3.0（生态进度）</li>\n</ul>\n<h2 id=\"性能表现\"><a href=\"#性能表现\" class=\"headerlink\" title=\"性能表现\"></a>性能表现</h2><h3 id=\"重写V-dom实现\"><a href=\"#重写V-dom实现\" class=\"headerlink\" title=\"重写V-dom实现\"></a>重写V-dom实现</h3><blockquote>\n<p>本节内容结合 <a href=\"https://vue-next-template-explorer.netlify.app/\"><em>vue-next-template-explorer.netlify.app</em></a> 食用更佳。</p>\n</blockquote>\n<p>2.0版本的的v-dom实现参考了<a href=\"https://github.com/snabbdom/snabbdom\">snabbdom</a>，加入了一部分Vue相关的特性属性如Static标记等。3.0大幅度修改了其实现，并对标记等进行了优化。</p>\n<h3 id=\"Compiler-informed-fast-paths（个人理解：更快的编译-render路径）\"><a href=\"#Compiler-informed-fast-paths（个人理解：更快的编译-render路径）\" class=\"headerlink\" title=\"Compiler-informed fast paths（个人理解：更快的编译/render路径）\"></a>Compiler-informed fast paths（个人理解：更快的编译/render路径）</h3><blockquote>\n<p>本节内容结合 <a href=\"https://vue-next-template-explorer.netlify.app/\"><em>vue-next-template-explorer.netlify.app</em></a> 食用更佳。</p>\n</blockquote>\n<p>这一部分主要体现在最终的render函数上，利用上述工具，我们发现静态节点标记以及属性（绑定）被归为不同的部分，其中静态节点甚至可以通过开启提升来进行复用，未绑定的属性与进行了绑定的也可以直接标记出来，减少了对比与diff压力，从而得到更快的速度。</p>\n<h3 id=\"更高效的组件初始化\"><a href=\"#更高效的组件初始化\" class=\"headerlink\" title=\"更高效的组件初始化\"></a>更高效的组件初始化</h3><h3 id=\"更新性能提高1-3～2倍\"><a href=\"#更新性能提高1-3～2倍\" class=\"headerlink\" title=\"更新性能提高1.3～2倍\"></a>更新性能提高1.3～2倍</h3><blockquote>\n<p>参考（下同）：based on benchmarks that simulates typical scenarios, may vary based on actual application.</p>\n</blockquote>\n<h3 id=\"2～3倍更快的SSR（服务端渲染）\"><a href=\"#2～3倍更快的SSR（服务端渲染）\" class=\"headerlink\" title=\"2～3倍更快的SSR（服务端渲染）\"></a>2～3倍更快的SSR（服务端渲染）</h3><p>SSR下，可以将静态节点作为Buffer的一部分直接推入最终的请求返回中，从而获得更快的速度。</p>\n<h2 id=\"“摇树”Tree-shaking\"><a href=\"#“摇树”Tree-shaking\" class=\"headerlink\" title=\"“摇树”Tree-shaking\"></a>“摇树”Tree-shaking</h2><blockquote>\n<p>本节内容结合 <a href=\"https://vue-next-template-explorer.netlify.app/\"><em>vue-next-template-explorer.netlify.app</em></a> 食用更佳。</p>\n</blockquote>\n<h3 id=\"大部分可选特性目前可被“摇树”\"><a href=\"#大部分可选特性目前可被“摇树”\" class=\"headerlink\" title=\"大部分可选特性目前可被“摇树”\"></a>大部分可选特性目前可被“摇树”</h3><p>在“next-template-explorer”中，如果你使用了例如v-on或者v-model等选项，可以在右侧清楚的发现对应选项通过摇树的方式单独打包进入最终的代码，相比于2.x版本需要包含完整runtime而言是非常大的优化。</p>\n<h3 id=\"最基本的HelloWorld示例打包大小约为13-5kb\"><a href=\"#最基本的HelloWorld示例打包大小约为13-5kb\" class=\"headerlink\" title=\"最基本的HelloWorld示例打包大小约为13.5kb\"></a>最基本的HelloWorld示例打包大小约为13.5kb</h3><blockquote>\n<p>如果选择只包含Composition API支持的模式，打包体积可以减小至11.75kb。</p>\n</blockquote>\n<h3 id=\"包含所有Runtime的打包体积约为22-5kb\"><a href=\"#包含所有Runtime的打包体积约为22-5kb\" class=\"headerlink\" title=\"包含所有Runtime的打包体积约为22.5kb\"></a>包含所有Runtime的打包体积约为22.5kb</h3><h2 id=\"Fragment-Teleport-Suspense\"><a href=\"#Fragment-Teleport-Suspense\" class=\"headerlink\" title=\"Fragment, Teleport, Suspense\"></a>Fragment, Teleport, Suspense</h2><h3 id=\"Fragment\"><a href=\"#Fragment\" class=\"headerlink\" title=\"Fragment\"></a>Fragment</h3><p>碎片的概念有些类似于<a href=\"https://zh-hans.reactjs.org/docs/fragments.html\">React的Fragment概念</a>，Vue 3版本支持更多的使用方式，比如可以只有字符串，或者利用数组构成一段Fragment。</p>\n<h3 id=\"Teleport-有译为：占位传递组件）\"><a href=\"#Teleport-有译为：占位传递组件）\" class=\"headerlink\" title=\"Teleport(有译为：占位传递组件）\"></a>Teleport(有译为：占位传递组件）</h3><p>Teleport与<a href=\"https://zh-hans.reactjs.org/docs/portals.html\">React的Portals概念</a>类似。</p>\n<blockquote>\n<p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>\n</blockquote>\n<blockquote>\n<p>尤大在直播中提到，为何没有直接使用Portal来命名还有另外一个原因：Chrome的iframe“替代方案”——<a href=\"https://www.chromestatus.com/feature/4828882419056640\">Portal</a></p>\n</blockquote>\n<p>Teleport功能可以用来将部分组件代码传递到DOM树的其他位置，可以在很多场景下使用，比如窗口resize等，简单说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- In some nested Vue component --&gt;</span><br><span class=\"line\">&lt;NestedComponent&gt;</span><br><span class=\"line\">  &lt;v-fragment target=<span class=\"string\">\"#popup-target\"</span>&gt;</span><br><span class=\"line\">    &lt;PopUp /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/v-fragment&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>NestedComponent&gt;</span><br><span class=\"line\">&lt;!-- before closing body tag --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"popup-target\"</span>&gt;&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Suspense\"><a href=\"#Suspense\" class=\"headerlink\" title=\"Suspense\"></a>Suspense</h3><p>同样的，其对应了<a href=\"https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html\">React的Suspense概念</a>，要注意的是，<strong>当前Suspense特性在React中同样也是试验性功能，暂时不适合投入生产环境</strong> 。</p>\n<p>React社区中有一些第三方库对其进行了实现，比如zeit.co推出的<a href=\"https://github.com/zeit/swr\">swr库</a>，主要是用于作为等待与实现异步，Suspense部分会进行等待，直到异步任务完成继续，非常适合用来实现loading态。</p>\n<h2 id=\"何时才能使用Vue-3-0（生态进度）\"><a href=\"#何时才能使用Vue-3-0（生态进度）\" class=\"headerlink\" title=\"何时才能使用Vue 3.0（生态进度）\"></a>何时才能使用Vue 3.0（生态进度）</h2><blockquote>\n<p>建议随时参考官方的<a href=\"https://github.com/vuejs/vue-next\">Vue-next仓库</a>，了解生态各部分的开发进展。</p>\n</blockquote>\n<p>目前Vue 3.0已经进入了Beta版本，预计年中会推出可以投入生产的版本。</p>\n<ul>\n<li>Vue Router：已知会 <strong>有部分API改动</strong> ，目前alpha阶段；</li>\n<li>Vuex：目前已知没有API改动，同样处于alpha阶段；</li>\n<li>Vetur：其作者预计在五月份会进行跟进开发工作；</li>\n<li>Nuxt：目前已经实现了demo版本，正在跟进中；</li>\n<li>vue-cli：目前实验性支持；</li>\n</ul>\n<p>需要注意的是，Vue 3.0 __beta目前不支持IE11__，在未来会推出针对IE11的专用build，如果需要兼容则需要开启对应的开关，会在最终打包时加入部分的fallback策略。</p>\n<h2 id=\"2-x版本的未来\"><a href=\"#2-x版本的未来\" class=\"headerlink\" title=\"2.x版本的未来\"></a>2.x版本的未来</h2><p>2.x版本会在3.0稳定后推出一个Minor版本，之后会进入为期18个月的LTS，LTS过后只进行安全修复不会做版本更新。这个版本会包括部分2.x版本可兼容的3.0新特性。</p>\n","site":{"data":{}},"more":"<h2 id=\"直播内容\"><a href=\"#直播内容\" class=\"headerlink\" title=\"直播内容\"></a>直播内容</h2><blockquote>\n<p>直播使用的PPT<a href=\"https://docs.google.com/presentation/d/1LHp-8hEtXEMSE1fd6YLAhYmtndQelQKbWlGggZKe4y8/edit#slide=id.g31e95ee831_0_92\">Google文档地址, 需要科学上网</a></p>\n</blockquote>\n<ul>\n<li>3.0 Beta特性介绍<ul>\n<li>性能表现</li>\n<li>“摇树”支持</li>\n<li>Composition API</li>\n<li>Fragment, Teleport, Suspense</li>\n<li>更好的TypeScript支持</li>\n<li>自定义Render</li>\n</ul>\n</li>\n<li>何时才能使用Vue 3.0（生态进度）</li>\n</ul>\n<h2 id=\"性能表现\"><a href=\"#性能表现\" class=\"headerlink\" title=\"性能表现\"></a>性能表现</h2><h3 id=\"重写V-dom实现\"><a href=\"#重写V-dom实现\" class=\"headerlink\" title=\"重写V-dom实现\"></a>重写V-dom实现</h3><blockquote>\n<p>本节内容结合 <a href=\"https://vue-next-template-explorer.netlify.app/\"><em>vue-next-template-explorer.netlify.app</em></a> 食用更佳。</p>\n</blockquote>\n<p>2.0版本的的v-dom实现参考了<a href=\"https://github.com/snabbdom/snabbdom\">snabbdom</a>，加入了一部分Vue相关的特性属性如Static标记等。3.0大幅度修改了其实现，并对标记等进行了优化。</p>\n<h3 id=\"Compiler-informed-fast-paths（个人理解：更快的编译-render路径）\"><a href=\"#Compiler-informed-fast-paths（个人理解：更快的编译-render路径）\" class=\"headerlink\" title=\"Compiler-informed fast paths（个人理解：更快的编译/render路径）\"></a>Compiler-informed fast paths（个人理解：更快的编译/render路径）</h3><blockquote>\n<p>本节内容结合 <a href=\"https://vue-next-template-explorer.netlify.app/\"><em>vue-next-template-explorer.netlify.app</em></a> 食用更佳。</p>\n</blockquote>\n<p>这一部分主要体现在最终的render函数上，利用上述工具，我们发现静态节点标记以及属性（绑定）被归为不同的部分，其中静态节点甚至可以通过开启提升来进行复用，未绑定的属性与进行了绑定的也可以直接标记出来，减少了对比与diff压力，从而得到更快的速度。</p>\n<h3 id=\"更高效的组件初始化\"><a href=\"#更高效的组件初始化\" class=\"headerlink\" title=\"更高效的组件初始化\"></a>更高效的组件初始化</h3><h3 id=\"更新性能提高1-3～2倍\"><a href=\"#更新性能提高1-3～2倍\" class=\"headerlink\" title=\"更新性能提高1.3～2倍\"></a>更新性能提高1.3～2倍</h3><blockquote>\n<p>参考（下同）：based on benchmarks that simulates typical scenarios, may vary based on actual application.</p>\n</blockquote>\n<h3 id=\"2～3倍更快的SSR（服务端渲染）\"><a href=\"#2～3倍更快的SSR（服务端渲染）\" class=\"headerlink\" title=\"2～3倍更快的SSR（服务端渲染）\"></a>2～3倍更快的SSR（服务端渲染）</h3><p>SSR下，可以将静态节点作为Buffer的一部分直接推入最终的请求返回中，从而获得更快的速度。</p>\n<h2 id=\"“摇树”Tree-shaking\"><a href=\"#“摇树”Tree-shaking\" class=\"headerlink\" title=\"“摇树”Tree-shaking\"></a>“摇树”Tree-shaking</h2><blockquote>\n<p>本节内容结合 <a href=\"https://vue-next-template-explorer.netlify.app/\"><em>vue-next-template-explorer.netlify.app</em></a> 食用更佳。</p>\n</blockquote>\n<h3 id=\"大部分可选特性目前可被“摇树”\"><a href=\"#大部分可选特性目前可被“摇树”\" class=\"headerlink\" title=\"大部分可选特性目前可被“摇树”\"></a>大部分可选特性目前可被“摇树”</h3><p>在“next-template-explorer”中，如果你使用了例如v-on或者v-model等选项，可以在右侧清楚的发现对应选项通过摇树的方式单独打包进入最终的代码，相比于2.x版本需要包含完整runtime而言是非常大的优化。</p>\n<h3 id=\"最基本的HelloWorld示例打包大小约为13-5kb\"><a href=\"#最基本的HelloWorld示例打包大小约为13-5kb\" class=\"headerlink\" title=\"最基本的HelloWorld示例打包大小约为13.5kb\"></a>最基本的HelloWorld示例打包大小约为13.5kb</h3><blockquote>\n<p>如果选择只包含Composition API支持的模式，打包体积可以减小至11.75kb。</p>\n</blockquote>\n<h3 id=\"包含所有Runtime的打包体积约为22-5kb\"><a href=\"#包含所有Runtime的打包体积约为22-5kb\" class=\"headerlink\" title=\"包含所有Runtime的打包体积约为22.5kb\"></a>包含所有Runtime的打包体积约为22.5kb</h3><h2 id=\"Fragment-Teleport-Suspense\"><a href=\"#Fragment-Teleport-Suspense\" class=\"headerlink\" title=\"Fragment, Teleport, Suspense\"></a>Fragment, Teleport, Suspense</h2><h3 id=\"Fragment\"><a href=\"#Fragment\" class=\"headerlink\" title=\"Fragment\"></a>Fragment</h3><p>碎片的概念有些类似于<a href=\"https://zh-hans.reactjs.org/docs/fragments.html\">React的Fragment概念</a>，Vue 3版本支持更多的使用方式，比如可以只有字符串，或者利用数组构成一段Fragment。</p>\n<h3 id=\"Teleport-有译为：占位传递组件）\"><a href=\"#Teleport-有译为：占位传递组件）\" class=\"headerlink\" title=\"Teleport(有译为：占位传递组件）\"></a>Teleport(有译为：占位传递组件）</h3><p>Teleport与<a href=\"https://zh-hans.reactjs.org/docs/portals.html\">React的Portals概念</a>类似。</p>\n<blockquote>\n<p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>\n</blockquote>\n<blockquote>\n<p>尤大在直播中提到，为何没有直接使用Portal来命名还有另外一个原因：Chrome的iframe“替代方案”——<a href=\"https://www.chromestatus.com/feature/4828882419056640\">Portal</a></p>\n</blockquote>\n<p>Teleport功能可以用来将部分组件代码传递到DOM树的其他位置，可以在很多场景下使用，比如窗口resize等，简单说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- In some nested Vue component --&gt;</span><br><span class=\"line\">&lt;NestedComponent&gt;</span><br><span class=\"line\">  &lt;v-fragment target=<span class=\"string\">\"#popup-target\"</span>&gt;</span><br><span class=\"line\">    &lt;PopUp /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/v-fragment&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>NestedComponent&gt;</span><br><span class=\"line\">&lt;!-- before closing body tag --&gt;</span><br><span class=\"line\">&lt;div id=<span class=\"string\">\"popup-target\"</span>&gt;&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Suspense\"><a href=\"#Suspense\" class=\"headerlink\" title=\"Suspense\"></a>Suspense</h3><p>同样的，其对应了<a href=\"https://zh-hans.reactjs.org/docs/concurrent-mode-suspense.html\">React的Suspense概念</a>，要注意的是，<strong>当前Suspense特性在React中同样也是试验性功能，暂时不适合投入生产环境</strong> 。</p>\n<p>React社区中有一些第三方库对其进行了实现，比如zeit.co推出的<a href=\"https://github.com/zeit/swr\">swr库</a>，主要是用于作为等待与实现异步，Suspense部分会进行等待，直到异步任务完成继续，非常适合用来实现loading态。</p>\n<h2 id=\"何时才能使用Vue-3-0（生态进度）\"><a href=\"#何时才能使用Vue-3-0（生态进度）\" class=\"headerlink\" title=\"何时才能使用Vue 3.0（生态进度）\"></a>何时才能使用Vue 3.0（生态进度）</h2><blockquote>\n<p>建议随时参考官方的<a href=\"https://github.com/vuejs/vue-next\">Vue-next仓库</a>，了解生态各部分的开发进展。</p>\n</blockquote>\n<p>目前Vue 3.0已经进入了Beta版本，预计年中会推出可以投入生产的版本。</p>\n<ul>\n<li>Vue Router：已知会 <strong>有部分API改动</strong> ，目前alpha阶段；</li>\n<li>Vuex：目前已知没有API改动，同样处于alpha阶段；</li>\n<li>Vetur：其作者预计在五月份会进行跟进开发工作；</li>\n<li>Nuxt：目前已经实现了demo版本，正在跟进中；</li>\n<li>vue-cli：目前实验性支持；</li>\n</ul>\n<p>需要注意的是，Vue 3.0 __beta目前不支持IE11__，在未来会推出针对IE11的专用build，如果需要兼容则需要开启对应的开关，会在最终打包时加入部分的fallback策略。</p>\n<h2 id=\"2-x版本的未来\"><a href=\"#2-x版本的未来\" class=\"headerlink\" title=\"2.x版本的未来\"></a>2.x版本的未来</h2><p>2.x版本会在3.0稳定后推出一个Minor版本，之后会进入为期18个月的LTS，LTS过后只进行安全修复不会做版本更新。这个版本会包括部分2.x版本可兼容的3.0新特性。</p>\n"},{"title":"Vue(v2.6.10)的选项 / 生命周期钩子","date":"2019-08-18T08:00:00.000Z","excerpt":"生命周期/选项几乎是面试必考的点，快速过一遍加深印象。","thumbnail":"","_content":"#### Vue更新版生命周期\n\n截止v2.6.10版本，Vue相关的选项/生命周期共有11个：\n- beforeCreate\n- created\n- beforeMount\n- mounted\n- beforeUpdate\n- updated\n- activated\n- deactivated\n- beforeDestroy\n- destroyed\n- errorCaptured\n\n#### 生命周期顺序：\n\n初始化生命周期和方法 -> __beforeCreate__ -> 初始化依赖注入和响应式 -> __created__ -> 模板解析编译 -> __beforeMount__ -> 创建element节点 -> __mounted__ -> 如果数据被更新 -> __updated__ -> 触发重新渲染和patch (-> 如果数据继续更新 -> __beforeUpdate__ -> 调用`destroy`方法 -> __beforeDestroy__ -> 销毁子节点&watcher&事件监听 -> __destroyed__\n\n- activated\nkeep-alive 组件激活时调用。\n该钩子在服务器端渲染期间不被调用。\n\n- deactivated\nkeep-alive 组件停用时调用。\n该钩子在服务器端渲染期间不被调用。\n\n- errorCaptured\n\t__2.5.0+ 新增__\n    当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。\n\n> 这里提一下`keep-alive`, 这是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在` <keep-alive>` 内被切换，它的 `activated` 和`deactivated` 这两个生命周期钩子函数将会被对应执行。","source":"_posts/fe/vue-v2-6-10-的选项-生命周期钩子.md","raw":"---\ntags:\n- Vue.js\ncategories: Frontend\ntitle: Vue(v2.6.10)的选项 / 生命周期钩子\ndate: 2019-08-19T00:00:00.000+08:00\nexcerpt: 生命周期/选项几乎是面试必考的点，快速过一遍加深印象。\nthumbnail: ''\n\n---\n#### Vue更新版生命周期\n\n截止v2.6.10版本，Vue相关的选项/生命周期共有11个：\n- beforeCreate\n- created\n- beforeMount\n- mounted\n- beforeUpdate\n- updated\n- activated\n- deactivated\n- beforeDestroy\n- destroyed\n- errorCaptured\n\n#### 生命周期顺序：\n\n初始化生命周期和方法 -> __beforeCreate__ -> 初始化依赖注入和响应式 -> __created__ -> 模板解析编译 -> __beforeMount__ -> 创建element节点 -> __mounted__ -> 如果数据被更新 -> __updated__ -> 触发重新渲染和patch (-> 如果数据继续更新 -> __beforeUpdate__ -> 调用`destroy`方法 -> __beforeDestroy__ -> 销毁子节点&watcher&事件监听 -> __destroyed__\n\n- activated\nkeep-alive 组件激活时调用。\n该钩子在服务器端渲染期间不被调用。\n\n- deactivated\nkeep-alive 组件停用时调用。\n该钩子在服务器端渲染期间不被调用。\n\n- errorCaptured\n\t__2.5.0+ 新增__\n    当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。\n\n> 这里提一下`keep-alive`, 这是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在` <keep-alive>` 内被切换，它的 `activated` 和`deactivated` 这两个生命周期钩子函数将会被对应执行。","slug":"fe/vue-v2-6-10-的选项-生命周期钩子","published":1,"updated":"2020-08-01T18:21:52.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ian0017j1wtcpic30xg","content":"<h4 id=\"Vue更新版生命周期\"><a href=\"#Vue更新版生命周期\" class=\"headerlink\" title=\"Vue更新版生命周期\"></a>Vue更新版生命周期</h4><p>截止v2.6.10版本，Vue相关的选项/生命周期共有11个：</p>\n<ul>\n<li>beforeCreate</li>\n<li>created</li>\n<li>beforeMount</li>\n<li>mounted</li>\n<li>beforeUpdate</li>\n<li>updated</li>\n<li>activated</li>\n<li>deactivated</li>\n<li>beforeDestroy</li>\n<li>destroyed</li>\n<li>errorCaptured</li>\n</ul>\n<h4 id=\"生命周期顺序：\"><a href=\"#生命周期顺序：\" class=\"headerlink\" title=\"生命周期顺序：\"></a>生命周期顺序：</h4><p>初始化生命周期和方法 -&gt; <strong>beforeCreate</strong> -&gt; 初始化依赖注入和响应式 -&gt; <strong>created</strong> -&gt; 模板解析编译 -&gt; <strong>beforeMount</strong> -&gt; 创建element节点 -&gt; <strong>mounted</strong> -&gt; 如果数据被更新 -&gt; <strong>updated</strong> -&gt; 触发重新渲染和patch (-&gt; 如果数据继续更新 -&gt; <strong>beforeUpdate</strong> -&gt; 调用<code>destroy</code>方法 -&gt; <strong>beforeDestroy</strong> -&gt; 销毁子节点&amp;watcher&amp;事件监听 -&gt; <strong>destroyed</strong></p>\n<ul>\n<li><p>activated<br>keep-alive 组件激活时调用。<br>该钩子在服务器端渲染期间不被调用。</p>\n</li>\n<li><p>deactivated<br>keep-alive 组件停用时调用。<br>该钩子在服务器端渲染期间不被调用。</p>\n</li>\n<li><p>errorCaptured<br>  <strong>2.5.0+ 新增</strong><br>  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>\n</li>\n</ul>\n<blockquote>\n<p>这里提一下<code>keep-alive</code>, 这是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在<code> &lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和<code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n</blockquote>\n","site":{"data":{}},"more":"<h4 id=\"Vue更新版生命周期\"><a href=\"#Vue更新版生命周期\" class=\"headerlink\" title=\"Vue更新版生命周期\"></a>Vue更新版生命周期</h4><p>截止v2.6.10版本，Vue相关的选项/生命周期共有11个：</p>\n<ul>\n<li>beforeCreate</li>\n<li>created</li>\n<li>beforeMount</li>\n<li>mounted</li>\n<li>beforeUpdate</li>\n<li>updated</li>\n<li>activated</li>\n<li>deactivated</li>\n<li>beforeDestroy</li>\n<li>destroyed</li>\n<li>errorCaptured</li>\n</ul>\n<h4 id=\"生命周期顺序：\"><a href=\"#生命周期顺序：\" class=\"headerlink\" title=\"生命周期顺序：\"></a>生命周期顺序：</h4><p>初始化生命周期和方法 -&gt; <strong>beforeCreate</strong> -&gt; 初始化依赖注入和响应式 -&gt; <strong>created</strong> -&gt; 模板解析编译 -&gt; <strong>beforeMount</strong> -&gt; 创建element节点 -&gt; <strong>mounted</strong> -&gt; 如果数据被更新 -&gt; <strong>updated</strong> -&gt; 触发重新渲染和patch (-&gt; 如果数据继续更新 -&gt; <strong>beforeUpdate</strong> -&gt; 调用<code>destroy</code>方法 -&gt; <strong>beforeDestroy</strong> -&gt; 销毁子节点&amp;watcher&amp;事件监听 -&gt; <strong>destroyed</strong></p>\n<ul>\n<li><p>activated<br>keep-alive 组件激活时调用。<br>该钩子在服务器端渲染期间不被调用。</p>\n</li>\n<li><p>deactivated<br>keep-alive 组件停用时调用。<br>该钩子在服务器端渲染期间不被调用。</p>\n</li>\n<li><p>errorCaptured<br>  <strong>2.5.0+ 新增</strong><br>  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>\n</li>\n</ul>\n<blockquote>\n<p>这里提一下<code>keep-alive</code>, 这是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在<code> &lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和<code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n</blockquote>\n"},{"title":"Vue使用自定义指令完成节流和防抖","date":"2019-08-11T08:00:00.000Z","excerpt":"在与用户有较多互动的场景（搜索，表单智能补全），防抖和节流显得尤为重要，在用户体验与接口性能之间找到绝佳的平衡点。","thumbnail":"","_content":"### 为什么要通过指令实现？\n\n参考`lodash/_`，和`underscore`库，节流和防抖均是通过高阶函数的形式实现的，这种方式需要手动绑定`this`，对于 Vue 的单组件文件来说，在`methods`外层使用会导致`this`的指向不清，直接指向`window`的情况，举例：\n\n```javascript\nmethods: {\n  doSomethings () {\n    console.log('log')\n  }\n},\nmounted () {\n  document.querySelector('.test').addEventListener('click', function() {\n    _.throttle(this.doSomethings, 200)\n  }) // 无法正常触发，此写法报错非函数，箭头函数则完全没有触发内部函数\n}\n```\n\n```javascript\nmethods: {\n  doSomethings: _.throttle(function() {\n    console.log('log') // 可以正常节流，这里this的指向是该组件\n  })\n}\n```\n\n虽然第二种方法正确实现了节流，但是这种写法不方便进行组合合并，如果触发的函数有不同的情况，在内部的函数需要多层嵌套或者传参，举例：\n\n```vue\n<template>\n  <div id=\"app\">\n    olas\n    <span @click=\"test(1)\">1111</span>\n    <span @click=\"test(2)\">2222</span>\n    <span @click=\"test(3)\">3333</span>\n    <span @click=\"test(4)\">4444</span>\n  </div>\n</template>\n<script>\nmethods: {\n  test: function(i) {\n  \tconsole.log(i)\n  },\n\tdoSomething:_.throttle(function(i) {\n    this.test(i)\n  }, 2000)\n\t},\n\tmounted () {\n\n\t}\n</script>\n```\n\n这种情况下无法实现参数值的传递，需要借助 data，并不是比较好的选择，因此采用自定义指令的方式\n\n### 这种实现有什么不足？\n\n最大的一点不足就是 **SSR**\n\n需要通过判断`window`或者提供一个服务端专用版本来避免获取 dom，但是需要节流/防抖的一般都是在客户端的用户交互事件，往往不需要提供服务端版本，因此我这里采用`window`判断的方式，只在客户端挂载监听事件\n\n通过自定义指令，代理 v-on 直接挂载的方式，需要传入较多的参数\n\n### 防抖实现\n\n参数：\n\n- `func`: methods 内的函数名;\n- `args`: 向该方法传递的参数，形式为数组;\n- `opt` : 防抖选项，包含 seconds 和 immediate\n\n```javascript\nVue.directive('debounce', {\n  inserted: function(el, binding) {\n    const event = binding.arg\n    const funcArgs = binding.value.args || []\n    const options = binding.value.opt || {}\n    const wait = options.seconds || 300\n    if (typeof window !== 'undefined') {\n      let timer = null\n      el.addEventListener(event, e => {\n        if (timer) {\n          clearTimeout(timer)\n        }\n        if (options.immediate) {\n          let callNow = !timer\n          if (callNow) {\n            binding.value.func.apply(this, funcArgs)\n          }\n          timer = setTimeout(() => {\n            timer = null\n          }, wait)\n        } else {\n          timer = setTimeout(() => {\n            timer = null\n            binding.value.func.apply(this, funcArgs)\n          }, wait)\n        }\n      })\n    }\n  }\n})\n```\n\n### 节流实现\n\n参数：\n\n- `func`: methods 内的函数名;\n- `args`: 向该方法传递的参数，形式为数组;\n- `opt` : 防抖选项，包含 seconds 和 leading(未实现),trailing(未实现)\n\n```javascript\nVue.directive('throttle', {\n  inserted: function(el, binding) {\n    const event = binding.arg\n    const funcArgs = binding.value.args || []\n    const options = binding.value.opt || {}\n    const wait = options.seconds || 300\n    if (typeof window !== 'undefined') {\n      let previous = 0\n      el.addEventListener(event, e => {\n        if (!previous) {\n          previous = new Date()\n          binding.value.func.apply(this, funcArgs)\n        } else {\n          let now = new Date()\n          if (now - previous > wait) {\n            previous = now\n            binding.value.func.apply(this, funcArgs)\n          }\n        }\n      })\n    }\n  }\n})\n```","source":"_posts/fe/vue使用自定义指令完成节流和防抖.md","raw":"---\ntags:\n- Vue.js\ncategories: Frontend\ntitle: Vue使用自定义指令完成节流和防抖\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: 在与用户有较多互动的场景（搜索，表单智能补全），防抖和节流显得尤为重要，在用户体验与接口性能之间找到绝佳的平衡点。\nthumbnail: ''\n\n---\n### 为什么要通过指令实现？\n\n参考`lodash/_`，和`underscore`库，节流和防抖均是通过高阶函数的形式实现的，这种方式需要手动绑定`this`，对于 Vue 的单组件文件来说，在`methods`外层使用会导致`this`的指向不清，直接指向`window`的情况，举例：\n\n```javascript\nmethods: {\n  doSomethings () {\n    console.log('log')\n  }\n},\nmounted () {\n  document.querySelector('.test').addEventListener('click', function() {\n    _.throttle(this.doSomethings, 200)\n  }) // 无法正常触发，此写法报错非函数，箭头函数则完全没有触发内部函数\n}\n```\n\n```javascript\nmethods: {\n  doSomethings: _.throttle(function() {\n    console.log('log') // 可以正常节流，这里this的指向是该组件\n  })\n}\n```\n\n虽然第二种方法正确实现了节流，但是这种写法不方便进行组合合并，如果触发的函数有不同的情况，在内部的函数需要多层嵌套或者传参，举例：\n\n```vue\n<template>\n  <div id=\"app\">\n    olas\n    <span @click=\"test(1)\">1111</span>\n    <span @click=\"test(2)\">2222</span>\n    <span @click=\"test(3)\">3333</span>\n    <span @click=\"test(4)\">4444</span>\n  </div>\n</template>\n<script>\nmethods: {\n  test: function(i) {\n  \tconsole.log(i)\n  },\n\tdoSomething:_.throttle(function(i) {\n    this.test(i)\n  }, 2000)\n\t},\n\tmounted () {\n\n\t}\n</script>\n```\n\n这种情况下无法实现参数值的传递，需要借助 data，并不是比较好的选择，因此采用自定义指令的方式\n\n### 这种实现有什么不足？\n\n最大的一点不足就是 **SSR**\n\n需要通过判断`window`或者提供一个服务端专用版本来避免获取 dom，但是需要节流/防抖的一般都是在客户端的用户交互事件，往往不需要提供服务端版本，因此我这里采用`window`判断的方式，只在客户端挂载监听事件\n\n通过自定义指令，代理 v-on 直接挂载的方式，需要传入较多的参数\n\n### 防抖实现\n\n参数：\n\n- `func`: methods 内的函数名;\n- `args`: 向该方法传递的参数，形式为数组;\n- `opt` : 防抖选项，包含 seconds 和 immediate\n\n```javascript\nVue.directive('debounce', {\n  inserted: function(el, binding) {\n    const event = binding.arg\n    const funcArgs = binding.value.args || []\n    const options = binding.value.opt || {}\n    const wait = options.seconds || 300\n    if (typeof window !== 'undefined') {\n      let timer = null\n      el.addEventListener(event, e => {\n        if (timer) {\n          clearTimeout(timer)\n        }\n        if (options.immediate) {\n          let callNow = !timer\n          if (callNow) {\n            binding.value.func.apply(this, funcArgs)\n          }\n          timer = setTimeout(() => {\n            timer = null\n          }, wait)\n        } else {\n          timer = setTimeout(() => {\n            timer = null\n            binding.value.func.apply(this, funcArgs)\n          }, wait)\n        }\n      })\n    }\n  }\n})\n```\n\n### 节流实现\n\n参数：\n\n- `func`: methods 内的函数名;\n- `args`: 向该方法传递的参数，形式为数组;\n- `opt` : 防抖选项，包含 seconds 和 leading(未实现),trailing(未实现)\n\n```javascript\nVue.directive('throttle', {\n  inserted: function(el, binding) {\n    const event = binding.arg\n    const funcArgs = binding.value.args || []\n    const options = binding.value.opt || {}\n    const wait = options.seconds || 300\n    if (typeof window !== 'undefined') {\n      let previous = 0\n      el.addEventListener(event, e => {\n        if (!previous) {\n          previous = new Date()\n          binding.value.func.apply(this, funcArgs)\n        } else {\n          let now = new Date()\n          if (now - previous > wait) {\n            previous = now\n            binding.value.func.apply(this, funcArgs)\n          }\n        }\n      })\n    }\n  }\n})\n```","slug":"fe/vue使用自定义指令完成节流和防抖","published":1,"updated":"2020-08-01T18:21:52.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iao001aj1wtd6zugto5","content":"<h3 id=\"为什么要通过指令实现？\"><a href=\"#为什么要通过指令实现？\" class=\"headerlink\" title=\"为什么要通过指令实现？\"></a>为什么要通过指令实现？</h3><p>参考<code>lodash/_</code>，和<code>underscore</code>库，节流和防抖均是通过高阶函数的形式实现的，这种方式需要手动绑定<code>this</code>，对于 Vue 的单组件文件来说，在<code>methods</code>外层使用会导致<code>this</code>的指向不清，直接指向<code>window</code>的情况，举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  doSomethings () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'log'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mounted () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.test'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    _.throttle(<span class=\"keyword\">this</span>.doSomethings, <span class=\"number\">200</span>)</span><br><span class=\"line\">  &#125;) <span class=\"comment\">// 无法正常触发，此写法报错非函数，箭头函数则完全没有触发内部函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  doSomethings: _.throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'log'</span>) <span class=\"comment\">// 可以正常节流，这里this的指向是该组件</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然第二种方法正确实现了节流，但是这种写法不方便进行组合合并，如果触发的函数有不同的情况，在内部的函数需要多层嵌套或者传参，举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    olas</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(1)&quot;&gt;1111&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(2)&quot;&gt;2222&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(3)&quot;&gt;3333&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(4)&quot;&gt;4444&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  test: function(i) &#123;</span><br><span class=\"line\">  \tconsole.log(i)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">\tdoSomething:_.throttle(function(i) &#123;</span><br><span class=\"line\">    this.test(i)</span><br><span class=\"line\">  &#125;, 2000)</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmounted () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下无法实现参数值的传递，需要借助 data，并不是比较好的选择，因此采用自定义指令的方式</p>\n<h3 id=\"这种实现有什么不足？\"><a href=\"#这种实现有什么不足？\" class=\"headerlink\" title=\"这种实现有什么不足？\"></a>这种实现有什么不足？</h3><p>最大的一点不足就是 <strong>SSR</strong></p>\n<p>需要通过判断<code>window</code>或者提供一个服务端专用版本来避免获取 dom，但是需要节流/防抖的一般都是在客户端的用户交互事件，往往不需要提供服务端版本，因此我这里采用<code>window</code>判断的方式，只在客户端挂载监听事件</p>\n<p>通过自定义指令，代理 v-on 直接挂载的方式，需要传入较多的参数</p>\n<h3 id=\"防抖实现\"><a href=\"#防抖实现\" class=\"headerlink\" title=\"防抖实现\"></a>防抖实现</h3><p>参数：</p>\n<ul>\n<li><code>func</code>: methods 内的函数名;</li>\n<li><code>args</code>: 向该方法传递的参数，形式为数组;</li>\n<li><code>opt</code> : 防抖选项，包含 seconds 和 immediate</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'debounce'</span>, &#123;</span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> event = binding.arg</span><br><span class=\"line\">    <span class=\"keyword\">const</span> funcArgs = binding.value.args || []</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = binding.value.opt || &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wait = options.seconds || <span class=\"number\">300</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">      el.addEventListener(event, e =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">          clearTimeout(timer)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.immediate) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> callNow = !timer</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (callNow) &#123;</span><br><span class=\"line\">            binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span></span><br><span class=\"line\">          &#125;, wait)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span></span><br><span class=\"line\">            binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">          &#125;, wait)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"节流实现\"><a href=\"#节流实现\" class=\"headerlink\" title=\"节流实现\"></a>节流实现</h3><p>参数：</p>\n<ul>\n<li><code>func</code>: methods 内的函数名;</li>\n<li><code>args</code>: 向该方法传递的参数，形式为数组;</li>\n<li><code>opt</code> : 防抖选项，包含 seconds 和 leading(未实现),trailing(未实现)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'throttle'</span>, &#123;</span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> event = binding.arg</span><br><span class=\"line\">    <span class=\"keyword\">const</span> funcArgs = binding.value.args || []</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = binding.value.opt || &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wait = options.seconds || <span class=\"number\">300</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> previous = <span class=\"number\">0</span></span><br><span class=\"line\">      el.addEventListener(event, e =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!previous) &#123;</span><br><span class=\"line\">          previous = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">          binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">            binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"more":"<h3 id=\"为什么要通过指令实现？\"><a href=\"#为什么要通过指令实现？\" class=\"headerlink\" title=\"为什么要通过指令实现？\"></a>为什么要通过指令实现？</h3><p>参考<code>lodash/_</code>，和<code>underscore</code>库，节流和防抖均是通过高阶函数的形式实现的，这种方式需要手动绑定<code>this</code>，对于 Vue 的单组件文件来说，在<code>methods</code>外层使用会导致<code>this</code>的指向不清，直接指向<code>window</code>的情况，举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  doSomethings () &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'log'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mounted () &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.test'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    _.throttle(<span class=\"keyword\">this</span>.doSomethings, <span class=\"number\">200</span>)</span><br><span class=\"line\">  &#125;) <span class=\"comment\">// 无法正常触发，此写法报错非函数，箭头函数则完全没有触发内部函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  doSomethings: _.throttle(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'log'</span>) <span class=\"comment\">// 可以正常节流，这里this的指向是该组件</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然第二种方法正确实现了节流，但是这种写法不方便进行组合合并，如果触发的函数有不同的情况，在内部的函数需要多层嵌套或者传参，举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    olas</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(1)&quot;&gt;1111&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(2)&quot;&gt;2222&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(3)&quot;&gt;3333&lt;&#x2F;span&gt;</span><br><span class=\"line\">    &lt;span @click&#x3D;&quot;test(4)&quot;&gt;4444&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  test: function(i) &#123;</span><br><span class=\"line\">  \tconsole.log(i)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">\tdoSomething:_.throttle(function(i) &#123;</span><br><span class=\"line\">    this.test(i)</span><br><span class=\"line\">  &#125;, 2000)</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmounted () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下无法实现参数值的传递，需要借助 data，并不是比较好的选择，因此采用自定义指令的方式</p>\n<h3 id=\"这种实现有什么不足？\"><a href=\"#这种实现有什么不足？\" class=\"headerlink\" title=\"这种实现有什么不足？\"></a>这种实现有什么不足？</h3><p>最大的一点不足就是 <strong>SSR</strong></p>\n<p>需要通过判断<code>window</code>或者提供一个服务端专用版本来避免获取 dom，但是需要节流/防抖的一般都是在客户端的用户交互事件，往往不需要提供服务端版本，因此我这里采用<code>window</code>判断的方式，只在客户端挂载监听事件</p>\n<p>通过自定义指令，代理 v-on 直接挂载的方式，需要传入较多的参数</p>\n<h3 id=\"防抖实现\"><a href=\"#防抖实现\" class=\"headerlink\" title=\"防抖实现\"></a>防抖实现</h3><p>参数：</p>\n<ul>\n<li><code>func</code>: methods 内的函数名;</li>\n<li><code>args</code>: 向该方法传递的参数，形式为数组;</li>\n<li><code>opt</code> : 防抖选项，包含 seconds 和 immediate</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'debounce'</span>, &#123;</span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> event = binding.arg</span><br><span class=\"line\">    <span class=\"keyword\">const</span> funcArgs = binding.value.args || []</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = binding.value.opt || &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wait = options.seconds || <span class=\"number\">300</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">      el.addEventListener(event, e =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">          clearTimeout(timer)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (options.immediate) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> callNow = !timer</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (callNow) &#123;</span><br><span class=\"line\">            binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span></span><br><span class=\"line\">          &#125;, wait)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            timer = <span class=\"literal\">null</span></span><br><span class=\"line\">            binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">          &#125;, wait)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"节流实现\"><a href=\"#节流实现\" class=\"headerlink\" title=\"节流实现\"></a>节流实现</h3><p>参数：</p>\n<ul>\n<li><code>func</code>: methods 内的函数名;</li>\n<li><code>args</code>: 向该方法传递的参数，形式为数组;</li>\n<li><code>opt</code> : 防抖选项，包含 seconds 和 leading(未实现),trailing(未实现)</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">'throttle'</span>, &#123;</span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> event = binding.arg</span><br><span class=\"line\">    <span class=\"keyword\">const</span> funcArgs = binding.value.args || []</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = binding.value.opt || &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wait = options.seconds || <span class=\"number\">300</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> previous = <span class=\"number\">0</span></span><br><span class=\"line\">      el.addEventListener(event, e =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!previous) &#123;</span><br><span class=\"line\">          previous = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">          binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">            binding.value.func.apply(<span class=\"keyword\">this</span>, funcArgs)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"Vue中的 computed 和 watch的区别","date":"2019-08-21T08:00:00.000Z","excerpt":"这道题总有问的，大概两年的时间“经久不衰”，还是单独开一篇文章简单说明一下吧。","thumbnail":"","_content":"#### computed\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n\n#### watch\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter；\n\nwatch有两个选项，deep和immediate\n\n#### 两者的区别\n\ncomputed: 适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为computed\n\nwatch: 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化","source":"_posts/fe/vue中的-computed-和-watch的区别.md","raw":"---\ntags:\n- Vue.js\ncategories: Frontend\ntitle: Vue中的 computed 和 watch的区别\ndate: 2019-08-22T00:00:00.000+08:00\nexcerpt: 这道题总有问的，大概两年的时间“经久不衰”，还是单独开一篇文章简单说明一下吧。\nthumbnail: ''\n\n---\n#### computed\n我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\n\n我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。\n\n#### watch\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter；\n\nwatch有两个选项，deep和immediate\n\n#### 两者的区别\n\ncomputed: 适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为computed\n\nwatch: 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化","slug":"fe/vue中的-computed-和-watch的区别","published":1,"updated":"2020-08-01T18:21:52.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iaq001ej1wt0bcmgy3d","content":"<h4 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h4><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。</p>\n<p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter；</p>\n<p>watch有两个选项，deep和immediate</p>\n<h4 id=\"两者的区别\"><a href=\"#两者的区别\" class=\"headerlink\" title=\"两者的区别\"></a>两者的区别</h4><p>computed: 适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为computed</p>\n<p>watch: 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</p>\n","site":{"data":{}},"more":"<h4 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h4><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</p>\n<p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p>\n<h4 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。</p>\n<p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter；</p>\n<p>watch有两个选项，deep和immediate</p>\n<h4 id=\"两者的区别\"><a href=\"#两者的区别\" class=\"headerlink\" title=\"两者的区别\"></a>两者的区别</h4><p>computed: 适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为computed</p>\n<p>watch: 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</p>\n"},{"title":"Yarn内那些冷门的命令","date":"2020-01-05T08:00:00.000Z","excerpt":"这篇文章在忘记命令的时候还会快速访问看看，不要再只用install和add了！","thumbnail":"","_content":"## Yarn与Package\n\n1. `yarn remove [package]`\n\n执行remove会同时移除package.json与yarn.lock。\n\n## Yarn安装\n\n1. `yarn install --force`\n\nYarn支持缓存依赖，如果曾经安装过相同的包，则会从缓存读取，并且能够离线安装，如果认为之前缓存的版本有问题，则需要使用`--force`来强制跳过缓存安装。也可以运行`yarn cache clean`移除所有本地缓存（可以指定包名单独清理）。\n\n1. `yarn install --ignore-scripts`\n\nYarn和NPM在运行安装时，如果项目有相关的钩子，则会在相应的事件运行钩子，如果想避免执行钩子，则可以通过忽略scripts避免钩子执行。\n\n1. `yarn global add`\n\nYarn的全局安装需要注意的是，在一些环境下`yarn config set prefix <filepath>`来设置全局安装位置，或者在如同`yarn global add create-react-app --prefix /usr/local`配置全局安装位置。\n\n这个问题常见于Linux环境，如果我们执行`yarn config get prefix`得到的是`undefined`或者其他无法访问的目录，我们是不能够通过yarn global安装全局可执行的命令的，这时我们需要设置`yarn config set prefix ~/.yarn`然后在我们的\\~/.bashrc(或者\\~/.zshrc)文件内添加一行:\n\n```bash\nexport PATH=\"$PATH:`yarn global bin`\"\n```\n\n## Yarn CLI 相关\n\n1. `yarn list --depth=0`\n\n博主曾经遇到过一次本地环境阿里云SDK执行正常，但同事的执行故障，经过检查发现阿里云的SDK最近有更新，检查可以通过list命令，也可以指定具体的包。\n\n1. `yarn upgrade-interactive [--latest]`\n\n升级，升级包是一个核心需求，加入--latest可以忽视大版本直接获取对应包的最新版，如果是跨版本更新，则会同时修改package.json。\n\n1. `yarn version --new-version <version>`\n\n我们在更新项目时经常需要同时更新package.json的对应版本，如果需要结合CI流程则未免过于繁琐，可以对应执行yarn version来更新package.json。\n\n## 你应该保留yarn.lock文件并提交到版本控制\n\nyarn.lock文件内部包括了所有相关的依赖和版本信息，以及对应的包地址，为了能够保证在所有开发者以及开发环境（如CI等）的运行一致，建议保留并提交版本控制。\n\n## 有关于切换源\n\n> 原始默认的源：https://registry.yarnpkg.com\n\n我们可以通过`yarn config set registry https://registry.npm.taobao.org/`来设置源为淘宝源，但是偶尔会出现一些安装问题，这里备份一下原始地址以供参考。","source":"_posts/fe/yarn内那些冷门的命令.md","raw":"---\ntags:\n- NPM\ncategories: Frontend\ntitle: Yarn内那些冷门的命令\ndate: 2020-01-05T16:00:00.000+00:00\nexcerpt: 这篇文章在忘记命令的时候还会快速访问看看，不要再只用install和add了！\nthumbnail: ''\n\n---\n## Yarn与Package\n\n1. `yarn remove [package]`\n\n执行remove会同时移除package.json与yarn.lock。\n\n## Yarn安装\n\n1. `yarn install --force`\n\nYarn支持缓存依赖，如果曾经安装过相同的包，则会从缓存读取，并且能够离线安装，如果认为之前缓存的版本有问题，则需要使用`--force`来强制跳过缓存安装。也可以运行`yarn cache clean`移除所有本地缓存（可以指定包名单独清理）。\n\n1. `yarn install --ignore-scripts`\n\nYarn和NPM在运行安装时，如果项目有相关的钩子，则会在相应的事件运行钩子，如果想避免执行钩子，则可以通过忽略scripts避免钩子执行。\n\n1. `yarn global add`\n\nYarn的全局安装需要注意的是，在一些环境下`yarn config set prefix <filepath>`来设置全局安装位置，或者在如同`yarn global add create-react-app --prefix /usr/local`配置全局安装位置。\n\n这个问题常见于Linux环境，如果我们执行`yarn config get prefix`得到的是`undefined`或者其他无法访问的目录，我们是不能够通过yarn global安装全局可执行的命令的，这时我们需要设置`yarn config set prefix ~/.yarn`然后在我们的\\~/.bashrc(或者\\~/.zshrc)文件内添加一行:\n\n```bash\nexport PATH=\"$PATH:`yarn global bin`\"\n```\n\n## Yarn CLI 相关\n\n1. `yarn list --depth=0`\n\n博主曾经遇到过一次本地环境阿里云SDK执行正常，但同事的执行故障，经过检查发现阿里云的SDK最近有更新，检查可以通过list命令，也可以指定具体的包。\n\n1. `yarn upgrade-interactive [--latest]`\n\n升级，升级包是一个核心需求，加入--latest可以忽视大版本直接获取对应包的最新版，如果是跨版本更新，则会同时修改package.json。\n\n1. `yarn version --new-version <version>`\n\n我们在更新项目时经常需要同时更新package.json的对应版本，如果需要结合CI流程则未免过于繁琐，可以对应执行yarn version来更新package.json。\n\n## 你应该保留yarn.lock文件并提交到版本控制\n\nyarn.lock文件内部包括了所有相关的依赖和版本信息，以及对应的包地址，为了能够保证在所有开发者以及开发环境（如CI等）的运行一致，建议保留并提交版本控制。\n\n## 有关于切换源\n\n> 原始默认的源：https://registry.yarnpkg.com\n\n我们可以通过`yarn config set registry https://registry.npm.taobao.org/`来设置源为淘宝源，但是偶尔会出现一些安装问题，这里备份一下原始地址以供参考。","slug":"fe/yarn内那些冷门的命令","published":1,"updated":"2020-08-01T18:21:52.871Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iar001gj1wt66dwan10","content":"<h2 id=\"Yarn与Package\"><a href=\"#Yarn与Package\" class=\"headerlink\" title=\"Yarn与Package\"></a>Yarn与Package</h2><ol>\n<li><code>yarn remove [package]</code></li>\n</ol>\n<p>执行remove会同时移除package.json与yarn.lock。</p>\n<h2 id=\"Yarn安装\"><a href=\"#Yarn安装\" class=\"headerlink\" title=\"Yarn安装\"></a>Yarn安装</h2><ol>\n<li><code>yarn install --force</code></li>\n</ol>\n<p>Yarn支持缓存依赖，如果曾经安装过相同的包，则会从缓存读取，并且能够离线安装，如果认为之前缓存的版本有问题，则需要使用<code>--force</code>来强制跳过缓存安装。也可以运行<code>yarn cache clean</code>移除所有本地缓存（可以指定包名单独清理）。</p>\n<ol>\n<li><code>yarn install --ignore-scripts</code></li>\n</ol>\n<p>Yarn和NPM在运行安装时，如果项目有相关的钩子，则会在相应的事件运行钩子，如果想避免执行钩子，则可以通过忽略scripts避免钩子执行。</p>\n<ol>\n<li><code>yarn global add</code></li>\n</ol>\n<p>Yarn的全局安装需要注意的是，在一些环境下<code>yarn config set prefix &lt;filepath&gt;</code>来设置全局安装位置，或者在如同<code>yarn global add create-react-app --prefix /usr/local</code>配置全局安装位置。</p>\n<p>这个问题常见于Linux环境，如果我们执行<code>yarn config get prefix</code>得到的是<code>undefined</code>或者其他无法访问的目录，我们是不能够通过yarn global安装全局可执行的命令的，这时我们需要设置<code>yarn config set prefix ~/.yarn</code>然后在我们的~/.bashrc(或者~/.zshrc)文件内添加一行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">\"<span class=\"variable\">$PATH</span>:`yarn global bin`\"</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Yarn-CLI-相关\"><a href=\"#Yarn-CLI-相关\" class=\"headerlink\" title=\"Yarn CLI 相关\"></a>Yarn CLI 相关</h2><ol>\n<li><code>yarn list --depth=0</code></li>\n</ol>\n<p>博主曾经遇到过一次本地环境阿里云SDK执行正常，但同事的执行故障，经过检查发现阿里云的SDK最近有更新，检查可以通过list命令，也可以指定具体的包。</p>\n<ol>\n<li><code>yarn upgrade-interactive [--latest]</code></li>\n</ol>\n<p>升级，升级包是一个核心需求，加入–latest可以忽视大版本直接获取对应包的最新版，如果是跨版本更新，则会同时修改package.json。</p>\n<ol>\n<li><code>yarn version --new-version &lt;version&gt;</code></li>\n</ol>\n<p>我们在更新项目时经常需要同时更新package.json的对应版本，如果需要结合CI流程则未免过于繁琐，可以对应执行yarn version来更新package.json。</p>\n<h2 id=\"你应该保留yarn-lock文件并提交到版本控制\"><a href=\"#你应该保留yarn-lock文件并提交到版本控制\" class=\"headerlink\" title=\"你应该保留yarn.lock文件并提交到版本控制\"></a>你应该保留yarn.lock文件并提交到版本控制</h2><p>yarn.lock文件内部包括了所有相关的依赖和版本信息，以及对应的包地址，为了能够保证在所有开发者以及开发环境（如CI等）的运行一致，建议保留并提交版本控制。</p>\n<h2 id=\"有关于切换源\"><a href=\"#有关于切换源\" class=\"headerlink\" title=\"有关于切换源\"></a>有关于切换源</h2><blockquote>\n<p>原始默认的源：<a href=\"https://registry.yarnpkg.com/\">https://registry.yarnpkg.com</a></p>\n</blockquote>\n<p>我们可以通过<code>yarn config set registry https://registry.npm.taobao.org/</code>来设置源为淘宝源，但是偶尔会出现一些安装问题，这里备份一下原始地址以供参考。</p>\n","site":{"data":{}},"more":"<h2 id=\"Yarn与Package\"><a href=\"#Yarn与Package\" class=\"headerlink\" title=\"Yarn与Package\"></a>Yarn与Package</h2><ol>\n<li><code>yarn remove [package]</code></li>\n</ol>\n<p>执行remove会同时移除package.json与yarn.lock。</p>\n<h2 id=\"Yarn安装\"><a href=\"#Yarn安装\" class=\"headerlink\" title=\"Yarn安装\"></a>Yarn安装</h2><ol>\n<li><code>yarn install --force</code></li>\n</ol>\n<p>Yarn支持缓存依赖，如果曾经安装过相同的包，则会从缓存读取，并且能够离线安装，如果认为之前缓存的版本有问题，则需要使用<code>--force</code>来强制跳过缓存安装。也可以运行<code>yarn cache clean</code>移除所有本地缓存（可以指定包名单独清理）。</p>\n<ol>\n<li><code>yarn install --ignore-scripts</code></li>\n</ol>\n<p>Yarn和NPM在运行安装时，如果项目有相关的钩子，则会在相应的事件运行钩子，如果想避免执行钩子，则可以通过忽略scripts避免钩子执行。</p>\n<ol>\n<li><code>yarn global add</code></li>\n</ol>\n<p>Yarn的全局安装需要注意的是，在一些环境下<code>yarn config set prefix &lt;filepath&gt;</code>来设置全局安装位置，或者在如同<code>yarn global add create-react-app --prefix /usr/local</code>配置全局安装位置。</p>\n<p>这个问题常见于Linux环境，如果我们执行<code>yarn config get prefix</code>得到的是<code>undefined</code>或者其他无法访问的目录，我们是不能够通过yarn global安装全局可执行的命令的，这时我们需要设置<code>yarn config set prefix ~/.yarn</code>然后在我们的~/.bashrc(或者~/.zshrc)文件内添加一行:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"string\">\"<span class=\"variable\">$PATH</span>:`yarn global bin`\"</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Yarn-CLI-相关\"><a href=\"#Yarn-CLI-相关\" class=\"headerlink\" title=\"Yarn CLI 相关\"></a>Yarn CLI 相关</h2><ol>\n<li><code>yarn list --depth=0</code></li>\n</ol>\n<p>博主曾经遇到过一次本地环境阿里云SDK执行正常，但同事的执行故障，经过检查发现阿里云的SDK最近有更新，检查可以通过list命令，也可以指定具体的包。</p>\n<ol>\n<li><code>yarn upgrade-interactive [--latest]</code></li>\n</ol>\n<p>升级，升级包是一个核心需求，加入–latest可以忽视大版本直接获取对应包的最新版，如果是跨版本更新，则会同时修改package.json。</p>\n<ol>\n<li><code>yarn version --new-version &lt;version&gt;</code></li>\n</ol>\n<p>我们在更新项目时经常需要同时更新package.json的对应版本，如果需要结合CI流程则未免过于繁琐，可以对应执行yarn version来更新package.json。</p>\n<h2 id=\"你应该保留yarn-lock文件并提交到版本控制\"><a href=\"#你应该保留yarn-lock文件并提交到版本控制\" class=\"headerlink\" title=\"你应该保留yarn.lock文件并提交到版本控制\"></a>你应该保留yarn.lock文件并提交到版本控制</h2><p>yarn.lock文件内部包括了所有相关的依赖和版本信息，以及对应的包地址，为了能够保证在所有开发者以及开发环境（如CI等）的运行一致，建议保留并提交版本控制。</p>\n<h2 id=\"有关于切换源\"><a href=\"#有关于切换源\" class=\"headerlink\" title=\"有关于切换源\"></a>有关于切换源</h2><blockquote>\n<p>原始默认的源：<a href=\"https://registry.yarnpkg.com/\">https://registry.yarnpkg.com</a></p>\n</blockquote>\n<p>我们可以通过<code>yarn config set registry https://registry.npm.taobao.org/</code>来设置源为淘宝源，但是偶尔会出现一些安装问题，这里备份一下原始地址以供参考。</p>\n"},{"date":"2020-03-19T23:07:15.000Z","title":"从零到一实现一个JS版深克隆","excerpt":"> 这一类的面试题其实并不是很难，但如果不自己亲自实现一遍，很难照顾到各种情况，本文从模仿lodash库内的cloneDeep函数来循序渐进地实现一个深克隆。","thumbnail":"","_content":"\n## 深克隆是用来做什么的？\n\nJavaScript内，所有的Object都是引用类型，它们对应的变量只保存了一个指向实际内存的指针，如果我们只是将目标对象赋值给新对象，那么我们实际复制的还是指针，如果我们修改了原始内存内保存的对象，就会导致所有相关的变量都会被改变。因此，深克隆的目的就是为了生成一个全新的对象，并存储在独立的内存位置内。\n\n## 先实现一个简单的复制\n\n假设我们有以下一段已有的代码：\n\n```javascript\n// 测试循环应用\nvar _objType = {\n  name: \"This is another object.\"\n};\n// _objType.objectType = _objType;\n\n// 复制的原始对象\nvar origin = {\n  stringType : \"This is string.\",\n  numberType : 123,\n  booleanType : false,\n  objectType : _objType,\n  functionType : function() {\n    return document.navigator.userAgent;\n  },\n  inheritType: inheritObj\n}\n\nvar clonedObj = cloneDeep(origin);\norigin.numberType = 456; // 修改原始对象的属性\n\nconsole.log(clonedObj);\n```\n\n那么我们的基础复制方法baseClone应该如下：\n\n```javascript\nfunction cloneDeep(target) {\n  return baseClone(target);\n}\n\nfunction baseClone(target) {\n  var newObj = {};\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n    newObj[key] = target[key];\n  }\n  return newObj;\n}\n```\n\n我们注释了一个循环引用的情况下，对应的属性得到了复制，并且在修改原始对象时，新对象没有被修改。\n\n## 递归实现简单深复制\n\n通过判断每次读取的key是否是对象，我们可以得到一个递归实现的简单深拷贝：\n\n```javascript\nfunction baseClone(target) {\n  var newObj = {};\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key]);\n      } else {\n        newObj[key] = target[key];\n      }\n  }\n  return newObj;\n}\n```\n\n但是这里就会出现一个非常致命的bug， **我们的测试用例内有一个循环引用，如果只这样遍历会导致无限递归** ，我们需要进行处理。\n\n## 保证只循环复制自身的属性\n\n修改我们的baseClone，检测对应的key是否是自身属性：\n\n```javascript\nfunction baseClone(target) {\n  var newObj = {};\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n    if(Object.prototype.hasOwnProperty.call(target, key)) { // 使用泛型方法，避免target内存在自定义的hasOwnProperty方法导致判断出现错误\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key]);\n      } else {\n        newObj[key] = target[key];\n      }\n  \t}\n  }\n  return newObj;\n}\n```\n\n## 处理循环引用(Circular Structure)\n\n> 循环引用是指，对象A中有一个指针指向对象B，B内又有一个指针指向对象A，导致两个指针都不能得到正确的释放。\n\n我们使用一个数组去存储拷贝过的对象，避免循环引用导致递归进入死循环无法退出的问题：\n\n```javascript\nfunction baseClone(target, stack) {\n  var newObj = {};\n  if(!stack) stack = [];\n  // 检测target是否已经存在于stack内\n  if(target.indexOf(stack) > -1) {\n    return target\n  } else {\n    stack.push(target)\n  }\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key], stack);\n      } else {\n        newObj[key] = target[key];\n      }\n  }\n  return newObj;\n}\n```\n\n## 如果涉及到继承\n\n我们修改上面的例子，给出一个简单的继承：\n\n```javascript\n// 测试继承部分的情况\nfunction OriginParent(name) {\n  this._stringType = name;\n  this.numberType = 999;\n};\nvar inheritObj = new OriginParent(\"origin string\");\nvar clonedInherit = cloneDeep(inheritObj);\ninheritObj.numberType = 888;\n\nconsole.log(clonedInherit.constructor);\n```\n\n当我们打印复制的对象的构造函数时，我们发现它输出的是Object而非OriginParent，也就是说我们在复制的过程中，遗失了它本身的构造函数。\n\n因此在循环时我们需要使用一个变量临时存储，并在之后修复它，改进的代码如下：\n\n```javascript\n// 利用new操作符的特性完成修复\nfunction inheritClone(target) {\n  var ctor = target.constructor;\n  var newObj = new ctor;\n  return newObj;\n}\n```\n\n> 这里处理的情况其实是函数，但实际上lodash库对于函数直接进行了返回，换而言之，他们使用同一个内存地址是符合我们对于深拷贝的定义的。\n\n## 处理更多的类型\n\n### 数组\n\n首先通过展开运算符(`...`)是可以快速实现的，会对简单的一维数组（且内部均为基本类型的值）的数组进行拷贝，如果涉及到引用类型（包括多维数组），还需要进行递归处理直到目标是一个基础类型为止。\n\n除了展开运算，我们也可以使用几个数组的原生方法返回全新的数组，比如`Array.map`或者`Array.concat(); // 拼接为空时是指返回新的原来数组`\n\n修改上面的代码，使之支持数组：\n\n```javascript\nfunction baseClone(target, stack) {\n  var newObj = Array.isArray(target) : [] : {};\n  if(!stack) stack = [];\n  // 检测target是否已经存在于stack内\n  if(target.indexOf(stack) > -1) {\n    return target\n  } else {\n    stack.push(target)\n  }\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key], stack);\n      } else {\n        newObj[key] = target[key];\n      }\n  }\n  return newObj;\n}\n```\n\n### 其他引用类型\n\n首先要进行判断，因为是引用类型，建议通过`toString`来进行判断，下面给出一个简单的对应：\n\n```javascript\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst numberTag = '[object Number]';\nconst regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\n```\n\n对于以上的类型，除了数组和对象，其他都不能再进行递归拷贝，因此可以对应使用构造器直接构造新的引用值来进行拷贝。\n\n## 延展话题：Map与WeakMap\n\n这个话题之后会另起一篇单独讨论，他们在这一类复制的情况可以有较好的运用。","source":"_posts/fe/从零到一实现一个js版深克隆.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-03-20T07:07:15.000+00:00\ntitle: 从零到一实现一个JS版深克隆\nexcerpt: \"> 这一类的面试题其实并不是很难，但如果不自己亲自实现一遍，很难照顾到各种情况，本文从模仿lodash库内的cloneDeep函数来循序渐进地实现一个深克隆。\"\nthumbnail: ''\n\n---\n\n## 深克隆是用来做什么的？\n\nJavaScript内，所有的Object都是引用类型，它们对应的变量只保存了一个指向实际内存的指针，如果我们只是将目标对象赋值给新对象，那么我们实际复制的还是指针，如果我们修改了原始内存内保存的对象，就会导致所有相关的变量都会被改变。因此，深克隆的目的就是为了生成一个全新的对象，并存储在独立的内存位置内。\n\n## 先实现一个简单的复制\n\n假设我们有以下一段已有的代码：\n\n```javascript\n// 测试循环应用\nvar _objType = {\n  name: \"This is another object.\"\n};\n// _objType.objectType = _objType;\n\n// 复制的原始对象\nvar origin = {\n  stringType : \"This is string.\",\n  numberType : 123,\n  booleanType : false,\n  objectType : _objType,\n  functionType : function() {\n    return document.navigator.userAgent;\n  },\n  inheritType: inheritObj\n}\n\nvar clonedObj = cloneDeep(origin);\norigin.numberType = 456; // 修改原始对象的属性\n\nconsole.log(clonedObj);\n```\n\n那么我们的基础复制方法baseClone应该如下：\n\n```javascript\nfunction cloneDeep(target) {\n  return baseClone(target);\n}\n\nfunction baseClone(target) {\n  var newObj = {};\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n    newObj[key] = target[key];\n  }\n  return newObj;\n}\n```\n\n我们注释了一个循环引用的情况下，对应的属性得到了复制，并且在修改原始对象时，新对象没有被修改。\n\n## 递归实现简单深复制\n\n通过判断每次读取的key是否是对象，我们可以得到一个递归实现的简单深拷贝：\n\n```javascript\nfunction baseClone(target) {\n  var newObj = {};\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key]);\n      } else {\n        newObj[key] = target[key];\n      }\n  }\n  return newObj;\n}\n```\n\n但是这里就会出现一个非常致命的bug， **我们的测试用例内有一个循环引用，如果只这样遍历会导致无限递归** ，我们需要进行处理。\n\n## 保证只循环复制自身的属性\n\n修改我们的baseClone，检测对应的key是否是自身属性：\n\n```javascript\nfunction baseClone(target) {\n  var newObj = {};\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n    if(Object.prototype.hasOwnProperty.call(target, key)) { // 使用泛型方法，避免target内存在自定义的hasOwnProperty方法导致判断出现错误\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key]);\n      } else {\n        newObj[key] = target[key];\n      }\n  \t}\n  }\n  return newObj;\n}\n```\n\n## 处理循环引用(Circular Structure)\n\n> 循环引用是指，对象A中有一个指针指向对象B，B内又有一个指针指向对象A，导致两个指针都不能得到正确的释放。\n\n我们使用一个数组去存储拷贝过的对象，避免循环引用导致递归进入死循环无法退出的问题：\n\n```javascript\nfunction baseClone(target, stack) {\n  var newObj = {};\n  if(!stack) stack = [];\n  // 检测target是否已经存在于stack内\n  if(target.indexOf(stack) > -1) {\n    return target\n  } else {\n    stack.push(target)\n  }\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key], stack);\n      } else {\n        newObj[key] = target[key];\n      }\n  }\n  return newObj;\n}\n```\n\n## 如果涉及到继承\n\n我们修改上面的例子，给出一个简单的继承：\n\n```javascript\n// 测试继承部分的情况\nfunction OriginParent(name) {\n  this._stringType = name;\n  this.numberType = 999;\n};\nvar inheritObj = new OriginParent(\"origin string\");\nvar clonedInherit = cloneDeep(inheritObj);\ninheritObj.numberType = 888;\n\nconsole.log(clonedInherit.constructor);\n```\n\n当我们打印复制的对象的构造函数时，我们发现它输出的是Object而非OriginParent，也就是说我们在复制的过程中，遗失了它本身的构造函数。\n\n因此在循环时我们需要使用一个变量临时存储，并在之后修复它，改进的代码如下：\n\n```javascript\n// 利用new操作符的特性完成修复\nfunction inheritClone(target) {\n  var ctor = target.constructor;\n  var newObj = new ctor;\n  return newObj;\n}\n```\n\n> 这里处理的情况其实是函数，但实际上lodash库对于函数直接进行了返回，换而言之，他们使用同一个内存地址是符合我们对于深拷贝的定义的。\n\n## 处理更多的类型\n\n### 数组\n\n首先通过展开运算符(`...`)是可以快速实现的，会对简单的一维数组（且内部均为基本类型的值）的数组进行拷贝，如果涉及到引用类型（包括多维数组），还需要进行递归处理直到目标是一个基础类型为止。\n\n除了展开运算，我们也可以使用几个数组的原生方法返回全新的数组，比如`Array.map`或者`Array.concat(); // 拼接为空时是指返回新的原来数组`\n\n修改上面的代码，使之支持数组：\n\n```javascript\nfunction baseClone(target, stack) {\n  var newObj = Array.isArray(target) : [] : {};\n  if(!stack) stack = [];\n  // 检测target是否已经存在于stack内\n  if(target.indexOf(stack) > -1) {\n    return target\n  } else {\n    stack.push(target)\n  }\n  for (var key in target) {\n    // 循环一个指定的变量来循环一个对象所有可枚举的属性\n      if(typeof target[key] === 'object' && target[key] !== null) {\n        newObj[key] = baseClone(target[key], stack);\n      } else {\n        newObj[key] = target[key];\n      }\n  }\n  return newObj;\n}\n```\n\n### 其他引用类型\n\n首先要进行判断，因为是引用类型，建议通过`toString`来进行判断，下面给出一个简单的对应：\n\n```javascript\nconst mapTag = '[object Map]';\nconst setTag = '[object Set]';\nconst arrayTag = '[object Array]';\nconst objectTag = '[object Object]';\n\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst numberTag = '[object Number]';\nconst regexpTag = '[object RegExp]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\n```\n\n对于以上的类型，除了数组和对象，其他都不能再进行递归拷贝，因此可以对应使用构造器直接构造新的引用值来进行拷贝。\n\n## 延展话题：Map与WeakMap\n\n这个话题之后会另起一篇单独讨论，他们在这一类复制的情况可以有较好的运用。","slug":"fe/从零到一实现一个js版深克隆","published":1,"updated":"2020-07-27T15:54:32.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ias001kj1wt9h368ncw","content":"<h2 id=\"深克隆是用来做什么的？\"><a href=\"#深克隆是用来做什么的？\" class=\"headerlink\" title=\"深克隆是用来做什么的？\"></a>深克隆是用来做什么的？</h2><p>JavaScript内，所有的Object都是引用类型，它们对应的变量只保存了一个指向实际内存的指针，如果我们只是将目标对象赋值给新对象，那么我们实际复制的还是指针，如果我们修改了原始内存内保存的对象，就会导致所有相关的变量都会被改变。因此，深克隆的目的就是为了生成一个全新的对象，并存储在独立的内存位置内。</p>\n<h2 id=\"先实现一个简单的复制\"><a href=\"#先实现一个简单的复制\" class=\"headerlink\" title=\"先实现一个简单的复制\"></a>先实现一个简单的复制</h2><p>假设我们有以下一段已有的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试循环应用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _objType = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"This is another object.\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// _objType.objectType = _objType;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制的原始对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> origin = &#123;</span><br><span class=\"line\">  stringType : <span class=\"string\">\"This is string.\"</span>,</span><br><span class=\"line\">  numberType : <span class=\"number\">123</span>,</span><br><span class=\"line\">  booleanType : <span class=\"literal\">false</span>,</span><br><span class=\"line\">  objectType : _objType,</span><br><span class=\"line\">  functionType : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.navigator.userAgent;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  inheritType: inheritObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> clonedObj = cloneDeep(origin);</span><br><span class=\"line\">origin.numberType = <span class=\"number\">456</span>; <span class=\"comment\">// 修改原始对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clonedObj);</span><br></pre></td></tr></table></figure>\n\n<p>那么我们的基础复制方法baseClone应该如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseClone(target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">    newObj[key] = target[key];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注释了一个循环引用的情况下，对应的属性得到了复制，并且在修改原始对象时，新对象没有被修改。</p>\n<h2 id=\"递归实现简单深复制\"><a href=\"#递归实现简单深复制\" class=\"headerlink\" title=\"递归实现简单深复制\"></a>递归实现简单深复制</h2><p>通过判断每次读取的key是否是对象，我们可以得到一个递归实现的简单深拷贝：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这里就会出现一个非常致命的bug， <strong>我们的测试用例内有一个循环引用，如果只这样遍历会导致无限递归</strong> ，我们需要进行处理。</p>\n<h2 id=\"保证只循环复制自身的属性\"><a href=\"#保证只循环复制自身的属性\" class=\"headerlink\" title=\"保证只循环复制自身的属性\"></a>保证只循环复制自身的属性</h2><p>修改我们的baseClone，检测对应的key是否是自身属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(target, key)) &#123; <span class=\"comment\">// 使用泛型方法，避免target内存在自定义的hasOwnProperty方法导致判断出现错误</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理循环引用-Circular-Structure\"><a href=\"#处理循环引用-Circular-Structure\" class=\"headerlink\" title=\"处理循环引用(Circular Structure)\"></a>处理循环引用(Circular Structure)</h2><blockquote>\n<p>循环引用是指，对象A中有一个指针指向对象B，B内又有一个指针指向对象A，导致两个指针都不能得到正确的释放。</p>\n</blockquote>\n<p>我们使用一个数组去存储拷贝过的对象，避免循环引用导致递归进入死循环无法退出的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!stack) stack = [];</span><br><span class=\"line\">  <span class=\"comment\">// 检测target是否已经存在于stack内</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(target.indexOf(stack) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    stack.push(target)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key], stack);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如果涉及到继承\"><a href=\"#如果涉及到继承\" class=\"headerlink\" title=\"如果涉及到继承\"></a>如果涉及到继承</h2><p>我们修改上面的例子，给出一个简单的继承：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试继承部分的情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">OriginParent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._stringType = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.numberType = <span class=\"number\">999</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inheritObj = <span class=\"keyword\">new</span> OriginParent(<span class=\"string\">\"origin string\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> clonedInherit = cloneDeep(inheritObj);</span><br><span class=\"line\">inheritObj.numberType = <span class=\"number\">888</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clonedInherit.constructor);</span><br></pre></td></tr></table></figure>\n\n<p>当我们打印复制的对象的构造函数时，我们发现它输出的是Object而非OriginParent，也就是说我们在复制的过程中，遗失了它本身的构造函数。</p>\n<p>因此在循环时我们需要使用一个变量临时存储，并在之后修复它，改进的代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 利用new操作符的特性完成修复</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctor = target.constructor;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = <span class=\"keyword\">new</span> ctor;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里处理的情况其实是函数，但实际上lodash库对于函数直接进行了返回，换而言之，他们使用同一个内存地址是符合我们对于深拷贝的定义的。</p>\n</blockquote>\n<h2 id=\"处理更多的类型\"><a href=\"#处理更多的类型\" class=\"headerlink\" title=\"处理更多的类型\"></a>处理更多的类型</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>首先通过展开运算符(<code>...</code>)是可以快速实现的，会对简单的一维数组（且内部均为基本类型的值）的数组进行拷贝，如果涉及到引用类型（包括多维数组），还需要进行递归处理直到目标是一个基础类型为止。</p>\n<p>除了展开运算，我们也可以使用几个数组的原生方法返回全新的数组，比如<code>Array.map</code>或者<code>Array.concat(); // 拼接为空时是指返回新的原来数组</code></p>\n<p>修改上面的代码，使之支持数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = <span class=\"built_in\">Array</span>.isArray(target) : [] : &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!stack) stack = [];</span><br><span class=\"line\">  <span class=\"comment\">// 检测target是否已经存在于stack内</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(target.indexOf(stack) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    stack.push(target)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key], stack);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他引用类型\"><a href=\"#其他引用类型\" class=\"headerlink\" title=\"其他引用类型\"></a>其他引用类型</h3><p>首先要进行判断，因为是引用类型，建议通过<code>toString</code>来进行判断，下面给出一个简单的对应：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapTag = <span class=\"string\">'[object Map]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> setTag = <span class=\"string\">'[object Set]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayTag = <span class=\"string\">'[object Array]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> objectTag = <span class=\"string\">'[object Object]'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> boolTag = <span class=\"string\">'[object Boolean]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dateTag = <span class=\"string\">'[object Date]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> errorTag = <span class=\"string\">'[object Error]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> numberTag = <span class=\"string\">'[object Number]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> regexpTag = <span class=\"string\">'[object RegExp]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stringTag = <span class=\"string\">'[object String]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> symbolTag = <span class=\"string\">'[object Symbol]'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对于以上的类型，除了数组和对象，其他都不能再进行递归拷贝，因此可以对应使用构造器直接构造新的引用值来进行拷贝。</p>\n<h2 id=\"延展话题：Map与WeakMap\"><a href=\"#延展话题：Map与WeakMap\" class=\"headerlink\" title=\"延展话题：Map与WeakMap\"></a>延展话题：Map与WeakMap</h2><p>这个话题之后会另起一篇单独讨论，他们在这一类复制的情况可以有较好的运用。</p>\n","site":{"data":{}},"more":"<h2 id=\"深克隆是用来做什么的？\"><a href=\"#深克隆是用来做什么的？\" class=\"headerlink\" title=\"深克隆是用来做什么的？\"></a>深克隆是用来做什么的？</h2><p>JavaScript内，所有的Object都是引用类型，它们对应的变量只保存了一个指向实际内存的指针，如果我们只是将目标对象赋值给新对象，那么我们实际复制的还是指针，如果我们修改了原始内存内保存的对象，就会导致所有相关的变量都会被改变。因此，深克隆的目的就是为了生成一个全新的对象，并存储在独立的内存位置内。</p>\n<h2 id=\"先实现一个简单的复制\"><a href=\"#先实现一个简单的复制\" class=\"headerlink\" title=\"先实现一个简单的复制\"></a>先实现一个简单的复制</h2><p>假设我们有以下一段已有的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试循环应用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _objType = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">\"This is another object.\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// _objType.objectType = _objType;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复制的原始对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> origin = &#123;</span><br><span class=\"line\">  stringType : <span class=\"string\">\"This is string.\"</span>,</span><br><span class=\"line\">  numberType : <span class=\"number\">123</span>,</span><br><span class=\"line\">  booleanType : <span class=\"literal\">false</span>,</span><br><span class=\"line\">  objectType : _objType,</span><br><span class=\"line\">  functionType : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">document</span>.navigator.userAgent;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  inheritType: inheritObj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> clonedObj = cloneDeep(origin);</span><br><span class=\"line\">origin.numberType = <span class=\"number\">456</span>; <span class=\"comment\">// 修改原始对象的属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clonedObj);</span><br></pre></td></tr></table></figure>\n\n<p>那么我们的基础复制方法baseClone应该如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cloneDeep</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> baseClone(target);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">    newObj[key] = target[key];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注释了一个循环引用的情况下，对应的属性得到了复制，并且在修改原始对象时，新对象没有被修改。</p>\n<h2 id=\"递归实现简单深复制\"><a href=\"#递归实现简单深复制\" class=\"headerlink\" title=\"递归实现简单深复制\"></a>递归实现简单深复制</h2><p>通过判断每次读取的key是否是对象，我们可以得到一个递归实现的简单深拷贝：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这里就会出现一个非常致命的bug， <strong>我们的测试用例内有一个循环引用，如果只这样遍历会导致无限递归</strong> ，我们需要进行处理。</p>\n<h2 id=\"保证只循环复制自身的属性\"><a href=\"#保证只循环复制自身的属性\" class=\"headerlink\" title=\"保证只循环复制自身的属性\"></a>保证只循环复制自身的属性</h2><p>修改我们的baseClone，检测对应的key是否是自身属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(target, key)) &#123; <span class=\"comment\">// 使用泛型方法，避免target内存在自定义的hasOwnProperty方法导致判断出现错误</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key]);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"处理循环引用-Circular-Structure\"><a href=\"#处理循环引用-Circular-Structure\" class=\"headerlink\" title=\"处理循环引用(Circular Structure)\"></a>处理循环引用(Circular Structure)</h2><blockquote>\n<p>循环引用是指，对象A中有一个指针指向对象B，B内又有一个指针指向对象A，导致两个指针都不能得到正确的释放。</p>\n</blockquote>\n<p>我们使用一个数组去存储拷贝过的对象，避免循环引用导致递归进入死循环无法退出的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!stack) stack = [];</span><br><span class=\"line\">  <span class=\"comment\">// 检测target是否已经存在于stack内</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(target.indexOf(stack) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    stack.push(target)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key], stack);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"如果涉及到继承\"><a href=\"#如果涉及到继承\" class=\"headerlink\" title=\"如果涉及到继承\"></a>如果涉及到继承</h2><p>我们修改上面的例子，给出一个简单的继承：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试继承部分的情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">OriginParent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>._stringType = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.numberType = <span class=\"number\">999</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inheritObj = <span class=\"keyword\">new</span> OriginParent(<span class=\"string\">\"origin string\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> clonedInherit = cloneDeep(inheritObj);</span><br><span class=\"line\">inheritObj.numberType = <span class=\"number\">888</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clonedInherit.constructor);</span><br></pre></td></tr></table></figure>\n\n<p>当我们打印复制的对象的构造函数时，我们发现它输出的是Object而非OriginParent，也就是说我们在复制的过程中，遗失了它本身的构造函数。</p>\n<p>因此在循环时我们需要使用一个变量临时存储，并在之后修复它，改进的代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 利用new操作符的特性完成修复</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ctor = target.constructor;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = <span class=\"keyword\">new</span> ctor;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里处理的情况其实是函数，但实际上lodash库对于函数直接进行了返回，换而言之，他们使用同一个内存地址是符合我们对于深拷贝的定义的。</p>\n</blockquote>\n<h2 id=\"处理更多的类型\"><a href=\"#处理更多的类型\" class=\"headerlink\" title=\"处理更多的类型\"></a>处理更多的类型</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>首先通过展开运算符(<code>...</code>)是可以快速实现的，会对简单的一维数组（且内部均为基本类型的值）的数组进行拷贝，如果涉及到引用类型（包括多维数组），还需要进行递归处理直到目标是一个基础类型为止。</p>\n<p>除了展开运算，我们也可以使用几个数组的原生方法返回全新的数组，比如<code>Array.map</code>或者<code>Array.concat(); // 拼接为空时是指返回新的原来数组</code></p>\n<p>修改上面的代码，使之支持数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseClone</span>(<span class=\"params\">target, stack</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newObj = <span class=\"built_in\">Array</span>.isArray(target) : [] : &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!stack) stack = [];</span><br><span class=\"line\">  <span class=\"comment\">// 检测target是否已经存在于stack内</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(target.indexOf(stack) &gt; <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    stack.push(target)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环一个指定的变量来循环一个对象所有可枚举的属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> target[key] === <span class=\"string\">'object'</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        newObj[key] = baseClone(target[key], stack);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        newObj[key] = target[key];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newObj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他引用类型\"><a href=\"#其他引用类型\" class=\"headerlink\" title=\"其他引用类型\"></a>其他引用类型</h3><p>首先要进行判断，因为是引用类型，建议通过<code>toString</code>来进行判断，下面给出一个简单的对应：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mapTag = <span class=\"string\">'[object Map]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> setTag = <span class=\"string\">'[object Set]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayTag = <span class=\"string\">'[object Array]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> objectTag = <span class=\"string\">'[object Object]'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> boolTag = <span class=\"string\">'[object Boolean]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> dateTag = <span class=\"string\">'[object Date]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> errorTag = <span class=\"string\">'[object Error]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> numberTag = <span class=\"string\">'[object Number]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> regexpTag = <span class=\"string\">'[object RegExp]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stringTag = <span class=\"string\">'[object String]'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> symbolTag = <span class=\"string\">'[object Symbol]'</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对于以上的类型，除了数组和对象，其他都不能再进行递归拷贝，因此可以对应使用构造器直接构造新的引用值来进行拷贝。</p>\n<h2 id=\"延展话题：Map与WeakMap\"><a href=\"#延展话题：Map与WeakMap\" class=\"headerlink\" title=\"延展话题：Map与WeakMap\"></a>延展话题：Map与WeakMap</h2><p>这个话题之后会另起一篇单独讨论，他们在这一类复制的情况可以有较好的运用。</p>\n"},{"title":"从DOM与虚拟DOM了解Vue和React是如何响应数据变化的","date":"2020-01-07T08:00:00.000Z","excerpt":"提起MVVM框架，就不能不提到虚拟DOM，也正是由于虚拟DOM的存在，界面不再是一条条DOM操作驱动的，取而代之的是数据的改变，“自动”地驱动了DOM改变……","thumbnail":"","_content":"## 先说浏览器的渲染模式\n\n这里引用一段掘金作者“我是你的超级英雄”在[深入剖析：Vue核心之虚拟DOM](https://juejin.im/post/5d36cc575188257aea108a74) 一文中的描述：\n\n> 所有的浏览器渲染引擎工作流程大致分为5步：创建DOM 树 —> 创建 Style Rules -> 构建 Render 树 —> 布局 Layout -—> 绘制 Painting。\n> 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；\n> 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；\n> 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；\n> 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；\n> 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。\n\nDOM树是整个页面的骨架，承载着内容和结构的任务，而当下的Web开发会有大量与DOM树交互的需要，因此，虚拟DOM和diff算法应运而生，先在虚拟DOM上更新，再diff后应用局部的更新，减少了直接操作DOM树带来的重绘与重排问题，有关diff算法会在下一篇文章中做分析。\n\n## Patch是何时执行的？\n\n当vnode和oldVnode都存在、oldVnode不是真实节点，并且vnode和oldVnode是同一节点时，才会调用patchVnode进行patch。\n\n## Patch/Update有哪些情况？\n\n这里我们只说明后续响应的情况：\n\n- 如果节点不同，则根据 __旧节点__ 参考使用 `nextSibling` 创建新节点并移除旧节点，其中Vue.js需要更新其中占位符节点（实际DOM节点）；\n- 如果节点相同，则更新vnode的属性并更新到实际节点，旧节点本质上仍然不变；\n- 如果节点存在子元素且子元素发生改变，则通过 `updateChildren` 更新子节点，这里可能会用到我们的key属性，进行快速比对diff。","source":"_posts/fe/从dom与虚拟dom了解vue和react是如何响应数据变化的.md","raw":"---\ntags:\n- Vue.js\ncategories: Frontend\ntitle: 从DOM与虚拟DOM了解Vue和React是如何响应数据变化的\ndate: 2020-01-08T00:00:00.000+08:00\nexcerpt: 提起MVVM框架，就不能不提到虚拟DOM，也正是由于虚拟DOM的存在，界面不再是一条条DOM操作驱动的，取而代之的是数据的改变，“自动”地驱动了DOM改变……\nthumbnail: ''\n\n---\n## 先说浏览器的渲染模式\n\n这里引用一段掘金作者“我是你的超级英雄”在[深入剖析：Vue核心之虚拟DOM](https://juejin.im/post/5d36cc575188257aea108a74) 一文中的描述：\n\n> 所有的浏览器渲染引擎工作流程大致分为5步：创建DOM 树 —> 创建 Style Rules -> 构建 Render 树 —> 布局 Layout -—> 绘制 Painting。\n> 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；\n> 第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；\n> 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；\n> 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；\n> 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。\n\nDOM树是整个页面的骨架，承载着内容和结构的任务，而当下的Web开发会有大量与DOM树交互的需要，因此，虚拟DOM和diff算法应运而生，先在虚拟DOM上更新，再diff后应用局部的更新，减少了直接操作DOM树带来的重绘与重排问题，有关diff算法会在下一篇文章中做分析。\n\n## Patch是何时执行的？\n\n当vnode和oldVnode都存在、oldVnode不是真实节点，并且vnode和oldVnode是同一节点时，才会调用patchVnode进行patch。\n\n## Patch/Update有哪些情况？\n\n这里我们只说明后续响应的情况：\n\n- 如果节点不同，则根据 __旧节点__ 参考使用 `nextSibling` 创建新节点并移除旧节点，其中Vue.js需要更新其中占位符节点（实际DOM节点）；\n- 如果节点相同，则更新vnode的属性并更新到实际节点，旧节点本质上仍然不变；\n- 如果节点存在子元素且子元素发生改变，则通过 `updateChildren` 更新子节点，这里可能会用到我们的key属性，进行快速比对diff。","slug":"fe/从dom与虚拟dom了解vue和react是如何响应数据变化的","published":1,"updated":"2020-08-01T18:21:52.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iat001mj1wtbtgibcqz","content":"<h2 id=\"先说浏览器的渲染模式\"><a href=\"#先说浏览器的渲染模式\" class=\"headerlink\" title=\"先说浏览器的渲染模式\"></a>先说浏览器的渲染模式</h2><p>这里引用一段掘金作者“我是你的超级英雄”在<a href=\"https://juejin.im/post/5d36cc575188257aea108a74\">深入剖析：Vue核心之虚拟DOM</a> 一文中的描述：</p>\n<blockquote>\n<p>所有的浏览器渲染引擎工作流程大致分为5步：创建DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting。<br>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；<br>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；<br>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；<br>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；<br>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。</p>\n</blockquote>\n<p>DOM树是整个页面的骨架，承载着内容和结构的任务，而当下的Web开发会有大量与DOM树交互的需要，因此，虚拟DOM和diff算法应运而生，先在虚拟DOM上更新，再diff后应用局部的更新，减少了直接操作DOM树带来的重绘与重排问题，有关diff算法会在下一篇文章中做分析。</p>\n<h2 id=\"Patch是何时执行的？\"><a href=\"#Patch是何时执行的？\" class=\"headerlink\" title=\"Patch是何时执行的？\"></a>Patch是何时执行的？</h2><p>当vnode和oldVnode都存在、oldVnode不是真实节点，并且vnode和oldVnode是同一节点时，才会调用patchVnode进行patch。</p>\n<h2 id=\"Patch-Update有哪些情况？\"><a href=\"#Patch-Update有哪些情况？\" class=\"headerlink\" title=\"Patch/Update有哪些情况？\"></a>Patch/Update有哪些情况？</h2><p>这里我们只说明后续响应的情况：</p>\n<ul>\n<li>如果节点不同，则根据 <strong>旧节点</strong> 参考使用 <code>nextSibling</code> 创建新节点并移除旧节点，其中Vue.js需要更新其中占位符节点（实际DOM节点）；</li>\n<li>如果节点相同，则更新vnode的属性并更新到实际节点，旧节点本质上仍然不变；</li>\n<li>如果节点存在子元素且子元素发生改变，则通过 <code>updateChildren</code> 更新子节点，这里可能会用到我们的key属性，进行快速比对diff。</li>\n</ul>\n","site":{"data":{}},"more":"<h2 id=\"先说浏览器的渲染模式\"><a href=\"#先说浏览器的渲染模式\" class=\"headerlink\" title=\"先说浏览器的渲染模式\"></a>先说浏览器的渲染模式</h2><p>这里引用一段掘金作者“我是你的超级英雄”在<a href=\"https://juejin.im/post/5d36cc575188257aea108a74\">深入剖析：Vue核心之虚拟DOM</a> 一文中的描述：</p>\n<blockquote>\n<p>所有的浏览器渲染引擎工作流程大致分为5步：创建DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting。<br>第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；<br>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；<br>第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；<br>第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；<br>第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。</p>\n</blockquote>\n<p>DOM树是整个页面的骨架，承载着内容和结构的任务，而当下的Web开发会有大量与DOM树交互的需要，因此，虚拟DOM和diff算法应运而生，先在虚拟DOM上更新，再diff后应用局部的更新，减少了直接操作DOM树带来的重绘与重排问题，有关diff算法会在下一篇文章中做分析。</p>\n<h2 id=\"Patch是何时执行的？\"><a href=\"#Patch是何时执行的？\" class=\"headerlink\" title=\"Patch是何时执行的？\"></a>Patch是何时执行的？</h2><p>当vnode和oldVnode都存在、oldVnode不是真实节点，并且vnode和oldVnode是同一节点时，才会调用patchVnode进行patch。</p>\n<h2 id=\"Patch-Update有哪些情况？\"><a href=\"#Patch-Update有哪些情况？\" class=\"headerlink\" title=\"Patch/Update有哪些情况？\"></a>Patch/Update有哪些情况？</h2><p>这里我们只说明后续响应的情况：</p>\n<ul>\n<li>如果节点不同，则根据 <strong>旧节点</strong> 参考使用 <code>nextSibling</code> 创建新节点并移除旧节点，其中Vue.js需要更新其中占位符节点（实际DOM节点）；</li>\n<li>如果节点相同，则更新vnode的属性并更新到实际节点，旧节点本质上仍然不变；</li>\n<li>如果节点存在子元素且子元素发生改变，则通过 <code>updateChildren</code> 更新子节点，这里可能会用到我们的key属性，进行快速比对diff。</li>\n</ul>\n"},{"title":"Task, Job 与 EventLoop","date":"2019-08-20T08:00:00.000Z","excerpt":"经久不衰的话题，我找到了一篇非常有趣的解释文章，详细说明了其中的区别，争取一文讲通JavaScript的循环机制！","thumbnail":"","_content":"#### 在解释事件循环前……\n\n```javascript\nfunction foo(b) {\n  var a = 10;\n  return a + b + 11;\n}\n\nfunction bar(x) {\n  var y = 3;\n  return foo(x * y);\n}\n\nconsole.log(bar(7)); // 返回 42\n```\n\n这段代码存在这样的过程：\n\n1. console.log调用bar -> 创建了第一个帧\n\n2. bar调用foo -> 创建了第二个帧，并被压倒第一个帧上\n\n3. foo完成并返回 -> 最上层帧弹出栈\n\n4. bar完成并返回 -> 出栈，栈空\n\n#### javascript在什么时候会用到队列呢？\n\n一个 JavaScript 运行时包含了一个 **待处理的消息队列** 。每一个消息都关联着一个用以处理这个消息的函数。\n\n在事件循环期间的某个时刻，运行时从 **最先进入队列的消息开始处理队列中的消息** 。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\n\n#### 回到正题\n\n根据 [HTML Standard](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops). 这里的宏任务（旧称macrotask）现统称为task，其定义为：\n\n> a task is a struct which has:\n> \\- **Steps**\n> A series of steps specifying the work to be done by the task.\n> \\- **A source**\n> One of the task sources, used to group and serialize related tasks.\n> \\- **A document**\n> A Document associated with the task, or null for tasks that are not in a window event loop.\n> \\- **A script evaluation environment settings object set**\n> A set of environment settings objects used for tracking script evaluation during the task.\n> A task is runnable if its document is either null or fully active.\n\n翻译过来就是一个具有指定步骤、具有一个源、上下文或者null（此时使用window event loop）、一系列追踪脚本运行的对象的结构。\n\n而微任务依然是microtask，其定义为：\n\n> A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 译：微任务是指通过队列微任务算法创建的任务的口语方式。\n\n#### 举个例子\n\n这里感谢Jiasm的例子[微任务、宏任务与Event-Loop](https://juejin.im/post/5b73d7a6518825610072b42b),\n对于一段JS代码而言，在JS的执行阶段是要逐步执行的，那么执行到一些需要等时的方法时，我就不可能去等待这些方法到来，等到你到来的时候我们再排队；\n那么对于一个方法（macrotask）而言，其内部可能存在多个额外的“业务”：\n\n```javascript\nsetTimeout(_ => console.log(4))\n\nnew Promise(resolve => {\n  resolve()\n  console.log(1)\n}).then(_ => {\n  console.log(3)\n})\n\nconsole.log(2)\n// finally log 1,2,3,4\n```\n\n这里需要注意，setTimeout是宏任务，而Promise.then是一个标准的微任务，**在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。**\n\n> [Promise A+规范](https://promisesaplus.com/#notes)里特别标注，这里Promise要取决于平台和引擎自身：This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.\n\n目前比较流行的实现标准里，宏任务有：\n\n|  | Browser | Node.js |\n| --- | --- | --- |\n| I/O | Yes | Yes |\n| setTimeout/setInterval | Yes | Yes |\n| setImmediate | No | Yes |\n| requestAnimationFrame | Yes | No |\n\n常见的微任务有：`process.nextTick`,`MutationObserver`,`Promise.then/catch/finally`\n\n#### 回到EventLoop-事件循环\n\n有一个非常好的动画来解释为什么是这样的执行顺序 [Who's right?](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight)","source":"_posts/fe/task-job-与-eventloop.md","raw":"---\ntags:\n- JavaScript\ncategories: Frontend\ntitle: Task, Job 与 EventLoop\ndate: 2019-08-20T16:00:00.000+00:00\nexcerpt: 经久不衰的话题，我找到了一篇非常有趣的解释文章，详细说明了其中的区别，争取一文讲通JavaScript的循环机制！\nthumbnail: ''\n\n---\n#### 在解释事件循环前……\n\n```javascript\nfunction foo(b) {\n  var a = 10;\n  return a + b + 11;\n}\n\nfunction bar(x) {\n  var y = 3;\n  return foo(x * y);\n}\n\nconsole.log(bar(7)); // 返回 42\n```\n\n这段代码存在这样的过程：\n\n1. console.log调用bar -> 创建了第一个帧\n\n2. bar调用foo -> 创建了第二个帧，并被压倒第一个帧上\n\n3. foo完成并返回 -> 最上层帧弹出栈\n\n4. bar完成并返回 -> 出栈，栈空\n\n#### javascript在什么时候会用到队列呢？\n\n一个 JavaScript 运行时包含了一个 **待处理的消息队列** 。每一个消息都关联着一个用以处理这个消息的函数。\n\n在事件循环期间的某个时刻，运行时从 **最先进入队列的消息开始处理队列中的消息** 。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\n\n#### 回到正题\n\n根据 [HTML Standard](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops). 这里的宏任务（旧称macrotask）现统称为task，其定义为：\n\n> a task is a struct which has:\n> \\- **Steps**\n> A series of steps specifying the work to be done by the task.\n> \\- **A source**\n> One of the task sources, used to group and serialize related tasks.\n> \\- **A document**\n> A Document associated with the task, or null for tasks that are not in a window event loop.\n> \\- **A script evaluation environment settings object set**\n> A set of environment settings objects used for tracking script evaluation during the task.\n> A task is runnable if its document is either null or fully active.\n\n翻译过来就是一个具有指定步骤、具有一个源、上下文或者null（此时使用window event loop）、一系列追踪脚本运行的对象的结构。\n\n而微任务依然是microtask，其定义为：\n\n> A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 译：微任务是指通过队列微任务算法创建的任务的口语方式。\n\n#### 举个例子\n\n这里感谢Jiasm的例子[微任务、宏任务与Event-Loop](https://juejin.im/post/5b73d7a6518825610072b42b),\n对于一段JS代码而言，在JS的执行阶段是要逐步执行的，那么执行到一些需要等时的方法时，我就不可能去等待这些方法到来，等到你到来的时候我们再排队；\n那么对于一个方法（macrotask）而言，其内部可能存在多个额外的“业务”：\n\n```javascript\nsetTimeout(_ => console.log(4))\n\nnew Promise(resolve => {\n  resolve()\n  console.log(1)\n}).then(_ => {\n  console.log(3)\n})\n\nconsole.log(2)\n// finally log 1,2,3,4\n```\n\n这里需要注意，setTimeout是宏任务，而Promise.then是一个标准的微任务，**在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。**\n\n> [Promise A+规范](https://promisesaplus.com/#notes)里特别标注，这里Promise要取决于平台和引擎自身：This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.\n\n目前比较流行的实现标准里，宏任务有：\n\n|  | Browser | Node.js |\n| --- | --- | --- |\n| I/O | Yes | Yes |\n| setTimeout/setInterval | Yes | Yes |\n| setImmediate | No | Yes |\n| requestAnimationFrame | Yes | No |\n\n常见的微任务有：`process.nextTick`,`MutationObserver`,`Promise.then/catch/finally`\n\n#### 回到EventLoop-事件循环\n\n有一个非常好的动画来解释为什么是这样的执行顺序 [Who's right?](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight)","slug":"fe/task-job-与-eventloop","published":1,"updated":"2020-08-01T18:21:52.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iau001qj1wt8gok0aql","content":"<h4 id=\"在解释事件循环前……\"><a href=\"#在解释事件循环前……\" class=\"headerlink\" title=\"在解释事件循环前……\"></a>在解释事件循环前……</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + <span class=\"number\">11</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> foo(x * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar(<span class=\"number\">7</span>)); <span class=\"comment\">// 返回 42</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码存在这样的过程：</p>\n<ol>\n<li><p>console.log调用bar -&gt; 创建了第一个帧</p>\n</li>\n<li><p>bar调用foo -&gt; 创建了第二个帧，并被压倒第一个帧上</p>\n</li>\n<li><p>foo完成并返回 -&gt; 最上层帧弹出栈</p>\n</li>\n<li><p>bar完成并返回 -&gt; 出栈，栈空</p>\n</li>\n</ol>\n<h4 id=\"javascript在什么时候会用到队列呢？\"><a href=\"#javascript在什么时候会用到队列呢？\" class=\"headerlink\" title=\"javascript在什么时候会用到队列呢？\"></a>javascript在什么时候会用到队列呢？</h4><p>一个 JavaScript 运行时包含了一个 <strong>待处理的消息队列</strong> 。每一个消息都关联着一个用以处理这个消息的函数。</p>\n<p>在事件循环期间的某个时刻，运行时从 <strong>最先进入队列的消息开始处理队列中的消息</strong> 。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>\n<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>\n<h4 id=\"回到正题\"><a href=\"#回到正题\" class=\"headerlink\" title=\"回到正题\"></a>回到正题</h4><p>根据 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\">HTML Standard</a>. 这里的宏任务（旧称macrotask）现统称为task，其定义为：</p>\n<blockquote>\n<p>a task is a struct which has:<br>- <strong>Steps</strong><br>A series of steps specifying the work to be done by the task.<br>- <strong>A source</strong><br>One of the task sources, used to group and serialize related tasks.<br>- <strong>A document</strong><br>A Document associated with the task, or null for tasks that are not in a window event loop.<br>- <strong>A script evaluation environment settings object set</strong><br>A set of environment settings objects used for tracking script evaluation during the task.<br>A task is runnable if its document is either null or fully active.</p>\n</blockquote>\n<p>翻译过来就是一个具有指定步骤、具有一个源、上下文或者null（此时使用window event loop）、一系列追踪脚本运行的对象的结构。</p>\n<p>而微任务依然是microtask，其定义为：</p>\n<blockquote>\n<p>A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 译：微任务是指通过队列微任务算法创建的任务的口语方式。</p>\n</blockquote>\n<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p>这里感谢Jiasm的例子<a href=\"https://juejin.im/post/5b73d7a6518825610072b42b\">微任务、宏任务与Event-Loop</a>,<br>对于一段JS代码而言，在JS的执行阶段是要逐步执行的，那么执行到一些需要等时的方法时，我就不可能去等待这些方法到来，等到你到来的时候我们再排队；<br>那么对于一个方法（macrotask）而言，其内部可能存在多个额外的“业务”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// finally log 1,2,3,4</span></span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意，setTimeout是宏任务，而Promise.then是一个标准的微任务，<strong>在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。</strong></p>\n<blockquote>\n<p><a href=\"https://promisesaplus.com/#notes\">Promise A+规范</a>里特别标注，这里Promise要取决于平台和引擎自身：This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p>\n</blockquote>\n<p>目前比较流行的实现标准里，宏任务有：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Browser</th>\n<th>Node.js</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I/O</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>setTimeout/setInterval</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>setImmediate</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>requestAnimationFrame</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>常见的微任务有：<code>process.nextTick</code>,<code>MutationObserver</code>,<code>Promise.then/catch/finally</code></p>\n<h4 id=\"回到EventLoop-事件循环\"><a href=\"#回到EventLoop-事件循环\" class=\"headerlink\" title=\"回到EventLoop-事件循环\"></a>回到EventLoop-事件循环</h4><p>有一个非常好的动画来解释为什么是这样的执行顺序 <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight\">Who’s right?</a></p>\n","site":{"data":{}},"more":"<h4 id=\"在解释事件循环前……\"><a href=\"#在解释事件循环前……\" class=\"headerlink\" title=\"在解释事件循环前……\"></a>在解释事件循环前……</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + <span class=\"number\">11</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> foo(x * y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar(<span class=\"number\">7</span>)); <span class=\"comment\">// 返回 42</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码存在这样的过程：</p>\n<ol>\n<li><p>console.log调用bar -&gt; 创建了第一个帧</p>\n</li>\n<li><p>bar调用foo -&gt; 创建了第二个帧，并被压倒第一个帧上</p>\n</li>\n<li><p>foo完成并返回 -&gt; 最上层帧弹出栈</p>\n</li>\n<li><p>bar完成并返回 -&gt; 出栈，栈空</p>\n</li>\n</ol>\n<h4 id=\"javascript在什么时候会用到队列呢？\"><a href=\"#javascript在什么时候会用到队列呢？\" class=\"headerlink\" title=\"javascript在什么时候会用到队列呢？\"></a>javascript在什么时候会用到队列呢？</h4><p>一个 JavaScript 运行时包含了一个 <strong>待处理的消息队列</strong> 。每一个消息都关联着一个用以处理这个消息的函数。</p>\n<p>在事件循环期间的某个时刻，运行时从 <strong>最先进入队列的消息开始处理队列中的消息</strong> 。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。</p>\n<p>函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。</p>\n<h4 id=\"回到正题\"><a href=\"#回到正题\" class=\"headerlink\" title=\"回到正题\"></a>回到正题</h4><p>根据 <a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\">HTML Standard</a>. 这里的宏任务（旧称macrotask）现统称为task，其定义为：</p>\n<blockquote>\n<p>a task is a struct which has:<br>- <strong>Steps</strong><br>A series of steps specifying the work to be done by the task.<br>- <strong>A source</strong><br>One of the task sources, used to group and serialize related tasks.<br>- <strong>A document</strong><br>A Document associated with the task, or null for tasks that are not in a window event loop.<br>- <strong>A script evaluation environment settings object set</strong><br>A set of environment settings objects used for tracking script evaluation during the task.<br>A task is runnable if its document is either null or fully active.</p>\n</blockquote>\n<p>翻译过来就是一个具有指定步骤、具有一个源、上下文或者null（此时使用window event loop）、一系列追踪脚本运行的对象的结构。</p>\n<p>而微任务依然是microtask，其定义为：</p>\n<blockquote>\n<p>A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 译：微任务是指通过队列微任务算法创建的任务的口语方式。</p>\n</blockquote>\n<h4 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h4><p>这里感谢Jiasm的例子<a href=\"https://juejin.im/post/5b73d7a6518825610072b42b\">微任务、宏任务与Event-Loop</a>,<br>对于一段JS代码而言，在JS的执行阶段是要逐步执行的，那么执行到一些需要等时的方法时，我就不可能去等待这些方法到来，等到你到来的时候我们再排队；<br>那么对于一个方法（macrotask）而言，其内部可能存在多个额外的“业务”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">  resolve()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">_</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// finally log 1,2,3,4</span></span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意，setTimeout是宏任务，而Promise.then是一个标准的微任务，<strong>在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。</strong></p>\n<blockquote>\n<p><a href=\"https://promisesaplus.com/#notes\">Promise A+规范</a>里特别标注，这里Promise要取决于平台和引擎自身：This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p>\n</blockquote>\n<p>目前比较流行的实现标准里，宏任务有：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Browser</th>\n<th>Node.js</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I/O</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>setTimeout/setInterval</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>setImmediate</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>requestAnimationFrame</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n</tbody></table>\n<p>常见的微任务有：<code>process.nextTick</code>,<code>MutationObserver</code>,<code>Promise.then/catch/finally</code></p>\n<h4 id=\"回到EventLoop-事件循环\"><a href=\"#回到EventLoop-事件循环\" class=\"headerlink\" title=\"回到EventLoop-事件循环\"></a>回到EventLoop-事件循环</h4><p>有一个非常好的动画来解释为什么是这样的执行顺序 <a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight\">Who’s right?</a></p>\n"},{"title":"养成好习惯 - HTML语义化","date":"2019-08-11T08:00:00.000Z","excerpt":"在平时开发时，尽量使用语义化的标签，利人利己。","thumbnail":"","_content":"### 何为语义化？\n\n> 语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。\n\n做一个比较而言，Markdown导出的html结构就是符合大部分语义化的做法，即便在没有样式时，通过浏览器基础的样式和解析，整个页面仍保持构想的文档结构，能够维持较为清晰的页面结构，对我而言，就需要注意标签的使用。\n\n### 语义化常使用的标签\n\n##### meta信息\n- title\n  `title`标签指定了文档对外的标题，建议一般显示为 *窗口标题 / 历史记录 / 搜索结果标题 / ...*\n- lang\n  `lang`指定了内容的语言\n- meta\n  `meta`元素中，name决定了文档种类，content表示内容，标准情况下应包括`application-name, author, description, generator, keywords`\n  \n###### 链接\n- link\n  `link`元素必须包括rel和href属性，用来描述文档本身与其他资源的关系\n- a\n  `a`元素在存在href时为超链接，无href为链接占位符，可以添加rel属性使其兼容浏览器的阅读模式（如rel=\"prev\"显示为分页器）\n\n##### 区块\n- article\n  `article`标签可以用于独立的文档、页面等，可以单独发布、重用等内容\n- section \n  `section`一般是按主题将内容分组，通常会有标题，但本身并非语义化的div，它通常用于将内容体现在文档等提纲中\n- nav\n  `nav`是一个包含导航链接等自然节，它可以帮助UA快速获得导航内容，其内部不一定使用ul，也可使用自然文本\n- aside\n  `aside`也是块级元素，它通常表示与周围内容关系不大密切等内容，可以用来做侧边栏等容器等\n- h1-h6\n  标题元素日常常用，需要注意覆盖浏览器默认样式\n- header/footer\n  `header`\n  `footer`元素与header类似，代表最近的父级区块内容的页脚，同样不影响文档提纲\n\n##### 内容分组\n- p\n  段落是主题接近的若干句子组成等文本块，如果段落没有特指，考虑使用p\n- ol/ul/li\n  需要注意，列表有序和无序在默认表现下不同，ol内的li可以设置value代表该列表项的序号值\n- dl/dt/dd\n  MDN对此元素的定义是：*一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。*\n  因此最好能够使用在能够体现键值对的情况\n- figure&figcaption\n  `figure`元素是比较独立的，被主要引用的图片、插图、照片代码等，一般会有一个标题，即`figcaption`\n- div\n  最常用也是最滥用的元素，其本身无语义，可以和类名、id、title等结合，但是是最后考虑的选择。\n  *尤其是涉及dom操作时，通过类名选择div需要遍历整个页面所有的div，性能上也会大量损耗*\n\n##### 文本\n- em/strong\n  一般表示侧重点的强调，会因嵌套层数改变强调级别，一般渲染为斜体\n- i\n  可作为画外音等等杂项，建议与class、lang一同使用\n- small\n  不止作为小字使用，可以作为注意或声明使用\n- cite\n  作为引述的作品标题、文章论文等标题\n- mark\n  不常用，但可以作为与用户当前的行为相关的内容，如高亮显示搜索关键词\n\n##### 嵌入内容\n- img\n  `img`要注意src和alt的使用，其中：\n  - 有 src 且 alt 为空字符串，代表装饰用图\n  - 有 src 且 alt 为非空字符串，图为文档内容的一部分\n  - 有 src 且无 alt，图为内容一部分但无等价的文本内容可用","source":"_posts/fe/养成好习惯-html语义化.md","raw":"---\ntags:\n- 前端\ncategories: Frontend\ntitle: 养成好习惯 - HTML语义化\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: 在平时开发时，尽量使用语义化的标签，利人利己。\nthumbnail: ''\n\n---\n### 何为语义化？\n\n> 语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。\n\n做一个比较而言，Markdown导出的html结构就是符合大部分语义化的做法，即便在没有样式时，通过浏览器基础的样式和解析，整个页面仍保持构想的文档结构，能够维持较为清晰的页面结构，对我而言，就需要注意标签的使用。\n\n### 语义化常使用的标签\n\n##### meta信息\n- title\n  `title`标签指定了文档对外的标题，建议一般显示为 *窗口标题 / 历史记录 / 搜索结果标题 / ...*\n- lang\n  `lang`指定了内容的语言\n- meta\n  `meta`元素中，name决定了文档种类，content表示内容，标准情况下应包括`application-name, author, description, generator, keywords`\n  \n###### 链接\n- link\n  `link`元素必须包括rel和href属性，用来描述文档本身与其他资源的关系\n- a\n  `a`元素在存在href时为超链接，无href为链接占位符，可以添加rel属性使其兼容浏览器的阅读模式（如rel=\"prev\"显示为分页器）\n\n##### 区块\n- article\n  `article`标签可以用于独立的文档、页面等，可以单独发布、重用等内容\n- section \n  `section`一般是按主题将内容分组，通常会有标题，但本身并非语义化的div，它通常用于将内容体现在文档等提纲中\n- nav\n  `nav`是一个包含导航链接等自然节，它可以帮助UA快速获得导航内容，其内部不一定使用ul，也可使用自然文本\n- aside\n  `aside`也是块级元素，它通常表示与周围内容关系不大密切等内容，可以用来做侧边栏等容器等\n- h1-h6\n  标题元素日常常用，需要注意覆盖浏览器默认样式\n- header/footer\n  `header`\n  `footer`元素与header类似，代表最近的父级区块内容的页脚，同样不影响文档提纲\n\n##### 内容分组\n- p\n  段落是主题接近的若干句子组成等文本块，如果段落没有特指，考虑使用p\n- ol/ul/li\n  需要注意，列表有序和无序在默认表现下不同，ol内的li可以设置value代表该列表项的序号值\n- dl/dt/dd\n  MDN对此元素的定义是：*一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。*\n  因此最好能够使用在能够体现键值对的情况\n- figure&figcaption\n  `figure`元素是比较独立的，被主要引用的图片、插图、照片代码等，一般会有一个标题，即`figcaption`\n- div\n  最常用也是最滥用的元素，其本身无语义，可以和类名、id、title等结合，但是是最后考虑的选择。\n  *尤其是涉及dom操作时，通过类名选择div需要遍历整个页面所有的div，性能上也会大量损耗*\n\n##### 文本\n- em/strong\n  一般表示侧重点的强调，会因嵌套层数改变强调级别，一般渲染为斜体\n- i\n  可作为画外音等等杂项，建议与class、lang一同使用\n- small\n  不止作为小字使用，可以作为注意或声明使用\n- cite\n  作为引述的作品标题、文章论文等标题\n- mark\n  不常用，但可以作为与用户当前的行为相关的内容，如高亮显示搜索关键词\n\n##### 嵌入内容\n- img\n  `img`要注意src和alt的使用，其中：\n  - 有 src 且 alt 为空字符串，代表装饰用图\n  - 有 src 且 alt 为非空字符串，图为文档内容的一部分\n  - 有 src 且无 alt，图为内容一部分但无等价的文本内容可用","slug":"fe/养成好习惯-html语义化","published":1,"updated":"2020-08-01T18:21:52.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iav001tj1wtgt4h7g28","content":"<h3 id=\"何为语义化？\"><a href=\"#何为语义化？\" class=\"headerlink\" title=\"何为语义化？\"></a>何为语义化？</h3><blockquote>\n<p>语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。</p>\n</blockquote>\n<p>做一个比较而言，Markdown导出的html结构就是符合大部分语义化的做法，即便在没有样式时，通过浏览器基础的样式和解析，整个页面仍保持构想的文档结构，能够维持较为清晰的页面结构，对我而言，就需要注意标签的使用。</p>\n<h3 id=\"语义化常使用的标签\"><a href=\"#语义化常使用的标签\" class=\"headerlink\" title=\"语义化常使用的标签\"></a>语义化常使用的标签</h3><h5 id=\"meta信息\"><a href=\"#meta信息\" class=\"headerlink\" title=\"meta信息\"></a>meta信息</h5><ul>\n<li>title<br><code>title</code>标签指定了文档对外的标题，建议一般显示为 <em>窗口标题 / 历史记录 / 搜索结果标题 / …</em></li>\n<li>lang<br><code>lang</code>指定了内容的语言</li>\n<li>meta<br><code>meta</code>元素中，name决定了文档种类，content表示内容，标准情况下应包括<code>application-name, author, description, generator, keywords</code></li>\n</ul>\n<h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><ul>\n<li>link<br><code>link</code>元素必须包括rel和href属性，用来描述文档本身与其他资源的关系</li>\n<li>a<br><code>a</code>元素在存在href时为超链接，无href为链接占位符，可以添加rel属性使其兼容浏览器的阅读模式（如rel=”prev”显示为分页器）</li>\n</ul>\n<h5 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h5><ul>\n<li>article<br><code>article</code>标签可以用于独立的文档、页面等，可以单独发布、重用等内容</li>\n<li>section<br><code>section</code>一般是按主题将内容分组，通常会有标题，但本身并非语义化的div，它通常用于将内容体现在文档等提纲中</li>\n<li>nav<br><code>nav</code>是一个包含导航链接等自然节，它可以帮助UA快速获得导航内容，其内部不一定使用ul，也可使用自然文本</li>\n<li>aside<br><code>aside</code>也是块级元素，它通常表示与周围内容关系不大密切等内容，可以用来做侧边栏等容器等</li>\n<li>h1-h6<br>标题元素日常常用，需要注意覆盖浏览器默认样式</li>\n<li>header/footer<br><code>header</code><br><code>footer</code>元素与header类似，代表最近的父级区块内容的页脚，同样不影响文档提纲</li>\n</ul>\n<h5 id=\"内容分组\"><a href=\"#内容分组\" class=\"headerlink\" title=\"内容分组\"></a>内容分组</h5><ul>\n<li>p<br>段落是主题接近的若干句子组成等文本块，如果段落没有特指，考虑使用p</li>\n<li>ol/ul/li<br>需要注意，列表有序和无序在默认表现下不同，ol内的li可以设置value代表该列表项的序号值</li>\n<li>dl/dt/dd<br>MDN对此元素的定义是：<em>一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。</em><br>因此最好能够使用在能够体现键值对的情况</li>\n<li>figure&amp;figcaption<br><code>figure</code>元素是比较独立的，被主要引用的图片、插图、照片代码等，一般会有一个标题，即<code>figcaption</code></li>\n<li>div<br>最常用也是最滥用的元素，其本身无语义，可以和类名、id、title等结合，但是是最后考虑的选择。<br><em>尤其是涉及dom操作时，通过类名选择div需要遍历整个页面所有的div，性能上也会大量损耗</em></li>\n</ul>\n<h5 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h5><ul>\n<li>em/strong<br>一般表示侧重点的强调，会因嵌套层数改变强调级别，一般渲染为斜体</li>\n<li>i<br>可作为画外音等等杂项，建议与class、lang一同使用</li>\n<li>small<br>不止作为小字使用，可以作为注意或声明使用</li>\n<li>cite<br>作为引述的作品标题、文章论文等标题</li>\n<li>mark<br>不常用，但可以作为与用户当前的行为相关的内容，如高亮显示搜索关键词</li>\n</ul>\n<h5 id=\"嵌入内容\"><a href=\"#嵌入内容\" class=\"headerlink\" title=\"嵌入内容\"></a>嵌入内容</h5><ul>\n<li>img<br><code>img</code>要注意src和alt的使用，其中：<ul>\n<li>有 src 且 alt 为空字符串，代表装饰用图</li>\n<li>有 src 且 alt 为非空字符串，图为文档内容的一部分</li>\n<li>有 src 且无 alt，图为内容一部分但无等价的文本内容可用</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"more":"<h3 id=\"何为语义化？\"><a href=\"#何为语义化？\" class=\"headerlink\" title=\"何为语义化？\"></a>何为语义化？</h3><blockquote>\n<p>语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。</p>\n</blockquote>\n<p>做一个比较而言，Markdown导出的html结构就是符合大部分语义化的做法，即便在没有样式时，通过浏览器基础的样式和解析，整个页面仍保持构想的文档结构，能够维持较为清晰的页面结构，对我而言，就需要注意标签的使用。</p>\n<h3 id=\"语义化常使用的标签\"><a href=\"#语义化常使用的标签\" class=\"headerlink\" title=\"语义化常使用的标签\"></a>语义化常使用的标签</h3><h5 id=\"meta信息\"><a href=\"#meta信息\" class=\"headerlink\" title=\"meta信息\"></a>meta信息</h5><ul>\n<li>title<br><code>title</code>标签指定了文档对外的标题，建议一般显示为 <em>窗口标题 / 历史记录 / 搜索结果标题 / …</em></li>\n<li>lang<br><code>lang</code>指定了内容的语言</li>\n<li>meta<br><code>meta</code>元素中，name决定了文档种类，content表示内容，标准情况下应包括<code>application-name, author, description, generator, keywords</code></li>\n</ul>\n<h6 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h6><ul>\n<li>link<br><code>link</code>元素必须包括rel和href属性，用来描述文档本身与其他资源的关系</li>\n<li>a<br><code>a</code>元素在存在href时为超链接，无href为链接占位符，可以添加rel属性使其兼容浏览器的阅读模式（如rel=”prev”显示为分页器）</li>\n</ul>\n<h5 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h5><ul>\n<li>article<br><code>article</code>标签可以用于独立的文档、页面等，可以单独发布、重用等内容</li>\n<li>section<br><code>section</code>一般是按主题将内容分组，通常会有标题，但本身并非语义化的div，它通常用于将内容体现在文档等提纲中</li>\n<li>nav<br><code>nav</code>是一个包含导航链接等自然节，它可以帮助UA快速获得导航内容，其内部不一定使用ul，也可使用自然文本</li>\n<li>aside<br><code>aside</code>也是块级元素，它通常表示与周围内容关系不大密切等内容，可以用来做侧边栏等容器等</li>\n<li>h1-h6<br>标题元素日常常用，需要注意覆盖浏览器默认样式</li>\n<li>header/footer<br><code>header</code><br><code>footer</code>元素与header类似，代表最近的父级区块内容的页脚，同样不影响文档提纲</li>\n</ul>\n<h5 id=\"内容分组\"><a href=\"#内容分组\" class=\"headerlink\" title=\"内容分组\"></a>内容分组</h5><ul>\n<li>p<br>段落是主题接近的若干句子组成等文本块，如果段落没有特指，考虑使用p</li>\n<li>ol/ul/li<br>需要注意，列表有序和无序在默认表现下不同，ol内的li可以设置value代表该列表项的序号值</li>\n<li>dl/dt/dd<br>MDN对此元素的定义是：<em>一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。</em><br>因此最好能够使用在能够体现键值对的情况</li>\n<li>figure&amp;figcaption<br><code>figure</code>元素是比较独立的，被主要引用的图片、插图、照片代码等，一般会有一个标题，即<code>figcaption</code></li>\n<li>div<br>最常用也是最滥用的元素，其本身无语义，可以和类名、id、title等结合，但是是最后考虑的选择。<br><em>尤其是涉及dom操作时，通过类名选择div需要遍历整个页面所有的div，性能上也会大量损耗</em></li>\n</ul>\n<h5 id=\"文本\"><a href=\"#文本\" class=\"headerlink\" title=\"文本\"></a>文本</h5><ul>\n<li>em/strong<br>一般表示侧重点的强调，会因嵌套层数改变强调级别，一般渲染为斜体</li>\n<li>i<br>可作为画外音等等杂项，建议与class、lang一同使用</li>\n<li>small<br>不止作为小字使用，可以作为注意或声明使用</li>\n<li>cite<br>作为引述的作品标题、文章论文等标题</li>\n<li>mark<br>不常用，但可以作为与用户当前的行为相关的内容，如高亮显示搜索关键词</li>\n</ul>\n<h5 id=\"嵌入内容\"><a href=\"#嵌入内容\" class=\"headerlink\" title=\"嵌入内容\"></a>嵌入内容</h5><ul>\n<li>img<br><code>img</code>要注意src和alt的使用，其中：<ul>\n<li>有 src 且 alt 为空字符串，代表装饰用图</li>\n<li>有 src 且 alt 为非空字符串，图为文档内容的一部分</li>\n<li>有 src 且无 alt，图为内容一部分但无等价的文本内容可用</li>\n</ul>\n</li>\n</ul>\n"},{"title":"利用CSS写一个可高度自定义的多行文本自动省略Vue组件","date":"2019-08-11T08:00:00.000Z","excerpt":"对于展示型页面，多行文本省略非常常见，但是实现时往往要通过嵌套，而且并不够足够精确，这里借鉴一位前辈的方案实现一个小的Vue组件实现多行省略。","thumbnail":"","_content":"目前对于文本溢出是通过\n```CSS\n/* 单行 */\ntext-overflow:ellipse;\n/* 多行 */\noverflow : hidden;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n```\n\n但这两种方法仅限于截断后在末尾添加省略号，如果有类似这样的需求，既不是纯色背景，又不能使用渐变的时候，就不容易计算末尾处如何控制溢出\n\n这里引用[大神hi](http://hai.li/2017/03/08/css-multiline-overflow-ellipsis.html)的解决方法，仅使用css解决这个问题，本文使用 _Vue + Stylus_ 完成这个方案\n\n首先分析这个组件应该具备的扩展性，它应该可以定制最大行数、行高，也需要规定更多部分的宽度大小，同时应该提供内容以及更多的html片段[插槽](https://cn.vuejs.org/v2/guide/components-slots.html#ad)(不清楚的同学请猛戳左侧链接~)，这里我先定义它的props:\n```javascript\nexport default {\n  name : 'mutiLinesEllipsis',\n  props: {\n    lineHeight : {\n      type : Number\n    },\n    maxLines : {\n      type : Number\n    },\n    fontSize : {\n      type : Number\n    },\n    moreTextSize : {\n      type : Number\n    }\n  }\n}\n```\n那么有了以上的几个属性，我们开始组织我们的html结构\n\n### 盒子结构以及原理\n如图所示，这里利用了一个块元素检测左侧高度与整体高度，当文本超出时，整个内部高度被撑开，使得“更多”块有空间移动到左侧。\n\n```html\n<div class=\"mutiple-line\" :style=\"{'max-height':lineHeight*maxLines + 'px' , 'line-height':lineHeight+'px'}\">\n  <div class=\"ellipsis-container\" :style=\"{'-webkit-line-clamp':maxLines , 'font-size':moreTextSize + 'px'}\">\n    <div class=\"ellipsis-content\" :style=\"{'font-size':fontSize + 'px'}\"><slot></slot></div>\n    <div class=\"ellipsis-ghost\">\n      <div class=\"ellipsis-placeholder\" :style=\"{'height' : lineHeight*maxLines + 'px'}\"></div>\n      <div class=\"ellipsis-more\" :style=\"{'font-size':fontSize+'px', 'width':moreTextSize+'px', 'height':lineHeight+'px', 'margin-top':'-'+lineHeight+'px'}\">\n        <slot name=\"more-link\"></slot>\n      </div>\n    </div>\n  </div>\n</div>\n```\n\n```css\n// 基本的多行容器样式\n.mutiple-line \n  position: relative;\n  overflow: hidden;\n  width 100%\n  .ellipsis-container   \n    position: relative;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    color: transparent;\n  .ellipsis-content \n    color: #000;\n    display: inline;\n    vertical-align: top;\n  .ellipsis-ghost \n    position:absolute;\n    z-index: 1;\n    top: 0;\n    left: 50%;\n    width: 100%;\n    height: 100%;\n    color: #000;\n  .ellipsis-ghost:before\n    content: \"\";\n    display: block;\n    float: right;\n    width: 50%;\n    height: 100%;\n  .ellipsis-placeholder \n    content: \"\";\n    display: block;\n    float: right;\n    width: 50%;\n  .ellipsis-more \n    position: relative;\n    float: right;\n```\n\n利用Vue响应式的特点，如果这里需要做媒体查询等操作也是可以的，只需要改变传入参数即可，通用于任何Webkit内核浏览器(毕竟还是要依赖`-webkit-line-clamp`属性)","source":"_posts/fe/利用css写一个可高度自定义的多行文本自动省略vue组件.md","raw":"---\ntags:\n- CSS\ncategories: Frontend\ntitle: 利用CSS写一个可高度自定义的多行文本自动省略Vue组件\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: 对于展示型页面，多行文本省略非常常见，但是实现时往往要通过嵌套，而且并不够足够精确，这里借鉴一位前辈的方案实现一个小的Vue组件实现多行省略。\nthumbnail: ''\n\n---\n目前对于文本溢出是通过\n```CSS\n/* 单行 */\ntext-overflow:ellipse;\n/* 多行 */\noverflow : hidden;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n```\n\n但这两种方法仅限于截断后在末尾添加省略号，如果有类似这样的需求，既不是纯色背景，又不能使用渐变的时候，就不容易计算末尾处如何控制溢出\n\n这里引用[大神hi](http://hai.li/2017/03/08/css-multiline-overflow-ellipsis.html)的解决方法，仅使用css解决这个问题，本文使用 _Vue + Stylus_ 完成这个方案\n\n首先分析这个组件应该具备的扩展性，它应该可以定制最大行数、行高，也需要规定更多部分的宽度大小，同时应该提供内容以及更多的html片段[插槽](https://cn.vuejs.org/v2/guide/components-slots.html#ad)(不清楚的同学请猛戳左侧链接~)，这里我先定义它的props:\n```javascript\nexport default {\n  name : 'mutiLinesEllipsis',\n  props: {\n    lineHeight : {\n      type : Number\n    },\n    maxLines : {\n      type : Number\n    },\n    fontSize : {\n      type : Number\n    },\n    moreTextSize : {\n      type : Number\n    }\n  }\n}\n```\n那么有了以上的几个属性，我们开始组织我们的html结构\n\n### 盒子结构以及原理\n如图所示，这里利用了一个块元素检测左侧高度与整体高度，当文本超出时，整个内部高度被撑开，使得“更多”块有空间移动到左侧。\n\n```html\n<div class=\"mutiple-line\" :style=\"{'max-height':lineHeight*maxLines + 'px' , 'line-height':lineHeight+'px'}\">\n  <div class=\"ellipsis-container\" :style=\"{'-webkit-line-clamp':maxLines , 'font-size':moreTextSize + 'px'}\">\n    <div class=\"ellipsis-content\" :style=\"{'font-size':fontSize + 'px'}\"><slot></slot></div>\n    <div class=\"ellipsis-ghost\">\n      <div class=\"ellipsis-placeholder\" :style=\"{'height' : lineHeight*maxLines + 'px'}\"></div>\n      <div class=\"ellipsis-more\" :style=\"{'font-size':fontSize+'px', 'width':moreTextSize+'px', 'height':lineHeight+'px', 'margin-top':'-'+lineHeight+'px'}\">\n        <slot name=\"more-link\"></slot>\n      </div>\n    </div>\n  </div>\n</div>\n```\n\n```css\n// 基本的多行容器样式\n.mutiple-line \n  position: relative;\n  overflow: hidden;\n  width 100%\n  .ellipsis-container   \n    position: relative;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    color: transparent;\n  .ellipsis-content \n    color: #000;\n    display: inline;\n    vertical-align: top;\n  .ellipsis-ghost \n    position:absolute;\n    z-index: 1;\n    top: 0;\n    left: 50%;\n    width: 100%;\n    height: 100%;\n    color: #000;\n  .ellipsis-ghost:before\n    content: \"\";\n    display: block;\n    float: right;\n    width: 50%;\n    height: 100%;\n  .ellipsis-placeholder \n    content: \"\";\n    display: block;\n    float: right;\n    width: 50%;\n  .ellipsis-more \n    position: relative;\n    float: right;\n```\n\n利用Vue响应式的特点，如果这里需要做媒体查询等操作也是可以的，只需要改变传入参数即可，通用于任何Webkit内核浏览器(毕竟还是要依赖`-webkit-line-clamp`属性)","slug":"fe/利用css写一个可高度自定义的多行文本自动省略vue组件","published":1,"updated":"2020-08-01T18:21:52.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iaw001xj1wtanu15md3","content":"<p>目前对于文本溢出是通过</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 单行 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">text-overflow</span><span class=\"selector-pseudo\">:ellipse</span>;</span><br><span class=\"line\"><span class=\"comment\">/* 多行 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">overflow</span> : <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-overflow</span>: <span class=\"selector-tag\">ellipsis</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">-webkit-box</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-line-clamp</span>: 2;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-box-orient</span>: <span class=\"selector-tag\">vertical</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但这两种方法仅限于截断后在末尾添加省略号，如果有类似这样的需求，既不是纯色背景，又不能使用渐变的时候，就不容易计算末尾处如何控制溢出</p>\n<p>这里引用<a href=\"http://hai.li/2017/03/08/css-multiline-overflow-ellipsis.html\">大神hi</a>的解决方法，仅使用css解决这个问题，本文使用 <em>Vue + Stylus</em> 完成这个方案</p>\n<p>首先分析这个组件应该具备的扩展性，它应该可以定制最大行数、行高，也需要规定更多部分的宽度大小，同时应该提供内容以及更多的html片段<a href=\"https://cn.vuejs.org/v2/guide/components-slots.html#ad\">插槽</a>(不清楚的同学请猛戳左侧链接~)，这里我先定义它的props:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'mutiLinesEllipsis'</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    lineHeight : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    maxLines : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fontSize : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    moreTextSize : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么有了以上的几个属性，我们开始组织我们的html结构</p>\n<h3 id=\"盒子结构以及原理\"><a href=\"#盒子结构以及原理\" class=\"headerlink\" title=\"盒子结构以及原理\"></a>盒子结构以及原理</h3><p>如图所示，这里利用了一个块元素检测左侧高度与整体高度，当文本超出时，整个内部高度被撑开，使得“更多”块有空间移动到左侧。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mutiple-line\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'max-height':lineHeight*maxLines + 'px' , 'line-height':lineHeight+'px'&#125;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-container\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'-webkit-line-clamp':maxLines , 'font-size':moreTextSize + 'px'&#125;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-content\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'font-size':fontSize + 'px'&#125;\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-ghost\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-placeholder\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'height' : lineHeight*maxLines + 'px'&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-more\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'font-size':fontSize+'px', 'width':moreTextSize+'px', 'height':lineHeight+'px', 'margin-top':'-'+lineHeight+'px'&#125;\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"more-link\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基本的多行容器样式</span><br><span class=\"line\"><span class=\"selector-class\">.mutiple-line</span> </span><br><span class=\"line\">  <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">width</span> 100%</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-container</span>   </span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">-webkit-box</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">-webkit-box-orient</span>: <span class=\"selector-tag\">vertical</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-content</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#000</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">vertical-align</span>: <span class=\"selector-tag\">top</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-ghost</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">position</span><span class=\"selector-pseudo\">:absolute</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">z-index</span>: 1;</span><br><span class=\"line\">    <span class=\"selector-tag\">top</span>: 0;</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span>: 50%;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 100%;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100%;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#000</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-ghost</span><span class=\"selector-pseudo\">:before</span></span><br><span class=\"line\">    <span class=\"selector-tag\">content</span>: \"\";</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">right</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 50%;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100%;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-placeholder</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">content</span>: \"\";</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">right</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 50%;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-more</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">right</span>;</span><br></pre></td></tr></table></figure>\n\n<p>利用Vue响应式的特点，如果这里需要做媒体查询等操作也是可以的，只需要改变传入参数即可，通用于任何Webkit内核浏览器(毕竟还是要依赖<code>-webkit-line-clamp</code>属性)</p>\n","site":{"data":{}},"more":"<p>目前对于文本溢出是通过</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 单行 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">text-overflow</span><span class=\"selector-pseudo\">:ellipse</span>;</span><br><span class=\"line\"><span class=\"comment\">/* 多行 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">overflow</span> : <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">text-overflow</span>: <span class=\"selector-tag\">ellipsis</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">-webkit-box</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-line-clamp</span>: 2;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-box-orient</span>: <span class=\"selector-tag\">vertical</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但这两种方法仅限于截断后在末尾添加省略号，如果有类似这样的需求，既不是纯色背景，又不能使用渐变的时候，就不容易计算末尾处如何控制溢出</p>\n<p>这里引用<a href=\"http://hai.li/2017/03/08/css-multiline-overflow-ellipsis.html\">大神hi</a>的解决方法，仅使用css解决这个问题，本文使用 <em>Vue + Stylus</em> 完成这个方案</p>\n<p>首先分析这个组件应该具备的扩展性，它应该可以定制最大行数、行高，也需要规定更多部分的宽度大小，同时应该提供内容以及更多的html片段<a href=\"https://cn.vuejs.org/v2/guide/components-slots.html#ad\">插槽</a>(不清楚的同学请猛戳左侧链接~)，这里我先定义它的props:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  name : <span class=\"string\">'mutiLinesEllipsis'</span>,</span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">    lineHeight : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    maxLines : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    fontSize : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    moreTextSize : &#123;</span><br><span class=\"line\">      type : <span class=\"built_in\">Number</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么有了以上的几个属性，我们开始组织我们的html结构</p>\n<h3 id=\"盒子结构以及原理\"><a href=\"#盒子结构以及原理\" class=\"headerlink\" title=\"盒子结构以及原理\"></a>盒子结构以及原理</h3><p>如图所示，这里利用了一个块元素检测左侧高度与整体高度，当文本超出时，整个内部高度被撑开，使得“更多”块有空间移动到左侧。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"mutiple-line\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'max-height':lineHeight*maxLines + 'px' , 'line-height':lineHeight+'px'&#125;\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-container\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'-webkit-line-clamp':maxLines , 'font-size':moreTextSize + 'px'&#125;\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-content\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'font-size':fontSize + 'px'&#125;\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-ghost\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-placeholder\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'height' : lineHeight*maxLines + 'px'&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"ellipsis-more\"</span> <span class=\"attr\">:style</span>=<span class=\"string\">\"&#123;'font-size':fontSize+'px', 'width':moreTextSize+'px', 'height':lineHeight+'px', 'margin-top':'-'+lineHeight+'px'&#125;\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"more-link\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 基本的多行容器样式</span><br><span class=\"line\"><span class=\"selector-class\">.mutiple-line</span> </span><br><span class=\"line\">  <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;</span><br><span class=\"line\">  <span class=\"selector-tag\">width</span> 100%</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-container</span>   </span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">-webkit-box</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">-webkit-box-orient</span>: <span class=\"selector-tag\">vertical</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-tag\">transparent</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-content</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#000</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">vertical-align</span>: <span class=\"selector-tag\">top</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-ghost</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">position</span><span class=\"selector-pseudo\">:absolute</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">z-index</span>: 1;</span><br><span class=\"line\">    <span class=\"selector-tag\">top</span>: 0;</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span>: 50%;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 100%;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100%;</span><br><span class=\"line\">    <span class=\"selector-tag\">color</span>: <span class=\"selector-id\">#000</span>;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-ghost</span><span class=\"selector-pseudo\">:before</span></span><br><span class=\"line\">    <span class=\"selector-tag\">content</span>: \"\";</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">right</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 50%;</span><br><span class=\"line\">    <span class=\"selector-tag\">height</span>: 100%;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-placeholder</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">content</span>: \"\";</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">right</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 50%;</span><br><span class=\"line\">  <span class=\"selector-class\">.ellipsis-more</span> </span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">relative</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">right</span>;</span><br></pre></td></tr></table></figure>\n\n<p>利用Vue响应式的特点，如果这里需要做媒体查询等操作也是可以的，只需要改变传入参数即可，通用于任何Webkit内核浏览器(毕竟还是要依赖<code>-webkit-line-clamp</code>属性)</p>\n"},{"date":"2020-03-02T23:06:46.000Z","title":"做前端笔试题前，需要复习的数组方法","excerpt":"数组方法兼容性不尽相同，而且一些方法可以实现非常巧妙的功能","thumbnail":"","_content":"前端的笔试题，离不开妙用数组解决存储和顺序，本文复习一下数组的方法，加深印象，补充一些妙用。\n\n## 方法概览\n\n1. 转换\n\t- toLocalString()\n    - toString()\n    - valueOf()\n    \n2. 栈方法\n\t- pop() `array.pop() // 返回pop的元素`\n    - push() `array.push(item1, item2, ..., itemX) // 返回数组新长度`\n    \n3. 队列方法\n\t- push() `array.push(item1, item2, ..., itemX) // 返回数组新长度`\n    - shift() `array.shift() // 返回移除的元素`\n    \n4. 重排序\n\t- sort() `array.sort(sortFunction) // 返回数组的引用，不产生新的副本`\n    - reverse() `array.reverse() // 返回数组的引用，不产生新的副本`\n    \n5. 操作方法\n\t- concat() `array1.concat(array2,array3,...,arrayX) // 返回新数组`\n    - slice() `array.slice(start, end) // 返回新的数组`\n    \n      > array.slice()返回数组的复制。\n        \n    - splice() `array.splice(index,howmany,item1,.....,itemX) // 如果从 array 中删除了元素，则返回的是含有被删除的元素的数组。`\n\n6. 位置方法\n\t- indexOf() `array.indexOf(item,start) // 返回第一个出现的位置，如果未找到返回 -1`\n    - lastIndexOf() ` // 返回最后一个出现的位置，如果未找到返回 -1`\n    \n7. 迭代方法\n\t- every() `array.every(function(currentValue,index,arr), context) // context为this的值，下同。返回布尔值，如果所有元素都通过检测返回 true，否则返回 false。`\n    - filter() `array.filter(function(currentValue,index,arr), context) // 返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。`\n    - some() `array.some(function(currentValue,index,arr) ,context) // 返回布尔值。如果数组中有元素满足条件返回 true，否则返回 false。`\n    - forEach() `array.forEach(function(currentValue, index, arr), context) // 返回undefined！`\n    - map() `array.map(function(currentValue,index,arr), context) // 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。`\n    \n8. 归并方法\n\t- reduce() `array.reduce(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果，例如求和。`\n    - reduceRight() `array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果。`\n    \n9. 新方法\n\t- keys() `array.keys() // [object Array Iterator]`\n    - includes() `arr.includes(searchElement, fromIndex?) // 返回布尔值。如果找到指定值返回 true，否则返回 false。`\n    - from() `array.from(object, mapFunction, context) // 返回数组对象。用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。`\n    - findIndex() `array.findIndex(function(currentValue, index, arr), context) // 返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1。` \n    - entires() `array.entries() // 返回数组迭代对象。`","source":"_posts/fe/做前端笔试题前-需要复习的数组方法.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-03-03T07:06:46.000+00:00\ntitle: 做前端笔试题前，需要复习的数组方法\nexcerpt: 数组方法兼容性不尽相同，而且一些方法可以实现非常巧妙的功能\nthumbnail: ''\n\n---\n前端的笔试题，离不开妙用数组解决存储和顺序，本文复习一下数组的方法，加深印象，补充一些妙用。\n\n## 方法概览\n\n1. 转换\n\t- toLocalString()\n    - toString()\n    - valueOf()\n    \n2. 栈方法\n\t- pop() `array.pop() // 返回pop的元素`\n    - push() `array.push(item1, item2, ..., itemX) // 返回数组新长度`\n    \n3. 队列方法\n\t- push() `array.push(item1, item2, ..., itemX) // 返回数组新长度`\n    - shift() `array.shift() // 返回移除的元素`\n    \n4. 重排序\n\t- sort() `array.sort(sortFunction) // 返回数组的引用，不产生新的副本`\n    - reverse() `array.reverse() // 返回数组的引用，不产生新的副本`\n    \n5. 操作方法\n\t- concat() `array1.concat(array2,array3,...,arrayX) // 返回新数组`\n    - slice() `array.slice(start, end) // 返回新的数组`\n    \n      > array.slice()返回数组的复制。\n        \n    - splice() `array.splice(index,howmany,item1,.....,itemX) // 如果从 array 中删除了元素，则返回的是含有被删除的元素的数组。`\n\n6. 位置方法\n\t- indexOf() `array.indexOf(item,start) // 返回第一个出现的位置，如果未找到返回 -1`\n    - lastIndexOf() ` // 返回最后一个出现的位置，如果未找到返回 -1`\n    \n7. 迭代方法\n\t- every() `array.every(function(currentValue,index,arr), context) // context为this的值，下同。返回布尔值，如果所有元素都通过检测返回 true，否则返回 false。`\n    - filter() `array.filter(function(currentValue,index,arr), context) // 返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。`\n    - some() `array.some(function(currentValue,index,arr) ,context) // 返回布尔值。如果数组中有元素满足条件返回 true，否则返回 false。`\n    - forEach() `array.forEach(function(currentValue, index, arr), context) // 返回undefined！`\n    - map() `array.map(function(currentValue,index,arr), context) // 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。`\n    \n8. 归并方法\n\t- reduce() `array.reduce(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果，例如求和。`\n    - reduceRight() `array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果。`\n    \n9. 新方法\n\t- keys() `array.keys() // [object Array Iterator]`\n    - includes() `arr.includes(searchElement, fromIndex?) // 返回布尔值。如果找到指定值返回 true，否则返回 false。`\n    - from() `array.from(object, mapFunction, context) // 返回数组对象。用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。`\n    - findIndex() `array.findIndex(function(currentValue, index, arr), context) // 返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1。` \n    - entires() `array.entries() // 返回数组迭代对象。`","slug":"fe/做前端笔试题前-需要复习的数组方法","published":1,"updated":"2020-08-01T18:21:52.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iay0020j1wt0bmo3za4","content":"<p>前端的笔试题，离不开妙用数组解决存储和顺序，本文复习一下数组的方法，加深印象，补充一些妙用。</p>\n<h2 id=\"方法概览\"><a href=\"#方法概览\" class=\"headerlink\" title=\"方法概览\"></a>方法概览</h2><ol>\n<li><p>转换</p>\n<ul>\n<li>toLocalString()</li>\n<li>toString()</li>\n<li>valueOf()</li>\n</ul>\n</li>\n<li><p>栈方法</p>\n<ul>\n<li>pop() <code>array.pop() // 返回pop的元素</code></li>\n<li>push() <code>array.push(item1, item2, ..., itemX) // 返回数组新长度</code></li>\n</ul>\n</li>\n<li><p>队列方法</p>\n<ul>\n<li>push() <code>array.push(item1, item2, ..., itemX) // 返回数组新长度</code></li>\n<li>shift() <code>array.shift() // 返回移除的元素</code></li>\n</ul>\n</li>\n<li><p>重排序</p>\n<ul>\n<li>sort() <code>array.sort(sortFunction) // 返回数组的引用，不产生新的副本</code></li>\n<li>reverse() <code>array.reverse() // 返回数组的引用，不产生新的副本</code></li>\n</ul>\n</li>\n<li><p>操作方法</p>\n<ul>\n<li><p>concat() <code>array1.concat(array2,array3,...,arrayX) // 返回新数组</code></p>\n</li>\n<li><p>slice() <code>array.slice(start, end) // 返回新的数组</code></p>\n<blockquote>\n<p>array.slice()返回数组的复制。</p>\n</blockquote>\n</li>\n<li><p>splice() <code>array.splice(index,howmany,item1,.....,itemX) // 如果从 array 中删除了元素，则返回的是含有被删除的元素的数组。</code></p>\n</li>\n</ul>\n</li>\n<li><p>位置方法</p>\n<ul>\n<li>indexOf() <code>array.indexOf(item,start) // 返回第一个出现的位置，如果未找到返回 -1</code></li>\n<li>lastIndexOf() <code> // 返回最后一个出现的位置，如果未找到返回 -1</code></li>\n</ul>\n</li>\n<li><p>迭代方法</p>\n<ul>\n<li>every() <code>array.every(function(currentValue,index,arr), context) // context为this的值，下同。返回布尔值，如果所有元素都通过检测返回 true，否则返回 false。</code></li>\n<li>filter() <code>array.filter(function(currentValue,index,arr), context) // 返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</code></li>\n<li>some() <code>array.some(function(currentValue,index,arr) ,context) // 返回布尔值。如果数组中有元素满足条件返回 true，否则返回 false。</code></li>\n<li>forEach() <code>array.forEach(function(currentValue, index, arr), context) // 返回undefined！</code></li>\n<li>map() <code>array.map(function(currentValue,index,arr), context) // 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</code></li>\n</ul>\n</li>\n<li><p>归并方法</p>\n<ul>\n<li>reduce() <code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果，例如求和。</code></li>\n<li>reduceRight() <code>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果。</code></li>\n</ul>\n</li>\n<li><p>新方法</p>\n<ul>\n<li>keys() <code>array.keys() // [object Array Iterator]</code></li>\n<li>includes() <code>arr.includes(searchElement, fromIndex?) // 返回布尔值。如果找到指定值返回 true，否则返回 false。</code></li>\n<li>from() <code>array.from(object, mapFunction, context) // 返回数组对象。用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。</code></li>\n<li>findIndex() <code>array.findIndex(function(currentValue, index, arr), context) // 返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1。</code> </li>\n<li>entires() <code>array.entries() // 返回数组迭代对象。</code></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"more":"<p>前端的笔试题，离不开妙用数组解决存储和顺序，本文复习一下数组的方法，加深印象，补充一些妙用。</p>\n<h2 id=\"方法概览\"><a href=\"#方法概览\" class=\"headerlink\" title=\"方法概览\"></a>方法概览</h2><ol>\n<li><p>转换</p>\n<ul>\n<li>toLocalString()</li>\n<li>toString()</li>\n<li>valueOf()</li>\n</ul>\n</li>\n<li><p>栈方法</p>\n<ul>\n<li>pop() <code>array.pop() // 返回pop的元素</code></li>\n<li>push() <code>array.push(item1, item2, ..., itemX) // 返回数组新长度</code></li>\n</ul>\n</li>\n<li><p>队列方法</p>\n<ul>\n<li>push() <code>array.push(item1, item2, ..., itemX) // 返回数组新长度</code></li>\n<li>shift() <code>array.shift() // 返回移除的元素</code></li>\n</ul>\n</li>\n<li><p>重排序</p>\n<ul>\n<li>sort() <code>array.sort(sortFunction) // 返回数组的引用，不产生新的副本</code></li>\n<li>reverse() <code>array.reverse() // 返回数组的引用，不产生新的副本</code></li>\n</ul>\n</li>\n<li><p>操作方法</p>\n<ul>\n<li><p>concat() <code>array1.concat(array2,array3,...,arrayX) // 返回新数组</code></p>\n</li>\n<li><p>slice() <code>array.slice(start, end) // 返回新的数组</code></p>\n<blockquote>\n<p>array.slice()返回数组的复制。</p>\n</blockquote>\n</li>\n<li><p>splice() <code>array.splice(index,howmany,item1,.....,itemX) // 如果从 array 中删除了元素，则返回的是含有被删除的元素的数组。</code></p>\n</li>\n</ul>\n</li>\n<li><p>位置方法</p>\n<ul>\n<li>indexOf() <code>array.indexOf(item,start) // 返回第一个出现的位置，如果未找到返回 -1</code></li>\n<li>lastIndexOf() <code> // 返回最后一个出现的位置，如果未找到返回 -1</code></li>\n</ul>\n</li>\n<li><p>迭代方法</p>\n<ul>\n<li>every() <code>array.every(function(currentValue,index,arr), context) // context为this的值，下同。返回布尔值，如果所有元素都通过检测返回 true，否则返回 false。</code></li>\n<li>filter() <code>array.filter(function(currentValue,index,arr), context) // 返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</code></li>\n<li>some() <code>array.some(function(currentValue,index,arr) ,context) // 返回布尔值。如果数组中有元素满足条件返回 true，否则返回 false。</code></li>\n<li>forEach() <code>array.forEach(function(currentValue, index, arr), context) // 返回undefined！</code></li>\n<li>map() <code>array.map(function(currentValue,index,arr), context) // 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</code></li>\n</ul>\n</li>\n<li><p>归并方法</p>\n<ul>\n<li>reduce() <code>array.reduce(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果，例如求和。</code></li>\n<li>reduceRight() <code>array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果。</code></li>\n</ul>\n</li>\n<li><p>新方法</p>\n<ul>\n<li>keys() <code>array.keys() // [object Array Iterator]</code></li>\n<li>includes() <code>arr.includes(searchElement, fromIndex?) // 返回布尔值。如果找到指定值返回 true，否则返回 false。</code></li>\n<li>from() <code>array.from(object, mapFunction, context) // 返回数组对象。用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。</code></li>\n<li>findIndex() <code>array.findIndex(function(currentValue, index, arr), context) // 返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1。</code> </li>\n<li>entires() <code>array.entries() // 返回数组迭代对象。</code></li>\n</ul>\n</li>\n</ol>\n"},{"date":"2020-04-03T09:48:03.000Z","title":"利用CSS给自己的博客增加灰度化效果","excerpt":"特殊的日子，前端需要配合做一些修改，这里总结一些大厂的实现方法。","thumbnail":"","_content":"## 思路\n\n利用filter特性，我们可以对根节点直接增加黑白滤镜，也可以通过通用的类名实现指定节点的滤镜（请注意，filter属性可能会影响部分DOM元素的渲染层，请参考BFC相关知识点。）\n\n## 先看几种实现\n\n### B站\n\n```css\nhtml.gray{-webkit-filter:grayscale(.95)}\n```\n\n配合以下的JS代码实现在指定时间段内自动开启滤镜：\n\n```javascript\nvar now=Date.now();15859296e5<now&&now<1586016e6&&(document.getElementsByTagName(\"html\")[0].className=\"gray\")\n```\n\n(PS: 刚上线的时候看了一下，发现轮播没有修改为单个，后两个为空，一定要注意😂)\n\n### 京东\n\n```css\n.o2_ie8 .more2_international {\n    filter: progid:dximagetransform.microsoft.alphaimageloader(src='//storage.360buyimg.com/mtd/home/more_international1575014601797.png', sizingMethod='scale');\n    background: none;\n}\n\n.mod_help_cover {\n    background-image: none;\n}\n\n.dropdown:hover .cw-icon {\n    border-bottom: 1px solid #e3e4e5;\n}\n\nhtml.o2_gray {\n    -webkit-filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n配合以下JS代码实现在指定时间内应用类名\n\n```javascript\nvar isDuringDate = function(beginDateStr, endDateStr) {\n    var curDate = new Date()\n    var beginDate = new Date(beginDateStr)\n    var endDate = new Date(endDateStr)\n\n    if (curDate >= beginDate && curDate <= endDate) {\n        return true\n    }\n    return false\n}\n\n$html = $('html')\n$html.toggleClass('o2_gray', isDuringDate('2020/04/04 00:00:00', '2020/04/04 23:59:59'))\n```\n\n(PS: 京东的首页没有压缩源代码，很多部分是直出拼接在页面内的，也是一种便于操作的方案)\n\n### 淘宝\n\n```css\nhtml{-webkit-filter: grayscale(100%);       filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);} \n```\n\n## 总结\n\n综合以上几个例子，我们可以知道，通过`filter: grayscale(100%);`即可完成最简单的灰度化，但是，filter属性的可用性在[Caniuse查询](https://caniuse.com/#feat=css-filters)可知，不兼容全系列IE浏览器，即便我们使用`-ms-filter`，在[部分版本IE仍无法使用](https://docs.microsoft.com/en-us/previous-versions/ms530752(v%3Dvs.85))，因此，如果需要兼容IE则可以通过IE浏览器自身实现的滤镜来作为替代。\n\n> Note   As of Windows Internet Explorer 9 this feature was deprecated. As of Internet Explorer 10 this feature was removed and should no longer be used.\n\n另外可以发现，京东还做了图片滤镜的兼容，在灰度滤镜效果异常时可以使用半透明图片作为滤镜，也是一种常见的方案。\n\n## 延申阅读\n\n[如何尽可能的兼容低版本IE](https://medium.com/@MateMarschalko/css-filters-all-the-way-down-to-ie4-6349d61c4cce)\n\n上面这篇文章介绍了一些兼容的技巧，但是对于一些效果需要实验验证DXImage系的滤镜与CSS3滤镜的效果是否一致。","source":"_posts/fe/利用css给自己的博客增加灰度化效果.md","raw":"---\ncategories: Frontend\ntags:\n- CSS\ndate: 2020-04-04T01:48:03.000+08:00\ntitle: 利用CSS给自己的博客增加灰度化效果\nexcerpt: 特殊的日子，前端需要配合做一些修改，这里总结一些大厂的实现方法。\nthumbnail: ''\n\n---\n## 思路\n\n利用filter特性，我们可以对根节点直接增加黑白滤镜，也可以通过通用的类名实现指定节点的滤镜（请注意，filter属性可能会影响部分DOM元素的渲染层，请参考BFC相关知识点。）\n\n## 先看几种实现\n\n### B站\n\n```css\nhtml.gray{-webkit-filter:grayscale(.95)}\n```\n\n配合以下的JS代码实现在指定时间段内自动开启滤镜：\n\n```javascript\nvar now=Date.now();15859296e5<now&&now<1586016e6&&(document.getElementsByTagName(\"html\")[0].className=\"gray\")\n```\n\n(PS: 刚上线的时候看了一下，发现轮播没有修改为单个，后两个为空，一定要注意😂)\n\n### 京东\n\n```css\n.o2_ie8 .more2_international {\n    filter: progid:dximagetransform.microsoft.alphaimageloader(src='//storage.360buyimg.com/mtd/home/more_international1575014601797.png', sizingMethod='scale');\n    background: none;\n}\n\n.mod_help_cover {\n    background-image: none;\n}\n\n.dropdown:hover .cw-icon {\n    border-bottom: 1px solid #e3e4e5;\n}\n\nhtml.o2_gray {\n    -webkit-filter: grayscale(100%);\n    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n}\n```\n\n配合以下JS代码实现在指定时间内应用类名\n\n```javascript\nvar isDuringDate = function(beginDateStr, endDateStr) {\n    var curDate = new Date()\n    var beginDate = new Date(beginDateStr)\n    var endDate = new Date(endDateStr)\n\n    if (curDate >= beginDate && curDate <= endDate) {\n        return true\n    }\n    return false\n}\n\n$html = $('html')\n$html.toggleClass('o2_gray', isDuringDate('2020/04/04 00:00:00', '2020/04/04 23:59:59'))\n```\n\n(PS: 京东的首页没有压缩源代码，很多部分是直出拼接在页面内的，也是一种便于操作的方案)\n\n### 淘宝\n\n```css\nhtml{-webkit-filter: grayscale(100%);       filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);} \n```\n\n## 总结\n\n综合以上几个例子，我们可以知道，通过`filter: grayscale(100%);`即可完成最简单的灰度化，但是，filter属性的可用性在[Caniuse查询](https://caniuse.com/#feat=css-filters)可知，不兼容全系列IE浏览器，即便我们使用`-ms-filter`，在[部分版本IE仍无法使用](https://docs.microsoft.com/en-us/previous-versions/ms530752(v%3Dvs.85))，因此，如果需要兼容IE则可以通过IE浏览器自身实现的滤镜来作为替代。\n\n> Note   As of Windows Internet Explorer 9 this feature was deprecated. As of Internet Explorer 10 this feature was removed and should no longer be used.\n\n另外可以发现，京东还做了图片滤镜的兼容，在灰度滤镜效果异常时可以使用半透明图片作为滤镜，也是一种常见的方案。\n\n## 延申阅读\n\n[如何尽可能的兼容低版本IE](https://medium.com/@MateMarschalko/css-filters-all-the-way-down-to-ie4-6349d61c4cce)\n\n上面这篇文章介绍了一些兼容的技巧，但是对于一些效果需要实验验证DXImage系的滤镜与CSS3滤镜的效果是否一致。","slug":"fe/利用css给自己的博客增加灰度化效果","published":1,"updated":"2020-08-01T18:21:52.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iaz0023j1wt85i3gsi4","content":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>利用filter特性，我们可以对根节点直接增加黑白滤镜，也可以通过通用的类名实现指定节点的滤镜（请注意，filter属性可能会影响部分DOM元素的渲染层，请参考BFC相关知识点。）</p>\n<h2 id=\"先看几种实现\"><a href=\"#先看几种实现\" class=\"headerlink\" title=\"先看几种实现\"></a>先看几种实现</h2><h3 id=\"B站\"><a href=\"#B站\" class=\"headerlink\" title=\"B站\"></a>B站</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-class\">.gray</span>&#123;<span class=\"attribute\">-webkit-filter</span>:<span class=\"built_in\">grayscale</span>(.<span class=\"number\">95</span>)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配合以下的JS代码实现在指定时间段内自动开启滤镜：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> now=<span class=\"built_in\">Date</span>.now();<span class=\"number\">15859296e5</span>&lt;now&amp;&amp;now&lt;<span class=\"number\">1586016e6</span>&amp;&amp;(<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"html\"</span>)[<span class=\"number\">0</span>].className=<span class=\"string\">\"gray\"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>(PS: 刚上线的时候看了一下，发现轮播没有修改为单个，后两个为空，一定要注意😂)</p>\n<h3 id=\"京东\"><a href=\"#京东\" class=\"headerlink\" title=\"京东\"></a>京东</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.o2_ie8</span> <span class=\"selector-class\">.more2_international</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: progid:dximagetransform.microsoft.<span class=\"built_in\">alphaimageloader</span>(src=<span class=\"string\">'//storage.360buyimg.com/mtd/home/more_international1575014601797.png'</span>, sizingMethod=<span class=\"string\">'scale'</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.mod_help_cover</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.dropdown</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.cw-icon</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#e3e4e5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-class\">.o2_gray</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(<span class=\"number\">100%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: progid:DXImageTransform.Microsoft.<span class=\"built_in\">BasicImage</span>(grayscale=<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配合以下JS代码实现在指定时间内应用类名</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isDuringDate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">beginDateStr, endDateStr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> curDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> beginDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(beginDateStr)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> endDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(endDateStr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curDate &gt;= beginDate &amp;&amp; curDate &lt;= endDate) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$html = $(<span class=\"string\">'html'</span>)</span><br><span class=\"line\">$html.toggleClass(<span class=\"string\">'o2_gray'</span>, isDuringDate(<span class=\"string\">'2020/04/04 00:00:00'</span>, <span class=\"string\">'2020/04/04 23:59:59'</span>))</span><br></pre></td></tr></table></figure>\n\n<p>(PS: 京东的首页没有压缩源代码，很多部分是直出拼接在页面内的，也是一种便于操作的方案)</p>\n<h3 id=\"淘宝\"><a href=\"#淘宝\" class=\"headerlink\" title=\"淘宝\"></a>淘宝</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>&#123;<span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(<span class=\"number\">100%</span>);       <span class=\"attribute\">filter</span>:progid:DXImageTransform.Microsoft.<span class=\"built_in\">BasicImage</span>(grayscale=<span class=\"number\">1</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综合以上几个例子，我们可以知道，通过<code>filter: grayscale(100%);</code>即可完成最简单的灰度化，但是，filter属性的可用性在<a href=\"https://caniuse.com/#feat=css-filters\">Caniuse查询</a>可知，不兼容全系列IE浏览器，即便我们使用<code>-ms-filter</code>，在<a href=\"https://docs.microsoft.com/en-us/previous-versions/ms530752(v%3Dvs.85)\">部分版本IE仍无法使用</a>，因此，如果需要兼容IE则可以通过IE浏览器自身实现的滤镜来作为替代。</p>\n<blockquote>\n<p>Note   As of Windows Internet Explorer 9 this feature was deprecated. As of Internet Explorer 10 this feature was removed and should no longer be used.</p>\n</blockquote>\n<p>另外可以发现，京东还做了图片滤镜的兼容，在灰度滤镜效果异常时可以使用半透明图片作为滤镜，也是一种常见的方案。</p>\n<h2 id=\"延申阅读\"><a href=\"#延申阅读\" class=\"headerlink\" title=\"延申阅读\"></a>延申阅读</h2><p><a href=\"https://medium.com/@MateMarschalko/css-filters-all-the-way-down-to-ie4-6349d61c4cce\">如何尽可能的兼容低版本IE</a></p>\n<p>上面这篇文章介绍了一些兼容的技巧，但是对于一些效果需要实验验证DXImage系的滤镜与CSS3滤镜的效果是否一致。</p>\n","site":{"data":{}},"more":"<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>利用filter特性，我们可以对根节点直接增加黑白滤镜，也可以通过通用的类名实现指定节点的滤镜（请注意，filter属性可能会影响部分DOM元素的渲染层，请参考BFC相关知识点。）</p>\n<h2 id=\"先看几种实现\"><a href=\"#先看几种实现\" class=\"headerlink\" title=\"先看几种实现\"></a>先看几种实现</h2><h3 id=\"B站\"><a href=\"#B站\" class=\"headerlink\" title=\"B站\"></a>B站</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-class\">.gray</span>&#123;<span class=\"attribute\">-webkit-filter</span>:<span class=\"built_in\">grayscale</span>(.<span class=\"number\">95</span>)&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配合以下的JS代码实现在指定时间段内自动开启滤镜：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> now=<span class=\"built_in\">Date</span>.now();<span class=\"number\">15859296e5</span>&lt;now&amp;&amp;now&lt;<span class=\"number\">1586016e6</span>&amp;&amp;(<span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"html\"</span>)[<span class=\"number\">0</span>].className=<span class=\"string\">\"gray\"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>(PS: 刚上线的时候看了一下，发现轮播没有修改为单个，后两个为空，一定要注意😂)</p>\n<h3 id=\"京东\"><a href=\"#京东\" class=\"headerlink\" title=\"京东\"></a>京东</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.o2_ie8</span> <span class=\"selector-class\">.more2_international</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: progid:dximagetransform.microsoft.<span class=\"built_in\">alphaimageloader</span>(src=<span class=\"string\">'//storage.360buyimg.com/mtd/home/more_international1575014601797.png'</span>, sizingMethod=<span class=\"string\">'scale'</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.mod_help_cover</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.dropdown</span><span class=\"selector-pseudo\">:hover</span> <span class=\"selector-class\">.cw-icon</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#e3e4e5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">html</span><span class=\"selector-class\">.o2_gray</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(<span class=\"number\">100%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">filter</span>: progid:DXImageTransform.Microsoft.<span class=\"built_in\">BasicImage</span>(grayscale=<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配合以下JS代码实现在指定时间内应用类名</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isDuringDate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">beginDateStr, endDateStr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> curDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> beginDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(beginDateStr)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> endDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(endDateStr)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curDate &gt;= beginDate &amp;&amp; curDate &lt;= endDate) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$html = $(<span class=\"string\">'html'</span>)</span><br><span class=\"line\">$html.toggleClass(<span class=\"string\">'o2_gray'</span>, isDuringDate(<span class=\"string\">'2020/04/04 00:00:00'</span>, <span class=\"string\">'2020/04/04 23:59:59'</span>))</span><br></pre></td></tr></table></figure>\n\n<p>(PS: 京东的首页没有压缩源代码，很多部分是直出拼接在页面内的，也是一种便于操作的方案)</p>\n<h3 id=\"淘宝\"><a href=\"#淘宝\" class=\"headerlink\" title=\"淘宝\"></a>淘宝</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span>&#123;<span class=\"attribute\">-webkit-filter</span>: <span class=\"built_in\">grayscale</span>(<span class=\"number\">100%</span>);       <span class=\"attribute\">filter</span>:progid:DXImageTransform.Microsoft.<span class=\"built_in\">BasicImage</span>(grayscale=<span class=\"number\">1</span>);&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综合以上几个例子，我们可以知道，通过<code>filter: grayscale(100%);</code>即可完成最简单的灰度化，但是，filter属性的可用性在<a href=\"https://caniuse.com/#feat=css-filters\">Caniuse查询</a>可知，不兼容全系列IE浏览器，即便我们使用<code>-ms-filter</code>，在<a href=\"https://docs.microsoft.com/en-us/previous-versions/ms530752(v%3Dvs.85)\">部分版本IE仍无法使用</a>，因此，如果需要兼容IE则可以通过IE浏览器自身实现的滤镜来作为替代。</p>\n<blockquote>\n<p>Note   As of Windows Internet Explorer 9 this feature was deprecated. As of Internet Explorer 10 this feature was removed and should no longer be used.</p>\n</blockquote>\n<p>另外可以发现，京东还做了图片滤镜的兼容，在灰度滤镜效果异常时可以使用半透明图片作为滤镜，也是一种常见的方案。</p>\n<h2 id=\"延申阅读\"><a href=\"#延申阅读\" class=\"headerlink\" title=\"延申阅读\"></a>延申阅读</h2><p><a href=\"https://medium.com/@MateMarschalko/css-filters-all-the-way-down-to-ie4-6349d61c4cce\">如何尽可能的兼容低版本IE</a></p>\n<p>上面这篇文章介绍了一些兼容的技巧，但是对于一些效果需要实验验证DXImage系的滤镜与CSS3滤镜的效果是否一致。</p>\n"},{"title":"前端看HTTP","date":"2019-08-18T08:00:00.000Z","excerpt":"HTTP是每一个前端应该知道的基础知识，本文综合了几个来源，总结了一些常用的知识点。","thumbnail":"","_content":"#### HTTP是什么\n\nHTTP (超文本传输协议) 是用来在 Web 上传输文件的 __基础协议__ ，基于 __TCP/IP通信协议__ 来传递数据，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们。目前HTTP说明文档的版本是HTTP/2。\n\nHTTPS 是 HTTP 协议的安全版本，HTTPS __在 HTTP 上加入套接字 SSL（TLS 为 SSL 最新版）层__ ，对网页进行加密传输。\n\nHTTP 是 __基于文本__ (所有的通信都是以纯文本的形式进行) 以及 __无状态的 (当前通信不会发现以前的通信状态)__ 。这个特点对在www上访问网页的人是很理想的。而且，HTTP也可以让网站更加的灵活多变，利用在AJAX上等。\n\nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 __URL是一种特殊类型的 URI__ 。\n\nHTTP是用于传输诸如HTML的超媒体文档的 __应用层__ 协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的 __客户端-服务端模型__ ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用；也就是说，一个不会像UDP协议那样静默丢失消息的协议。RUDP作为UDP的可靠的升级版本，是一种合适的替代选择。\n\n#### 通过定义能够知道的特点\n\n1. 基于TCP/IP通信协议\n这部分的知识稍后开篇来讲\n2. HTTP位于应用层\n这部分的知识稍后开篇来讲\n3. 遵循客户端-服务端模型\nC/S(客户端/服务器)模型，是常用的服务器模型，包括现在说的B/S(浏览器/客户端)模型，都是对C/S结构的一种变化或者改进的结构。 TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有服务器都是对等的。但由于资源被数据提供者所垄断，于是产生了C/S模型：所有客户端都通过服务器获取所需资源。\n4. 无状态\n这里需要区分一下两个概念：\n\t- __无连接__：每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；\n\t- __无状态__：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；\n    \n在后续的Web发展中需要带有一定的状态，则通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。\n\n#### HTTP与HTTPS\n##### 什么是HTTPS\nHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\n##### HTTPS加密机制\nHTTP中没有加密机制，可以通过 __SSL（Secure Socket Layer 安全套接层）__ 或 __TLS（Transport Layer Security 安全层传输协议）__ 的组合使用，加密HTTP的通信内容。\n\nHTTPS是 HTTP Secure 或 HTTP over SSL。\n\nSSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但 __目前主流的还是SSL3.0和TSL1.0__ 。\n\nSSL工作在 __OSI七层模型中的表示层__ ，__TCP/IP 四层模型的应用层__ 。\n\nSSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。\n\nSSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。\n\nSSL/TLS握手阶段分为五步(假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程)：\n以下引自 [阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)\n- 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。\n- 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。\n- 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。\n- 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。\n- 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成\"对话密钥\"（session key），用来加密接下来的整个对话过程。\n\n直白解释，在HTTPS使用时，客户端首先发起请求，服务端返回证书，客户端确认无误后，选择对应的公钥开始加密，服务端接收到数据后开始使用服务器的私钥解密。\n\n#### HTTP Header\nHTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。\n\n根据不同上下文，可将消息头分为：\n- 一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。\n- 请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。\n- 响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。\n- 实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。\n\n常用的头部主要有：\n\n|应答头|说明|\n|--|--|\n|Content-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。|\n|Content-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。|\n|Expires|应该在什么时候认为文档已经过期，从而不再缓存它|\n|Last-Modified|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。|\n|Set-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。|","source":"_posts/fe/前端看http.md","raw":"---\ntags:\n- 前端\n- HTTP\ncategories: Frontend\ntitle: 前端看HTTP\ndate: 2019-08-18T16:00:00.000+00:00\nexcerpt: HTTP是每一个前端应该知道的基础知识，本文综合了几个来源，总结了一些常用的知识点。\nthumbnail: ''\n\n---\n#### HTTP是什么\n\nHTTP (超文本传输协议) 是用来在 Web 上传输文件的 __基础协议__ ，基于 __TCP/IP通信协议__ 来传递数据，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们。目前HTTP说明文档的版本是HTTP/2。\n\nHTTPS 是 HTTP 协议的安全版本，HTTPS __在 HTTP 上加入套接字 SSL（TLS 为 SSL 最新版）层__ ，对网页进行加密传输。\n\nHTTP 是 __基于文本__ (所有的通信都是以纯文本的形式进行) 以及 __无状态的 (当前通信不会发现以前的通信状态)__ 。这个特点对在www上访问网页的人是很理想的。而且，HTTP也可以让网站更加的灵活多变，利用在AJAX上等。\n\nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 __URL是一种特殊类型的 URI__ 。\n\nHTTP是用于传输诸如HTML的超媒体文档的 __应用层__ 协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的 __客户端-服务端模型__ ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用；也就是说，一个不会像UDP协议那样静默丢失消息的协议。RUDP作为UDP的可靠的升级版本，是一种合适的替代选择。\n\n#### 通过定义能够知道的特点\n\n1. 基于TCP/IP通信协议\n这部分的知识稍后开篇来讲\n2. HTTP位于应用层\n这部分的知识稍后开篇来讲\n3. 遵循客户端-服务端模型\nC/S(客户端/服务器)模型，是常用的服务器模型，包括现在说的B/S(浏览器/客户端)模型，都是对C/S结构的一种变化或者改进的结构。 TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有服务器都是对等的。但由于资源被数据提供者所垄断，于是产生了C/S模型：所有客户端都通过服务器获取所需资源。\n4. 无状态\n这里需要区分一下两个概念：\n\t- __无连接__：每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；\n\t- __无状态__：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；\n    \n在后续的Web发展中需要带有一定的状态，则通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。\n\n#### HTTP与HTTPS\n##### 什么是HTTPS\nHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。\n\n##### HTTPS加密机制\nHTTP中没有加密机制，可以通过 __SSL（Secure Socket Layer 安全套接层）__ 或 __TLS（Transport Layer Security 安全层传输协议）__ 的组合使用，加密HTTP的通信内容。\n\nHTTPS是 HTTP Secure 或 HTTP over SSL。\n\nSSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但 __目前主流的还是SSL3.0和TSL1.0__ 。\n\nSSL工作在 __OSI七层模型中的表示层__ ，__TCP/IP 四层模型的应用层__ 。\n\nSSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。\n\nSSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。\n\nSSL/TLS握手阶段分为五步(假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程)：\n以下引自 [阮一峰的网络日志](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)\n- 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。\n- 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。\n- 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。\n- 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。\n- 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成\"对话密钥\"（session key），用来加密接下来的整个对话过程。\n\n直白解释，在HTTPS使用时，客户端首先发起请求，服务端返回证书，客户端确认无误后，选择对应的公钥开始加密，服务端接收到数据后开始使用服务器的私钥解密。\n\n#### HTTP Header\nHTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。\n\n根据不同上下文，可将消息头分为：\n- 一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。\n- 请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。\n- 响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。\n- 实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。\n\n常用的头部主要有：\n\n|应答头|说明|\n|--|--|\n|Content-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。|\n|Content-Type|表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。|\n|Expires|应该在什么时候认为文档已经过期，从而不再缓存它|\n|Last-Modified|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。|\n|Set-Cookie|设置和页面关联的Cookie。Servlet不应使用response.setHeader(\"Set-Cookie\", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。|","slug":"fe/前端看http","published":1,"updated":"2020-08-01T18:21:52.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iaz0026j1wt26533unv","content":"<h4 id=\"HTTP是什么\"><a href=\"#HTTP是什么\" class=\"headerlink\" title=\"HTTP是什么\"></a>HTTP是什么</h4><p>HTTP (超文本传输协议) 是用来在 Web 上传输文件的 <strong>基础协议</strong> ，基于 <strong>TCP/IP通信协议</strong> 来传递数据，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们。目前HTTP说明文档的版本是HTTP/2。</p>\n<p>HTTPS 是 HTTP 协议的安全版本，HTTPS <strong>在 HTTP 上加入套接字 SSL（TLS 为 SSL 最新版）层</strong> ，对网页进行加密传输。</p>\n<p>HTTP 是 <strong>基于文本</strong> (所有的通信都是以纯文本的形式进行) 以及 <strong>无状态的 (当前通信不会发现以前的通信状态)</strong> 。这个特点对在www上访问网页的人是很理想的。而且，HTTP也可以让网站更加的灵活多变，利用在AJAX上等。</p>\n<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 <strong>URL是一种特殊类型的 URI</strong> 。</p>\n<p>HTTP是用于传输诸如HTML的超媒体文档的 <strong>应用层</strong> 协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的 <strong>客户端-服务端模型</strong> ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用；也就是说，一个不会像UDP协议那样静默丢失消息的协议。RUDP作为UDP的可靠的升级版本，是一种合适的替代选择。</p>\n<h4 id=\"通过定义能够知道的特点\"><a href=\"#通过定义能够知道的特点\" class=\"headerlink\" title=\"通过定义能够知道的特点\"></a>通过定义能够知道的特点</h4><ol>\n<li>基于TCP/IP通信协议<br>这部分的知识稍后开篇来讲</li>\n<li>HTTP位于应用层<br>这部分的知识稍后开篇来讲</li>\n<li>遵循客户端-服务端模型<br>C/S(客户端/服务器)模型，是常用的服务器模型，包括现在说的B/S(浏览器/客户端)模型，都是对C/S结构的一种变化或者改进的结构。 TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有服务器都是对等的。但由于资源被数据提供者所垄断，于是产生了C/S模型：所有客户端都通过服务器获取所需资源。</li>\n<li>无状态<br>这里需要区分一下两个概念：<ul>\n<li>__无连接__：每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</li>\n<li>__无状态__：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</li>\n</ul>\n</li>\n</ol>\n<p>在后续的Web发展中需要带有一定的状态，则通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p>\n<h4 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h4><h5 id=\"什么是HTTPS\"><a href=\"#什么是HTTPS\" class=\"headerlink\" title=\"什么是HTTPS\"></a>什么是HTTPS</h5><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>\n<h5 id=\"HTTPS加密机制\"><a href=\"#HTTPS加密机制\" class=\"headerlink\" title=\"HTTPS加密机制\"></a>HTTPS加密机制</h5><p>HTTP中没有加密机制，可以通过 <strong>SSL（Secure Socket Layer 安全套接层）</strong> 或 <strong>TLS（Transport Layer Security 安全层传输协议）</strong> 的组合使用，加密HTTP的通信内容。</p>\n<p>HTTPS是 HTTP Secure 或 HTTP over SSL。</p>\n<p>SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但 <strong>目前主流的还是SSL3.0和TSL1.0</strong> 。</p>\n<p>SSL工作在 <strong>OSI七层模型中的表示层</strong> ，<strong>TCP/IP 四层模型的应用层</strong> 。</p>\n<p>SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。</p>\n<p>SSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。</p>\n<p>SSL/TLS握手阶段分为五步(假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程)：<br>以下引自 <a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\">阮一峰的网络日志</a></p>\n<ul>\n<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>\n<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>\n<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>\n<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>\n<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>\n</ul>\n<p>直白解释，在HTTPS使用时，客户端首先发起请求，服务端返回证书，客户端确认无误后，选择对应的公钥开始加密，服务端接收到数据后开始使用服务器的私钥解密。</p>\n<h4 id=\"HTTP-Header\"><a href=\"#HTTP-Header\" class=\"headerlink\" title=\"HTTP Header\"></a>HTTP Header</h4><p>HTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。</p>\n<p>根据不同上下文，可将消息头分为：</p>\n<ul>\n<li>一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li>\n<li>请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。</li>\n<li>响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li>\n<li>实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li>\n</ul>\n<p>常用的头部主要有：</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"more":"<h4 id=\"HTTP是什么\"><a href=\"#HTTP是什么\" class=\"headerlink\" title=\"HTTP是什么\"></a>HTTP是什么</h4><p>HTTP (超文本传输协议) 是用来在 Web 上传输文件的 <strong>基础协议</strong> ，基于 <strong>TCP/IP通信协议</strong> 来传递数据，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们。目前HTTP说明文档的版本是HTTP/2。</p>\n<p>HTTPS 是 HTTP 协议的安全版本，HTTPS <strong>在 HTTP 上加入套接字 SSL（TLS 为 SSL 最新版）层</strong> ，对网页进行加密传输。</p>\n<p>HTTP 是 <strong>基于文本</strong> (所有的通信都是以纯文本的形式进行) 以及 <strong>无状态的 (当前通信不会发现以前的通信状态)</strong> 。这个特点对在www上访问网页的人是很理想的。而且，HTTP也可以让网站更加的灵活多变，利用在AJAX上等。</p>\n<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 <strong>URL是一种特殊类型的 URI</strong> 。</p>\n<p>HTTP是用于传输诸如HTML的超媒体文档的 <strong>应用层</strong> 协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的 <strong>客户端-服务端模型</strong> ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用；也就是说，一个不会像UDP协议那样静默丢失消息的协议。RUDP作为UDP的可靠的升级版本，是一种合适的替代选择。</p>\n<h4 id=\"通过定义能够知道的特点\"><a href=\"#通过定义能够知道的特点\" class=\"headerlink\" title=\"通过定义能够知道的特点\"></a>通过定义能够知道的特点</h4><ol>\n<li>基于TCP/IP通信协议<br>这部分的知识稍后开篇来讲</li>\n<li>HTTP位于应用层<br>这部分的知识稍后开篇来讲</li>\n<li>遵循客户端-服务端模型<br>C/S(客户端/服务器)模型，是常用的服务器模型，包括现在说的B/S(浏览器/客户端)模型，都是对C/S结构的一种变化或者改进的结构。 TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有服务器都是对等的。但由于资源被数据提供者所垄断，于是产生了C/S模型：所有客户端都通过服务器获取所需资源。</li>\n<li>无状态<br>这里需要区分一下两个概念：<ul>\n<li>__无连接__：每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</li>\n<li>__无状态__：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</li>\n</ul>\n</li>\n</ol>\n<p>在后续的Web发展中需要带有一定的状态，则通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p>\n<h4 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h4><h5 id=\"什么是HTTPS\"><a href=\"#什么是HTTPS\" class=\"headerlink\" title=\"什么是HTTPS\"></a>什么是HTTPS</h5><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>\n<h5 id=\"HTTPS加密机制\"><a href=\"#HTTPS加密机制\" class=\"headerlink\" title=\"HTTPS加密机制\"></a>HTTPS加密机制</h5><p>HTTP中没有加密机制，可以通过 <strong>SSL（Secure Socket Layer 安全套接层）</strong> 或 <strong>TLS（Transport Layer Security 安全层传输协议）</strong> 的组合使用，加密HTTP的通信内容。</p>\n<p>HTTPS是 HTTP Secure 或 HTTP over SSL。</p>\n<p>SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但 <strong>目前主流的还是SSL3.0和TSL1.0</strong> 。</p>\n<p>SSL工作在 <strong>OSI七层模型中的表示层</strong> ，<strong>TCP/IP 四层模型的应用层</strong> 。</p>\n<p>SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。</p>\n<p>SSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。</p>\n<p>SSL/TLS握手阶段分为五步(假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程)：<br>以下引自 <a href=\"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html\">阮一峰的网络日志</a></p>\n<ul>\n<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>\n<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>\n<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>\n<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>\n<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>\n</ul>\n<p>直白解释，在HTTPS使用时，客户端首先发起请求，服务端返回证书，客户端确认无误后，选择对应的公钥开始加密，服务端接收到数据后开始使用服务器的私钥解密。</p>\n<h4 id=\"HTTP-Header\"><a href=\"#HTTP-Header\" class=\"headerlink\" title=\"HTTP Header\"></a>HTTP Header</h4><p>HTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。</p>\n<p>根据不同上下文，可将消息头分为：</p>\n<ul>\n<li>一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li>\n<li>请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。</li>\n<li>响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li>\n<li>实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li>\n</ul>\n<p>常用的头部主要有：</p>\n<table>\n<thead>\n<tr>\n<th>应答头</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Content-Length</td>\n<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>\n</tr>\n<tr>\n<td>Set-Cookie</td>\n<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</td>\n</tr>\n</tbody></table>\n"},{"title":"在一个较大的对象数组里查询指定的对象","date":"2019-08-11T08:00:00.000Z","excerpt":"JS有多种循环方案，那么究竟哪种是最好的呢？","thumbnail":"","_content":"## 较大的数组\n对于较大的数组处理首先考虑两个问题，第一个要使用原生的for循环，即：\n```javascript\nfor(j = 0,len=arr.length; j < len; j++) {\n   \n}\n```\n缓存了数组长度后能够有效提高运行效率，同时原生的性能最好\n附：\n对于较大数组的遍历运行效率比较\n![10000长度数组的运行效率](https://cdn.sparkling.land/public/blog/images/demo_js_performanceAnalysis_jsarrayGoThrough_1.png)\n\n第二个要注意的就是如果可以使用二分法，那么二分后会提高效率，举例说明\n一个Vue的表单中存在带筛选的Boolean值A，那么在数据加载好之后我们可以在`mounted()`周期中添加一个方法，将所有`A===true`的放入数组中，其他的放入另外一个实现二分\n\n## 快速筛选对象\n可以使用ES6的filter方法，过滤掉不符合条件的元素，举例说明：\n```javascript\nconst origin = [\n  {\n    A: \"joasdjfoijas\",\n    B: \"oasdjfojoadsjf\",\n  },\n  {\n    A: \"joasdjfoijaafdafasfs\",\n    B: \"oasdjfojoadsjfdasfasdf\",\n  },\n  {\n    A: \"111\",\n    B: \"Joe\",\n  },\n]\n\nlet result = origin.filter(function(value){\n  return value.A === \"111\"&&value.B === \"Joe\"\n})\n\nconsole.log(result)\n```\n通过Array的filter方法用回调的方式一次比较多个值是否匹配，避免多次遍历\n\n利用`filter`和`map`组合可以大量过滤需要的元素并输出所需要的值，例如：\n```javascript\nvar arr = [{\n  gender: 'man',\n  name: 'john'\n}, {\n  gender: 'woman',\n  name: 'mark'\n}, {\n  gender: 'man',\n  name: 'jerry'\n}]\n// filter : 有条件的筛选，返回条件为true的数组\n// 筛选出性别为男性的名字集合\nvar newArr = arr.filter(n => n.gender === 'man').map(item => {\n  return {\n    name: item.name\n  }\n})\nconsole.log('男性名字集合', newArr)   // => [{name: 'john'}, {name: 'jerry'}]\n\n// 作者：付出\n// 链接：https://juejin.im/post/5a5f3eaf518825733201a6a7\n```\n避免了老式的for+continue，也提高了代码的可读性","source":"_posts/fe/在一个较大的对象数组里查询指定的对象.md","raw":"---\ntags:\n- 前端\n- JavaScript\ncategories: Frontend\ntitle: 在一个较大的对象数组里查询指定的对象\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: JS有多种循环方案，那么究竟哪种是最好的呢？\nthumbnail: ''\n\n---\n## 较大的数组\n对于较大的数组处理首先考虑两个问题，第一个要使用原生的for循环，即：\n```javascript\nfor(j = 0,len=arr.length; j < len; j++) {\n   \n}\n```\n缓存了数组长度后能够有效提高运行效率，同时原生的性能最好\n附：\n对于较大数组的遍历运行效率比较\n![10000长度数组的运行效率](https://cdn.sparkling.land/public/blog/images/demo_js_performanceAnalysis_jsarrayGoThrough_1.png)\n\n第二个要注意的就是如果可以使用二分法，那么二分后会提高效率，举例说明\n一个Vue的表单中存在带筛选的Boolean值A，那么在数据加载好之后我们可以在`mounted()`周期中添加一个方法，将所有`A===true`的放入数组中，其他的放入另外一个实现二分\n\n## 快速筛选对象\n可以使用ES6的filter方法，过滤掉不符合条件的元素，举例说明：\n```javascript\nconst origin = [\n  {\n    A: \"joasdjfoijas\",\n    B: \"oasdjfojoadsjf\",\n  },\n  {\n    A: \"joasdjfoijaafdafasfs\",\n    B: \"oasdjfojoadsjfdasfasdf\",\n  },\n  {\n    A: \"111\",\n    B: \"Joe\",\n  },\n]\n\nlet result = origin.filter(function(value){\n  return value.A === \"111\"&&value.B === \"Joe\"\n})\n\nconsole.log(result)\n```\n通过Array的filter方法用回调的方式一次比较多个值是否匹配，避免多次遍历\n\n利用`filter`和`map`组合可以大量过滤需要的元素并输出所需要的值，例如：\n```javascript\nvar arr = [{\n  gender: 'man',\n  name: 'john'\n}, {\n  gender: 'woman',\n  name: 'mark'\n}, {\n  gender: 'man',\n  name: 'jerry'\n}]\n// filter : 有条件的筛选，返回条件为true的数组\n// 筛选出性别为男性的名字集合\nvar newArr = arr.filter(n => n.gender === 'man').map(item => {\n  return {\n    name: item.name\n  }\n})\nconsole.log('男性名字集合', newArr)   // => [{name: 'john'}, {name: 'jerry'}]\n\n// 作者：付出\n// 链接：https://juejin.im/post/5a5f3eaf518825733201a6a7\n```\n避免了老式的for+continue，也提高了代码的可读性","slug":"fe/在一个较大的对象数组里查询指定的对象","published":1,"updated":"2020-08-01T18:21:52.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib1002aj1wt4gv34vl0","content":"<h2 id=\"较大的数组\"><a href=\"#较大的数组\" class=\"headerlink\" title=\"较大的数组\"></a>较大的数组</h2><p>对于较大的数组处理首先考虑两个问题，第一个要使用原生的for循环，即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>,len=arr.length; j &lt; len; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缓存了数组长度后能够有效提高运行效率，同时原生的性能最好<br>附：<br>对于较大数组的遍历运行效率比较<br><img src=\"https://cdn.sparkling.land/public/blog/images/demo_js_performanceAnalysis_jsarrayGoThrough_1.png\" alt=\"10000长度数组的运行效率\"></p>\n<p>第二个要注意的就是如果可以使用二分法，那么二分后会提高效率，举例说明<br>一个Vue的表单中存在带筛选的Boolean值A，那么在数据加载好之后我们可以在<code>mounted()</code>周期中添加一个方法，将所有<code>A===true</code>的放入数组中，其他的放入另外一个实现二分</p>\n<h2 id=\"快速筛选对象\"><a href=\"#快速筛选对象\" class=\"headerlink\" title=\"快速筛选对象\"></a>快速筛选对象</h2><p>可以使用ES6的filter方法，过滤掉不符合条件的元素，举例说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> origin = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    A: <span class=\"string\">\"joasdjfoijas\"</span>,</span><br><span class=\"line\">    B: <span class=\"string\">\"oasdjfojoadsjf\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    A: <span class=\"string\">\"joasdjfoijaafdafasfs\"</span>,</span><br><span class=\"line\">    B: <span class=\"string\">\"oasdjfojoadsjfdasfasdf\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    A: <span class=\"string\">\"111\"</span>,</span><br><span class=\"line\">    B: <span class=\"string\">\"Joe\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = origin.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value.A === <span class=\"string\">\"111\"</span>&amp;&amp;value.B === <span class=\"string\">\"Joe\"</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)</span><br></pre></td></tr></table></figure>\n<p>通过Array的filter方法用回调的方式一次比较多个值是否匹配，避免多次遍历</p>\n<p>利用<code>filter</code>和<code>map</code>组合可以大量过滤需要的元素并输出所需要的值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [&#123;</span><br><span class=\"line\">  gender: <span class=\"string\">'man'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'john'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  gender: <span class=\"string\">'woman'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'mark'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  gender: <span class=\"string\">'man'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'jerry'</span></span><br><span class=\"line\">&#125;]</span><br><span class=\"line\"><span class=\"comment\">// filter : 有条件的筛选，返回条件为true的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 筛选出性别为男性的名字集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newArr = arr.filter(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n.gender === <span class=\"string\">'man'</span>).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: item.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'男性名字集合'</span>, newArr)   <span class=\"comment\">// =&gt; [&#123;name: 'john'&#125;, &#123;name: 'jerry'&#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作者：付出</span></span><br><span class=\"line\"><span class=\"comment\">// 链接：https://juejin.im/post/5a5f3eaf518825733201a6a7</span></span><br></pre></td></tr></table></figure>\n<p>避免了老式的for+continue，也提高了代码的可读性</p>\n","site":{"data":{}},"more":"<h2 id=\"较大的数组\"><a href=\"#较大的数组\" class=\"headerlink\" title=\"较大的数组\"></a>较大的数组</h2><p>对于较大的数组处理首先考虑两个问题，第一个要使用原生的for循环，即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>,len=arr.length; j &lt; len; j++) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缓存了数组长度后能够有效提高运行效率，同时原生的性能最好<br>附：<br>对于较大数组的遍历运行效率比较<br><img src=\"https://cdn.sparkling.land/public/blog/images/demo_js_performanceAnalysis_jsarrayGoThrough_1.png\" alt=\"10000长度数组的运行效率\"></p>\n<p>第二个要注意的就是如果可以使用二分法，那么二分后会提高效率，举例说明<br>一个Vue的表单中存在带筛选的Boolean值A，那么在数据加载好之后我们可以在<code>mounted()</code>周期中添加一个方法，将所有<code>A===true</code>的放入数组中，其他的放入另外一个实现二分</p>\n<h2 id=\"快速筛选对象\"><a href=\"#快速筛选对象\" class=\"headerlink\" title=\"快速筛选对象\"></a>快速筛选对象</h2><p>可以使用ES6的filter方法，过滤掉不符合条件的元素，举例说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> origin = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    A: <span class=\"string\">\"joasdjfoijas\"</span>,</span><br><span class=\"line\">    B: <span class=\"string\">\"oasdjfojoadsjf\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    A: <span class=\"string\">\"joasdjfoijaafdafasfs\"</span>,</span><br><span class=\"line\">    B: <span class=\"string\">\"oasdjfojoadsjfdasfasdf\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    A: <span class=\"string\">\"111\"</span>,</span><br><span class=\"line\">    B: <span class=\"string\">\"Joe\"</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = origin.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value.A === <span class=\"string\">\"111\"</span>&amp;&amp;value.B === <span class=\"string\">\"Joe\"</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)</span><br></pre></td></tr></table></figure>\n<p>通过Array的filter方法用回调的方式一次比较多个值是否匹配，避免多次遍历</p>\n<p>利用<code>filter</code>和<code>map</code>组合可以大量过滤需要的元素并输出所需要的值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [&#123;</span><br><span class=\"line\">  gender: <span class=\"string\">'man'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'john'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  gender: <span class=\"string\">'woman'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'mark'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  gender: <span class=\"string\">'man'</span>,</span><br><span class=\"line\">  name: <span class=\"string\">'jerry'</span></span><br><span class=\"line\">&#125;]</span><br><span class=\"line\"><span class=\"comment\">// filter : 有条件的筛选，返回条件为true的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 筛选出性别为男性的名字集合</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newArr = arr.filter(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n.gender === <span class=\"string\">'man'</span>).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: item.name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'男性名字集合'</span>, newArr)   <span class=\"comment\">// =&gt; [&#123;name: 'john'&#125;, &#123;name: 'jerry'&#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作者：付出</span></span><br><span class=\"line\"><span class=\"comment\">// 链接：https://juejin.im/post/5a5f3eaf518825733201a6a7</span></span><br></pre></td></tr></table></figure>\n<p>避免了老式的for+continue，也提高了代码的可读性</p>\n"},{"title":"我们为什么需要使用Vuex做状态管理？","date":"2019-08-21T08:00:00.000Z","excerpt":"日常开发使用Vue就或多或少需要用到Vuex，那么Vuex在Vue项目中扮演了什么角色呢？","thumbnail":"","_content":"#### Vuex是什么\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n#### 多个组件共享状态时\n当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：\n\n- 多个视图依赖于同一状态。\n- 来自不同视图的行为需要变更同一状态。\n\n#### Vuex每个方法的区别\n- mutations就是存放如何更改状态\n- getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。\n- actions就是mutation的加强版，它可以通过commit  mutations中的方法来改变状态，最重要的是它可以进行异步操作。\n- modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。","source":"_posts/fe/我们为什么需要使用vuex做状态管理.md","raw":"---\ntags:\n- 前端\n- Vue.js\ncategories: Frontend\ntitle: 我们为什么需要使用Vuex做状态管理？\ndate: 2019-08-22T00:00:00.000+08:00\nexcerpt: 日常开发使用Vue就或多或少需要用到Vuex，那么Vuex在Vue项目中扮演了什么角色呢？\nthumbnail: ''\n\n---\n#### Vuex是什么\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n#### 多个组件共享状态时\n当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：\n\n- 多个视图依赖于同一状态。\n- 来自不同视图的行为需要变更同一状态。\n\n#### Vuex每个方法的区别\n- mutations就是存放如何更改状态\n- getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。\n- actions就是mutation的加强版，它可以通过commit  mutations中的方法来改变状态，最重要的是它可以进行异步操作。\n- modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。","slug":"fe/我们为什么需要使用vuex做状态管理","published":1,"updated":"2020-08-01T18:21:52.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib2002dj1wtet0f3ae0","content":"<h4 id=\"Vuex是什么\"><a href=\"#Vuex是什么\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<h4 id=\"多个组件共享状态时\"><a href=\"#多个组件共享状态时\" class=\"headerlink\" title=\"多个组件共享状态时\"></a>多个组件共享状态时</h4><p>当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>\n<ul>\n<li>多个视图依赖于同一状态。</li>\n<li>来自不同视图的行为需要变更同一状态。</li>\n</ul>\n<h4 id=\"Vuex每个方法的区别\"><a href=\"#Vuex每个方法的区别\" class=\"headerlink\" title=\"Vuex每个方法的区别\"></a>Vuex每个方法的区别</h4><ul>\n<li>mutations就是存放如何更改状态</li>\n<li>getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。</li>\n<li>actions就是mutation的加强版，它可以通过commit  mutations中的方法来改变状态，最重要的是它可以进行异步操作。</li>\n<li>modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。</li>\n</ul>\n","site":{"data":{}},"more":"<h4 id=\"Vuex是什么\"><a href=\"#Vuex是什么\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<h4 id=\"多个组件共享状态时\"><a href=\"#多个组件共享状态时\" class=\"headerlink\" title=\"多个组件共享状态时\"></a>多个组件共享状态时</h4><p>当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</p>\n<ul>\n<li>多个视图依赖于同一状态。</li>\n<li>来自不同视图的行为需要变更同一状态。</li>\n</ul>\n<h4 id=\"Vuex每个方法的区别\"><a href=\"#Vuex每个方法的区别\" class=\"headerlink\" title=\"Vuex每个方法的区别\"></a>Vuex每个方法的区别</h4><ul>\n<li>mutations就是存放如何更改状态</li>\n<li>getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。</li>\n<li>actions就是mutation的加强版，它可以通过commit  mutations中的方法来改变状态，最重要的是它可以进行异步操作。</li>\n<li>modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。</li>\n</ul>\n"},{"title":"执行NPM命令报lifecycle的警告解决","date":"2019-12-27T08:00:00.000Z","excerpt":"","thumbnail":"","_content":"今天使用npm时，发现了一条如下的警告：\n\n> npm WARN lifecycle The node binary used for scripts is /var/folders/g_/dslq6ff90pn_wyjv5g6578qm0000gn/T/yarn--1577473189287-0.1962072526914138/node but npm is using /usr/local/Cellar/node/13.5.0/bin/node itself. Use the \\`--scripts-prepend-node-path\\` option to include the path for the node binary npm was executed with.\n\n这是因为yarn运行在独立的yarn环境下，解决此警告需要设置一条全局的config\n\n    npm config set scripts-prepend-node-path true","source":"_posts/fe/执行npm命令报lifecycle的警告解决.md","raw":"---\ntags:\n- NPM\ncategories: Frontend\ntitle: 执行NPM命令报lifecycle的警告解决\ndate: 2019-12-28T00:00:00.000+08:00\nexcerpt: ''\nthumbnail: ''\n\n---\n今天使用npm时，发现了一条如下的警告：\n\n> npm WARN lifecycle The node binary used for scripts is /var/folders/g_/dslq6ff90pn_wyjv5g6578qm0000gn/T/yarn--1577473189287-0.1962072526914138/node but npm is using /usr/local/Cellar/node/13.5.0/bin/node itself. Use the \\`--scripts-prepend-node-path\\` option to include the path for the node binary npm was executed with.\n\n这是因为yarn运行在独立的yarn环境下，解决此警告需要设置一条全局的config\n\n    npm config set scripts-prepend-node-path true","slug":"fe/执行npm命令报lifecycle的警告解决","published":1,"updated":"2020-07-27T15:54:32.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib3002gj1wt9erh2v3k","content":"<p>今天使用npm时，发现了一条如下的警告：</p>\n<blockquote>\n<p>npm WARN lifecycle The node binary used for scripts is /var/folders/g_/dslq6ff90pn_wyjv5g6578qm0000gn/T/yarn–1577473189287-0.1962072526914138/node but npm is using /usr/local/Cellar/node/13.5.0/bin/node itself. Use the `–scripts-prepend-node-path` option to include the path for the node binary npm was executed with.</p>\n</blockquote>\n<p>这是因为yarn运行在独立的yarn环境下，解决此警告需要设置一条全局的config</p>\n<pre><code>npm config set scripts-prepend-node-path true</code></pre>\n","site":{"data":{}},"more":"<p>今天使用npm时，发现了一条如下的警告：</p>\n<blockquote>\n<p>npm WARN lifecycle The node binary used for scripts is /var/folders/g_/dslq6ff90pn_wyjv5g6578qm0000gn/T/yarn–1577473189287-0.1962072526914138/node but npm is using /usr/local/Cellar/node/13.5.0/bin/node itself. Use the `–scripts-prepend-node-path` option to include the path for the node binary npm was executed with.</p>\n</blockquote>\n<p>这是因为yarn运行在独立的yarn环境下，解决此警告需要设置一条全局的config</p>\n<pre><code>npm config set scripts-prepend-node-path true</code></pre>\n"},{"title":"Node.js环境log颜色表","date":"2019-08-11T08:00:00.000Z","excerpt":"如果你想自己实现一个Node.js CLI，不妨加入一些颜色来使CLI的交互感更好吧。","thumbnail":"","_content":"Refer from: [https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color]()\n\n```javascript\nconsole.log('\\x1b[36m%s\\x1b[0m', 'I am cyan') //cyan\nconsole.log('\\x1b[33m%s\\x1b[0m', stringToMakeYellow) //yellow\n```\n\n通过配置 log，达到实现不同颜色的目的，下面是一些常用的颜色\n\n```javascript\nReset = '\\x1b[0m'\nBright = '\\x1b[1m'\nDim = '\\x1b[2m'\nUnderscore = '\\x1b[4m'\nBlink = '\\x1b[5m'\nReverse = '\\x1b[7m'\nHidden = '\\x1b[8m'\n\nFgBlack = '\\x1b[30m'\nFgRed = '\\x1b[31m'\nFgGreen = '\\x1b[32m'\nFgYellow = '\\x1b[33m'\nFgBlue = '\\x1b[34m'\nFgMagenta = '\\x1b[35m'\nFgCyan = '\\x1b[36m'\nFgWhite = '\\x1b[37m'\n\nBgBlack = '\\x1b[40m'\nBgRed = '\\x1b[41m'\nBgGreen = '\\x1b[42m'\nBgYellow = '\\x1b[43m'\nBgBlue = '\\x1b[44m'\nBgMagenta = '\\x1b[45m'\nBgCyan = '\\x1b[46m'\nBgWhite = '\\x1b[47m'\n```\n\naddons: 在可以引用其他库的环境中，也可以使用`inquirer`，能够完成大部分情况比如：\n\n- 错误回显\n- “提问”模式\n- 输入格式化\n- 回答校验\n- 管理多重选项\n\n用法详见[npm](https://www.npmjs.com/package/inquirer)","source":"_posts/fe/node-js环境log颜色表.md","raw":"---\ntags:\n- Node.js\ncategories: Frontend\ntitle: Node.js环境log颜色表\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: 如果你想自己实现一个Node.js CLI，不妨加入一些颜色来使CLI的交互感更好吧。\nthumbnail: ''\n\n---\nRefer from: [https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color]()\n\n```javascript\nconsole.log('\\x1b[36m%s\\x1b[0m', 'I am cyan') //cyan\nconsole.log('\\x1b[33m%s\\x1b[0m', stringToMakeYellow) //yellow\n```\n\n通过配置 log，达到实现不同颜色的目的，下面是一些常用的颜色\n\n```javascript\nReset = '\\x1b[0m'\nBright = '\\x1b[1m'\nDim = '\\x1b[2m'\nUnderscore = '\\x1b[4m'\nBlink = '\\x1b[5m'\nReverse = '\\x1b[7m'\nHidden = '\\x1b[8m'\n\nFgBlack = '\\x1b[30m'\nFgRed = '\\x1b[31m'\nFgGreen = '\\x1b[32m'\nFgYellow = '\\x1b[33m'\nFgBlue = '\\x1b[34m'\nFgMagenta = '\\x1b[35m'\nFgCyan = '\\x1b[36m'\nFgWhite = '\\x1b[37m'\n\nBgBlack = '\\x1b[40m'\nBgRed = '\\x1b[41m'\nBgGreen = '\\x1b[42m'\nBgYellow = '\\x1b[43m'\nBgBlue = '\\x1b[44m'\nBgMagenta = '\\x1b[45m'\nBgCyan = '\\x1b[46m'\nBgWhite = '\\x1b[47m'\n```\n\naddons: 在可以引用其他库的环境中，也可以使用`inquirer`，能够完成大部分情况比如：\n\n- 错误回显\n- “提问”模式\n- 输入格式化\n- 回答校验\n- 管理多重选项\n\n用法详见[npm](https://www.npmjs.com/package/inquirer)","slug":"fe/node-js环境log颜色表","published":1,"updated":"2020-08-02T12:34:30.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib4002jj1wt566u738s","content":"<p>Refer from: <a href=\"\">https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'\\x1b[36m%s\\x1b[0m'</span>, <span class=\"string\">'I am cyan'</span>) <span class=\"comment\">//cyan</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'\\x1b[33m%s\\x1b[0m'</span>, stringToMakeYellow) <span class=\"comment\">//yellow</span></span><br></pre></td></tr></table></figure>\n\n<p>通过配置 log，达到实现不同颜色的目的，下面是一些常用的颜色</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reset = <span class=\"string\">'\\x1b[0m'</span></span><br><span class=\"line\">Bright = <span class=\"string\">'\\x1b[1m'</span></span><br><span class=\"line\">Dim = <span class=\"string\">'\\x1b[2m'</span></span><br><span class=\"line\">Underscore = <span class=\"string\">'\\x1b[4m'</span></span><br><span class=\"line\">Blink = <span class=\"string\">'\\x1b[5m'</span></span><br><span class=\"line\">Reverse = <span class=\"string\">'\\x1b[7m'</span></span><br><span class=\"line\">Hidden = <span class=\"string\">'\\x1b[8m'</span></span><br><span class=\"line\"></span><br><span class=\"line\">FgBlack = <span class=\"string\">'\\x1b[30m'</span></span><br><span class=\"line\">FgRed = <span class=\"string\">'\\x1b[31m'</span></span><br><span class=\"line\">FgGreen = <span class=\"string\">'\\x1b[32m'</span></span><br><span class=\"line\">FgYellow = <span class=\"string\">'\\x1b[33m'</span></span><br><span class=\"line\">FgBlue = <span class=\"string\">'\\x1b[34m'</span></span><br><span class=\"line\">FgMagenta = <span class=\"string\">'\\x1b[35m'</span></span><br><span class=\"line\">FgCyan = <span class=\"string\">'\\x1b[36m'</span></span><br><span class=\"line\">FgWhite = <span class=\"string\">'\\x1b[37m'</span></span><br><span class=\"line\"></span><br><span class=\"line\">BgBlack = <span class=\"string\">'\\x1b[40m'</span></span><br><span class=\"line\">BgRed = <span class=\"string\">'\\x1b[41m'</span></span><br><span class=\"line\">BgGreen = <span class=\"string\">'\\x1b[42m'</span></span><br><span class=\"line\">BgYellow = <span class=\"string\">'\\x1b[43m'</span></span><br><span class=\"line\">BgBlue = <span class=\"string\">'\\x1b[44m'</span></span><br><span class=\"line\">BgMagenta = <span class=\"string\">'\\x1b[45m'</span></span><br><span class=\"line\">BgCyan = <span class=\"string\">'\\x1b[46m'</span></span><br><span class=\"line\">BgWhite = <span class=\"string\">'\\x1b[47m'</span></span><br></pre></td></tr></table></figure>\n\n<p>addons: 在可以引用其他库的环境中，也可以使用<code>inquirer</code>，能够完成大部分情况比如：</p>\n<ul>\n<li>错误回显</li>\n<li>“提问”模式</li>\n<li>输入格式化</li>\n<li>回答校验</li>\n<li>管理多重选项</li>\n</ul>\n<p>用法详见<a href=\"https://www.npmjs.com/package/inquirer\">npm</a></p>\n","site":{"data":{}},"more":"<p>Refer from: <a href=\"\">https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'\\x1b[36m%s\\x1b[0m'</span>, <span class=\"string\">'I am cyan'</span>) <span class=\"comment\">//cyan</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'\\x1b[33m%s\\x1b[0m'</span>, stringToMakeYellow) <span class=\"comment\">//yellow</span></span><br></pre></td></tr></table></figure>\n\n<p>通过配置 log，达到实现不同颜色的目的，下面是一些常用的颜色</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Reset = <span class=\"string\">'\\x1b[0m'</span></span><br><span class=\"line\">Bright = <span class=\"string\">'\\x1b[1m'</span></span><br><span class=\"line\">Dim = <span class=\"string\">'\\x1b[2m'</span></span><br><span class=\"line\">Underscore = <span class=\"string\">'\\x1b[4m'</span></span><br><span class=\"line\">Blink = <span class=\"string\">'\\x1b[5m'</span></span><br><span class=\"line\">Reverse = <span class=\"string\">'\\x1b[7m'</span></span><br><span class=\"line\">Hidden = <span class=\"string\">'\\x1b[8m'</span></span><br><span class=\"line\"></span><br><span class=\"line\">FgBlack = <span class=\"string\">'\\x1b[30m'</span></span><br><span class=\"line\">FgRed = <span class=\"string\">'\\x1b[31m'</span></span><br><span class=\"line\">FgGreen = <span class=\"string\">'\\x1b[32m'</span></span><br><span class=\"line\">FgYellow = <span class=\"string\">'\\x1b[33m'</span></span><br><span class=\"line\">FgBlue = <span class=\"string\">'\\x1b[34m'</span></span><br><span class=\"line\">FgMagenta = <span class=\"string\">'\\x1b[35m'</span></span><br><span class=\"line\">FgCyan = <span class=\"string\">'\\x1b[36m'</span></span><br><span class=\"line\">FgWhite = <span class=\"string\">'\\x1b[37m'</span></span><br><span class=\"line\"></span><br><span class=\"line\">BgBlack = <span class=\"string\">'\\x1b[40m'</span></span><br><span class=\"line\">BgRed = <span class=\"string\">'\\x1b[41m'</span></span><br><span class=\"line\">BgGreen = <span class=\"string\">'\\x1b[42m'</span></span><br><span class=\"line\">BgYellow = <span class=\"string\">'\\x1b[43m'</span></span><br><span class=\"line\">BgBlue = <span class=\"string\">'\\x1b[44m'</span></span><br><span class=\"line\">BgMagenta = <span class=\"string\">'\\x1b[45m'</span></span><br><span class=\"line\">BgCyan = <span class=\"string\">'\\x1b[46m'</span></span><br><span class=\"line\">BgWhite = <span class=\"string\">'\\x1b[47m'</span></span><br></pre></td></tr></table></figure>\n\n<p>addons: 在可以引用其他库的环境中，也可以使用<code>inquirer</code>，能够完成大部分情况比如：</p>\n<ul>\n<li>错误回显</li>\n<li>“提问”模式</li>\n<li>输入格式化</li>\n<li>回答校验</li>\n<li>管理多重选项</li>\n</ul>\n<p>用法详见<a href=\"https://www.npmjs.com/package/inquirer\">npm</a></p>\n"},{"title":"OSI七层模型&TCP/IP四层模型","date":"2019-08-19T08:00:00.000Z","excerpt":"OSI七层模型，本科计算机网络的“老番”，其实对于前端而言，相对底层的接触会比较少，更多的仍在上层。","thumbnail":"","_content":"#### OSI七层模型\n\nOSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。\nOSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。\n\n* **物理层（Physical Layer）**：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。\n* **数据链路层（Datalink Layer）**：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。\n* **网络层（Network Layer）**：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）\n* **传输层（Transport Layer）**：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。\n* **会话层（Session Layer）**：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。\n* **表示层（Presentation Layer）**：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。\n* **应用层（Application Layer）**： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。\n\n#### TCP/IP四层模型\n\nTCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。\n\nTCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。\nTCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为：\n\n* 应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。\n* 传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。\n* 网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。\n* 网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。\n\n![对比图示](https://cdn.sparkling.land/public/blog/images/2018032308260661_hwybit.jpg)","source":"_posts/fe/osi七层模型-tcp-ip四层模型.md","raw":"---\ntags:\n- HTTP\ncategories: Frontend\ntitle: OSI七层模型&TCP/IP四层模型\ndate: 2019-08-19T16:00:00.000+00:00\nexcerpt: OSI七层模型，本科计算机网络的“老番”，其实对于前端而言，相对底层的接触会比较少，更多的仍在上层。\nthumbnail: ''\n\n---\n#### OSI七层模型\n\nOSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。\nOSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。\n\n* **物理层（Physical Layer）**：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。\n* **数据链路层（Datalink Layer）**：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。\n* **网络层（Network Layer）**：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）\n* **传输层（Transport Layer）**：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。\n* **会话层（Session Layer）**：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。\n* **表示层（Presentation Layer）**：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。\n* **应用层（Application Layer）**： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。\n\n#### TCP/IP四层模型\n\nTCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。\n\nTCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。\nTCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为：\n\n* 应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。\n* 传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。\n* 网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。\n* 网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。\n\n![对比图示](https://cdn.sparkling.land/public/blog/images/2018032308260661_hwybit.jpg)","slug":"fe/osi七层模型-tcp-ip四层模型","published":1,"updated":"2020-08-02T12:34:30.521Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib5002mj1wt746sgyqt","content":"<h4 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h4><p>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。<br>OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</p>\n<ul>\n<li><strong>物理层（Physical Layer）</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。</li>\n<li><strong>数据链路层（Datalink Layer）</strong>：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。</li>\n<li><strong>网络层（Network Layer）</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）</li>\n<li><strong>传输层（Transport Layer）</strong>：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。</li>\n<li><strong>会话层（Session Layer）</strong>：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li>\n<li><strong>表示层（Presentation Layer）</strong>：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>\n<li><strong>应用层（Application Layer）</strong>： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li>\n</ul>\n<h4 id=\"TCP-IP四层模型\"><a href=\"#TCP-IP四层模型\" class=\"headerlink\" title=\"TCP/IP四层模型\"></a>TCP/IP四层模型</h4><p>TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。</p>\n<p>TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。<br>TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为：</p>\n<ul>\n<li>应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。</li>\n<li>传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。</li>\n<li>网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。</li>\n<li>网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。</li>\n</ul>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/2018032308260661_hwybit.jpg\" alt=\"对比图示\"></p>\n","site":{"data":{}},"more":"<h4 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h4><p>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。<br>OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</p>\n<ul>\n<li><strong>物理层（Physical Layer）</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。</li>\n<li><strong>数据链路层（Datalink Layer）</strong>：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。</li>\n<li><strong>网络层（Network Layer）</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）</li>\n<li><strong>传输层（Transport Layer）</strong>：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。</li>\n<li><strong>会话层（Session Layer）</strong>：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li>\n<li><strong>表示层（Presentation Layer）</strong>：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>\n<li><strong>应用层（Application Layer）</strong>： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li>\n</ul>\n<h4 id=\"TCP-IP四层模型\"><a href=\"#TCP-IP四层模型\" class=\"headerlink\" title=\"TCP/IP四层模型\"></a>TCP/IP四层模型</h4><p>TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。</p>\n<p>TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。<br>TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为：</p>\n<ul>\n<li>应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。</li>\n<li>传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。</li>\n<li>网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。</li>\n<li>网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。</li>\n</ul>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/2018032308260661_hwybit.jpg\" alt=\"对比图示\"></p>\n"},{"title":"Bye QYER","date":"2019-08-17T08:00:00.000Z","excerpt":"2019年，入职一年之后还是选择了离开穷游探索更加广泛的天地，不忘初心，加油！","thumbnail":"","_content":"在穷游一年的时间，最终还是选择了离开去寻找更大的环境，希望穷游的一切能够越来越好，希望同事们都能工作顺利！\n\nBye！\n\n![不定期的旅行牛人分享](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011937_rc9nev.jpg \"不定期的旅行牛人分享\")\n\n![英式电话亭](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011907_hxhh3l.jpg \"英式电话亭\")\n\n![面试就被火车吸引到了](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011927_vj5kxb.jpg \"面试就被火车吸引到了\")\n\n![JNE的旅行物件](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011931_owanyw.jpg \"JNE的旅行物件\")","source":"_posts/life/bye-qyer.md","raw":"---\ntags:\n- 工作\ncategories: Life\ntitle: Bye QYER\ndate: 2019-08-17T16:00:00.000+00:00\nexcerpt: 2019年，入职一年之后还是选择了离开穷游探索更加广泛的天地，不忘初心，加油！\nthumbnail: ''\n\n---\n在穷游一年的时间，最终还是选择了离开去寻找更大的环境，希望穷游的一切能够越来越好，希望同事们都能工作顺利！\n\nBye！\n\n![不定期的旅行牛人分享](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011937_rc9nev.jpg \"不定期的旅行牛人分享\")\n\n![英式电话亭](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011907_hxhh3l.jpg \"英式电话亭\")\n\n![面试就被火车吸引到了](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011927_vj5kxb.jpg \"面试就被火车吸引到了\")\n\n![JNE的旅行物件](https://cdn.sparkling.land/public/blog/images/微信图片_20190818011931_owanyw.jpg \"JNE的旅行物件\")","slug":"life/bye-qyer","published":1,"updated":"2020-08-01T18:21:52.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib6002pj1wt04le11oc","content":"<p>在穷游一年的时间，最终还是选择了离开去寻找更大的环境，希望穷游的一切能够越来越好，希望同事们都能工作顺利！</p>\n<p>Bye！</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011937_rc9nev.jpg\" alt=\"不定期的旅行牛人分享\" title=\"不定期的旅行牛人分享\"></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011907_hxhh3l.jpg\" alt=\"英式电话亭\" title=\"英式电话亭\"></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011927_vj5kxb.jpg\" alt=\"面试就被火车吸引到了\" title=\"面试就被火车吸引到了\"></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011931_owanyw.jpg\" alt=\"JNE的旅行物件\" title=\"JNE的旅行物件\"></p>\n","site":{"data":{}},"more":"<p>在穷游一年的时间，最终还是选择了离开去寻找更大的环境，希望穷游的一切能够越来越好，希望同事们都能工作顺利！</p>\n<p>Bye！</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011937_rc9nev.jpg\" alt=\"不定期的旅行牛人分享\" title=\"不定期的旅行牛人分享\"></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011907_hxhh3l.jpg\" alt=\"英式电话亭\" title=\"英式电话亭\"></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011927_vj5kxb.jpg\" alt=\"面试就被火车吸引到了\" title=\"面试就被火车吸引到了\"></p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190818011931_owanyw.jpg\" alt=\"JNE的旅行物件\" title=\"JNE的旅行物件\"></p>\n"},{"title":"移动端iOS特殊的点击事件","date":"2019-08-12T08:00:00.000Z","excerpt":"又在iOS的点击事件上踩坑了，iOS的Safari会对触发条件要求比较高，如果你也踩坑了可以花几分钟看看","thumbnail":"","_content":"### 起因\n\n目前需要做一个 SDK，挂载到全局完成一些标记的时间，因此需要借助`document.body.addEventListener`的方式，那么废话不多说，一把 suo\n\n```javascript\ndocument.body.addEventListener('click', function(e) {\n  console.log('成功触发:' + e.target)\n})\n```\n\n正当我觉得这一切没什么问题的时候，测试发现了 Bug\n\n| iOS 设备不能正常的触发啊\n\n这种情况只能回头看代码了，这里有如下代码\n\n```html\n<p data-xxx=\"test\"></p>\n```\n\n通过上面的事件监听，我发现 iOS 设备压根没有成功的添加到这个节点，那么是什么问题呢？\n\n### Bug or Feature?\n\n经过一系列尝试我发现， **位于 body 的事件是无法在捕获/冒泡阶段在 iOS 设备触发事件** , 这就触及到知识盲区了，赶紧翻阅相关网站查找资料\n\n### Fix\n\n经过查阅，以下方法可以修复这个问题：\n\n- onclick\n- `<a href=\"javascript:void(0);\">`\n- `cursor: pointer;` body 或者对应元素\n- `<button>`\n- `click` -> `touchstart`\n\n以上方案来讲，样式最清晰，改动最小，touchstart 方案也是比较容易实现的，但需要注意 touchend","source":"_posts/fe/移动端ios特殊的点击事件.md","raw":"---\ntags:\n- Safari\ncategories: Frontend\ntitle: 移动端iOS特殊的点击事件\ndate: 2019-08-13T00:00:00.000+08:00\nexcerpt: 又在iOS的点击事件上踩坑了，iOS的Safari会对触发条件要求比较高，如果你也踩坑了可以花几分钟看看\nthumbnail: ''\n\n---\n### 起因\n\n目前需要做一个 SDK，挂载到全局完成一些标记的时间，因此需要借助`document.body.addEventListener`的方式，那么废话不多说，一把 suo\n\n```javascript\ndocument.body.addEventListener('click', function(e) {\n  console.log('成功触发:' + e.target)\n})\n```\n\n正当我觉得这一切没什么问题的时候，测试发现了 Bug\n\n| iOS 设备不能正常的触发啊\n\n这种情况只能回头看代码了，这里有如下代码\n\n```html\n<p data-xxx=\"test\"></p>\n```\n\n通过上面的事件监听，我发现 iOS 设备压根没有成功的添加到这个节点，那么是什么问题呢？\n\n### Bug or Feature?\n\n经过一系列尝试我发现， **位于 body 的事件是无法在捕获/冒泡阶段在 iOS 设备触发事件** , 这就触及到知识盲区了，赶紧翻阅相关网站查找资料\n\n### Fix\n\n经过查阅，以下方法可以修复这个问题：\n\n- onclick\n- `<a href=\"javascript:void(0);\">`\n- `cursor: pointer;` body 或者对应元素\n- `<button>`\n- `click` -> `touchstart`\n\n以上方案来讲，样式最清晰，改动最小，touchstart 方案也是比较容易实现的，但需要注意 touchend","slug":"fe/移动端ios特殊的点击事件","published":1,"updated":"2020-08-01T18:21:52.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib7002tj1wt9fs16ny3","content":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>目前需要做一个 SDK，挂载到全局完成一些标记的时间，因此需要借助<code>document.body.addEventListener</code>的方式，那么废话不多说，一把 suo</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'成功触发:'</span> + e.target)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>正当我觉得这一切没什么问题的时候，测试发现了 Bug</p>\n<p>| iOS 设备不能正常的触发啊</p>\n<p>这种情况只能回头看代码了，这里有如下代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">data-xxx</span>=<span class=\"string\">\"test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的事件监听，我发现 iOS 设备压根没有成功的添加到这个节点，那么是什么问题呢？</p>\n<h3 id=\"Bug-or-Feature\"><a href=\"#Bug-or-Feature\" class=\"headerlink\" title=\"Bug or Feature?\"></a>Bug or Feature?</h3><p>经过一系列尝试我发现， <strong>位于 body 的事件是无法在捕获/冒泡阶段在 iOS 设备触发事件</strong> , 这就触及到知识盲区了，赶紧翻阅相关网站查找资料</p>\n<h3 id=\"Fix\"><a href=\"#Fix\" class=\"headerlink\" title=\"Fix\"></a>Fix</h3><p>经过查阅，以下方法可以修复这个问题：</p>\n<ul>\n<li>onclick</li>\n<li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;</code></li>\n<li><code>cursor: pointer;</code> body 或者对应元素</li>\n<li><code>&lt;button&gt;</code></li>\n<li><code>click</code> -&gt; <code>touchstart</code></li>\n</ul>\n<p>以上方案来讲，样式最清晰，改动最小，touchstart 方案也是比较容易实现的，但需要注意 touchend</p>\n","site":{"data":{}},"more":"<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>目前需要做一个 SDK，挂载到全局完成一些标记的时间，因此需要借助<code>document.body.addEventListener</code>的方式，那么废话不多说，一把 suo</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'成功触发:'</span> + e.target)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>正当我觉得这一切没什么问题的时候，测试发现了 Bug</p>\n<p>| iOS 设备不能正常的触发啊</p>\n<p>这种情况只能回头看代码了，这里有如下代码</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">data-xxx</span>=<span class=\"string\">\"test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面的事件监听，我发现 iOS 设备压根没有成功的添加到这个节点，那么是什么问题呢？</p>\n<h3 id=\"Bug-or-Feature\"><a href=\"#Bug-or-Feature\" class=\"headerlink\" title=\"Bug or Feature?\"></a>Bug or Feature?</h3><p>经过一系列尝试我发现， <strong>位于 body 的事件是无法在捕获/冒泡阶段在 iOS 设备触发事件</strong> , 这就触及到知识盲区了，赶紧翻阅相关网站查找资料</p>\n<h3 id=\"Fix\"><a href=\"#Fix\" class=\"headerlink\" title=\"Fix\"></a>Fix</h3><p>经过查阅，以下方法可以修复这个问题：</p>\n<ul>\n<li>onclick</li>\n<li><code>&lt;a href=&quot;javascript:void(0);&quot;&gt;</code></li>\n<li><code>cursor: pointer;</code> body 或者对应元素</li>\n<li><code>&lt;button&gt;</code></li>\n<li><code>click</code> -&gt; <code>touchstart</code></li>\n</ul>\n<p>以上方案来讲，样式最清晰，改动最小，touchstart 方案也是比较容易实现的，但需要注意 touchend</p>\n"},{"date":"2020-02-27T11:09:27.000Z","title":"对于前端熟悉又陌生的RIA","excerpt":"RIA算是一个几年前的概念了，但是目前仍有一些旧的应用还在使用诸如Flash等等过去RIA常用的技术，因此对于前端而言，了解还是很有必要的。","thumbnail":"","_content":"### RIA是什么？\n\nWiki百科对RIA的定义是：\n\n> 丰富互联网应用程序（英语：Rich Internet applications，简称RIA），又译为丰富性网络应用服务，是一种具有近似于传统桌面应用软件系统功能和特性的网络应用系统。RIA系统最大的特点是将大部分处理任务都从用户界面端移植到客户端，仅保留一些必要数据与服务器端进行信息交互。\n\n其中比较重要的特性有两个，第一点它依赖于浏览器环境，第二点是运行在独立的沙箱内部。\n\n### RIA有哪些应用？\n\n我在Vista系统的年代，下载过“三国杀”的客户端，原来是在浏览器环境内的一个Flash，后来有了Flash AIR的客户端，可以“脱离”浏览器环境运行独立的三国杀游戏。\n\n~~之所以说是“脱离”，其实只是不在浏览器内，本质还是需要调用Flash组件与功能。~~\n\n当然，依托于客户端能力，避免了频繁的页面请求，能够对运行和本地化起到比较关键的作用，也能够复用在页面使用的Flash等技术，更有效的利用客户端能力。\n\n### RIA在2020年的新面貌\n\n前一阵看到了一所国外大学的测试平台仍在使用Flash作为录音插件，众所周知，2020年Flash已经正式被各大浏览器所废弃，用户在使用这种旧方式的时候就需要通过设置临时开启Flash功能来正常完成测试。\n\n但是不是说Flash被废弃后，RIA就没有了存在的意义呢？\n\n我想并不是的，RIA更多的是一种思想，能够将前端技术扩展到更多的端，能够利用更多的客户端能力，是Flash等旧一代技术“退役”后不变的方向。\n\n现在我们可以用Electron打包Web App，完成从浏览器端到客户端的过程；我们还可以借助部分浏览器支持的PWA特性，直接安装网页程序，或是通过Service Worker，增强本身的客户端能力。\n\n除此之外，UWP以及Chrome插件环境也是前端技术在客户端的第二春，他们在实现上与浏览器非常类似，都能够实现更强的本地化需求。","source":"_posts/fe/对于前端熟悉又陌生的ria.md","raw":"---\ncategories: Frontend\ntags:\n- 前端\ndate: 2020-02-28T03:09:27.000+08:00\ntitle: 对于前端熟悉又陌生的RIA\nexcerpt: RIA算是一个几年前的概念了，但是目前仍有一些旧的应用还在使用诸如Flash等等过去RIA常用的技术，因此对于前端而言，了解还是很有必要的。\nthumbnail: ''\n\n---\n### RIA是什么？\n\nWiki百科对RIA的定义是：\n\n> 丰富互联网应用程序（英语：Rich Internet applications，简称RIA），又译为丰富性网络应用服务，是一种具有近似于传统桌面应用软件系统功能和特性的网络应用系统。RIA系统最大的特点是将大部分处理任务都从用户界面端移植到客户端，仅保留一些必要数据与服务器端进行信息交互。\n\n其中比较重要的特性有两个，第一点它依赖于浏览器环境，第二点是运行在独立的沙箱内部。\n\n### RIA有哪些应用？\n\n我在Vista系统的年代，下载过“三国杀”的客户端，原来是在浏览器环境内的一个Flash，后来有了Flash AIR的客户端，可以“脱离”浏览器环境运行独立的三国杀游戏。\n\n~~之所以说是“脱离”，其实只是不在浏览器内，本质还是需要调用Flash组件与功能。~~\n\n当然，依托于客户端能力，避免了频繁的页面请求，能够对运行和本地化起到比较关键的作用，也能够复用在页面使用的Flash等技术，更有效的利用客户端能力。\n\n### RIA在2020年的新面貌\n\n前一阵看到了一所国外大学的测试平台仍在使用Flash作为录音插件，众所周知，2020年Flash已经正式被各大浏览器所废弃，用户在使用这种旧方式的时候就需要通过设置临时开启Flash功能来正常完成测试。\n\n但是不是说Flash被废弃后，RIA就没有了存在的意义呢？\n\n我想并不是的，RIA更多的是一种思想，能够将前端技术扩展到更多的端，能够利用更多的客户端能力，是Flash等旧一代技术“退役”后不变的方向。\n\n现在我们可以用Electron打包Web App，完成从浏览器端到客户端的过程；我们还可以借助部分浏览器支持的PWA特性，直接安装网页程序，或是通过Service Worker，增强本身的客户端能力。\n\n除此之外，UWP以及Chrome插件环境也是前端技术在客户端的第二春，他们在实现上与浏览器非常类似，都能够实现更强的本地化需求。","slug":"fe/对于前端熟悉又陌生的ria","published":1,"updated":"2020-08-02T12:34:30.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib8002xj1wt8jmf1cro","content":"<h3 id=\"RIA是什么？\"><a href=\"#RIA是什么？\" class=\"headerlink\" title=\"RIA是什么？\"></a>RIA是什么？</h3><p>Wiki百科对RIA的定义是：</p>\n<blockquote>\n<p>丰富互联网应用程序（英语：Rich Internet applications，简称RIA），又译为丰富性网络应用服务，是一种具有近似于传统桌面应用软件系统功能和特性的网络应用系统。RIA系统最大的特点是将大部分处理任务都从用户界面端移植到客户端，仅保留一些必要数据与服务器端进行信息交互。</p>\n</blockquote>\n<p>其中比较重要的特性有两个，第一点它依赖于浏览器环境，第二点是运行在独立的沙箱内部。</p>\n<h3 id=\"RIA有哪些应用？\"><a href=\"#RIA有哪些应用？\" class=\"headerlink\" title=\"RIA有哪些应用？\"></a>RIA有哪些应用？</h3><p>我在Vista系统的年代，下载过“三国杀”的客户端，原来是在浏览器环境内的一个Flash，后来有了Flash AIR的客户端，可以“脱离”浏览器环境运行独立的三国杀游戏。</p>\n<p><del>之所以说是“脱离”，其实只是不在浏览器内，本质还是需要调用Flash组件与功能。</del></p>\n<p>当然，依托于客户端能力，避免了频繁的页面请求，能够对运行和本地化起到比较关键的作用，也能够复用在页面使用的Flash等技术，更有效的利用客户端能力。</p>\n<h3 id=\"RIA在2020年的新面貌\"><a href=\"#RIA在2020年的新面貌\" class=\"headerlink\" title=\"RIA在2020年的新面貌\"></a>RIA在2020年的新面貌</h3><p>前一阵看到了一所国外大学的测试平台仍在使用Flash作为录音插件，众所周知，2020年Flash已经正式被各大浏览器所废弃，用户在使用这种旧方式的时候就需要通过设置临时开启Flash功能来正常完成测试。</p>\n<p>但是不是说Flash被废弃后，RIA就没有了存在的意义呢？</p>\n<p>我想并不是的，RIA更多的是一种思想，能够将前端技术扩展到更多的端，能够利用更多的客户端能力，是Flash等旧一代技术“退役”后不变的方向。</p>\n<p>现在我们可以用Electron打包Web App，完成从浏览器端到客户端的过程；我们还可以借助部分浏览器支持的PWA特性，直接安装网页程序，或是通过Service Worker，增强本身的客户端能力。</p>\n<p>除此之外，UWP以及Chrome插件环境也是前端技术在客户端的第二春，他们在实现上与浏览器非常类似，都能够实现更强的本地化需求。</p>\n","site":{"data":{}},"more":"<h3 id=\"RIA是什么？\"><a href=\"#RIA是什么？\" class=\"headerlink\" title=\"RIA是什么？\"></a>RIA是什么？</h3><p>Wiki百科对RIA的定义是：</p>\n<blockquote>\n<p>丰富互联网应用程序（英语：Rich Internet applications，简称RIA），又译为丰富性网络应用服务，是一种具有近似于传统桌面应用软件系统功能和特性的网络应用系统。RIA系统最大的特点是将大部分处理任务都从用户界面端移植到客户端，仅保留一些必要数据与服务器端进行信息交互。</p>\n</blockquote>\n<p>其中比较重要的特性有两个，第一点它依赖于浏览器环境，第二点是运行在独立的沙箱内部。</p>\n<h3 id=\"RIA有哪些应用？\"><a href=\"#RIA有哪些应用？\" class=\"headerlink\" title=\"RIA有哪些应用？\"></a>RIA有哪些应用？</h3><p>我在Vista系统的年代，下载过“三国杀”的客户端，原来是在浏览器环境内的一个Flash，后来有了Flash AIR的客户端，可以“脱离”浏览器环境运行独立的三国杀游戏。</p>\n<p><del>之所以说是“脱离”，其实只是不在浏览器内，本质还是需要调用Flash组件与功能。</del></p>\n<p>当然，依托于客户端能力，避免了频繁的页面请求，能够对运行和本地化起到比较关键的作用，也能够复用在页面使用的Flash等技术，更有效的利用客户端能力。</p>\n<h3 id=\"RIA在2020年的新面貌\"><a href=\"#RIA在2020年的新面貌\" class=\"headerlink\" title=\"RIA在2020年的新面貌\"></a>RIA在2020年的新面貌</h3><p>前一阵看到了一所国外大学的测试平台仍在使用Flash作为录音插件，众所周知，2020年Flash已经正式被各大浏览器所废弃，用户在使用这种旧方式的时候就需要通过设置临时开启Flash功能来正常完成测试。</p>\n<p>但是不是说Flash被废弃后，RIA就没有了存在的意义呢？</p>\n<p>我想并不是的，RIA更多的是一种思想，能够将前端技术扩展到更多的端，能够利用更多的客户端能力，是Flash等旧一代技术“退役”后不变的方向。</p>\n<p>现在我们可以用Electron打包Web App，完成从浏览器端到客户端的过程；我们还可以借助部分浏览器支持的PWA特性，直接安装网页程序，或是通过Service Worker，增强本身的客户端能力。</p>\n<p>除此之外，UWP以及Chrome插件环境也是前端技术在客户端的第二春，他们在实现上与浏览器非常类似，都能够实现更强的本地化需求。</p>\n"},{"title":"CentOS服务器配置防火墙","date":"2019-08-25T08:00:00.000Z","excerpt":"虽然现在用CentOS较少，（因为Docker的原因，基本都是Ubuntu18.04），但是就作为CheatSheet保留在此吧","thumbnail":"","_content":"- 将端口添加到区域（永久 `--permanent`）\n    ```bash\n    firewall-cmd --zone=public --add-interface=eth0\n    ```\n\n- reload防火墙\n    ```bash\n    firewall-cmd --reload\n    firewall-cmd --complete-reload # 需要断开链接\n    ```\n    \n- 查看指定区域所有打开的端口\n    ```bash\n    firewall-cmd --zone=public --list-ports\n    ```\n    \n- 在指定区域打开端口\n    ```bash\n    firewall-cmd --zone=public --add-port=80/tcp # (永久生效再加上 --permanent, udp设置同理)\n    ```\n    \n- 查看防火墙状态\n    ```bash\n    systemctl status firewalld\n    # firewall-cmd --state\n    ```\n    \n- 防火墙启动/禁用等\n    ```bash\n    systemctl start firewalld # 启动防火墙\n    systemctl stop firewalld # 禁用防火墙\n    systemctl enable firewalld # 设置开机启动\n    sytemctl disable firewalld # 停止并禁用开机启动\n    firewall-cmd --reload # 重启防火墙\n    ```","source":"_posts/other/centos服务器配置防火墙.md","raw":"---\ntags:\n- Linux\ncategories: Other\ntitle: CentOS服务器配置防火墙\ndate: 2019-08-26T00:00:00.000+08:00\nexcerpt: 虽然现在用CentOS较少，（因为Docker的原因，基本都是Ubuntu18.04），但是就作为CheatSheet保留在此吧\nthumbnail: ''\n\n---\n- 将端口添加到区域（永久 `--permanent`）\n    ```bash\n    firewall-cmd --zone=public --add-interface=eth0\n    ```\n\n- reload防火墙\n    ```bash\n    firewall-cmd --reload\n    firewall-cmd --complete-reload # 需要断开链接\n    ```\n    \n- 查看指定区域所有打开的端口\n    ```bash\n    firewall-cmd --zone=public --list-ports\n    ```\n    \n- 在指定区域打开端口\n    ```bash\n    firewall-cmd --zone=public --add-port=80/tcp # (永久生效再加上 --permanent, udp设置同理)\n    ```\n    \n- 查看防火墙状态\n    ```bash\n    systemctl status firewalld\n    # firewall-cmd --state\n    ```\n    \n- 防火墙启动/禁用等\n    ```bash\n    systemctl start firewalld # 启动防火墙\n    systemctl stop firewalld # 禁用防火墙\n    systemctl enable firewalld # 设置开机启动\n    sytemctl disable firewalld # 停止并禁用开机启动\n    firewall-cmd --reload # 重启防火墙\n    ```","slug":"other/centos服务器配置防火墙","published":1,"updated":"2020-08-02T12:34:30.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ib90031j1wt6u6zazzf","content":"<ul>\n<li><p>将端口添加到区域（永久 <code>--permanent</code>）</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-interface=eth0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reload防火墙</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\">firewall-cmd --complete-reload <span class=\"comment\"># 需要断开链接</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看指定区域所有打开的端口</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在指定区域打开端口</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=80/tcp <span class=\"comment\"># (永久生效再加上 --permanent, udp设置同理)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看防火墙状态</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status firewalld</span><br><span class=\"line\"><span class=\"comment\"># firewall-cmd --state</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>防火墙启动/禁用等</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start firewalld <span class=\"comment\"># 启动防火墙</span></span><br><span class=\"line\">systemctl stop firewalld <span class=\"comment\"># 禁用防火墙</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> firewalld <span class=\"comment\"># 设置开机启动</span></span><br><span class=\"line\">sytemctl <span class=\"built_in\">disable</span> firewalld <span class=\"comment\"># 停止并禁用开机启动</span></span><br><span class=\"line\">firewall-cmd --reload <span class=\"comment\"># 重启防火墙</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"more":"<ul>\n<li><p>将端口添加到区域（永久 <code>--permanent</code>）</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-interface=eth0</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>reload防火墙</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --reload</span><br><span class=\"line\">firewall-cmd --complete-reload <span class=\"comment\"># 需要断开链接</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看指定区域所有打开的端口</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在指定区域打开端口</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=80/tcp <span class=\"comment\"># (永久生效再加上 --permanent, udp设置同理)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看防火墙状态</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status firewalld</span><br><span class=\"line\"><span class=\"comment\"># firewall-cmd --state</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>防火墙启动/禁用等</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl start firewalld <span class=\"comment\"># 启动防火墙</span></span><br><span class=\"line\">systemctl stop firewalld <span class=\"comment\"># 禁用防火墙</span></span><br><span class=\"line\">systemctl <span class=\"built_in\">enable</span> firewalld <span class=\"comment\"># 设置开机启动</span></span><br><span class=\"line\">sytemctl <span class=\"built_in\">disable</span> firewalld <span class=\"comment\"># 停止并禁用开机启动</span></span><br><span class=\"line\">firewall-cmd --reload <span class=\"comment\"># 重启防火墙</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"浏览器的重绘（Repaint）与重排（Reflow）机制","date":"2019-08-20T08:00:00.000Z","excerpt":"优化重绘与重排是日常优化页面性能较为常见的手段，了解其机制非常重要。","thumbnail":"","_content":"#### 什么时候会触发重排？\n\n- 添加或删除可见的 DOM 元素\n- 元素位置改变\n- 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）\n- 内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替\n- 页面渲染器初始化\n- 浏览器窗口尺寸改变\n- 获取会导致渲染队列刷新的属性（详细介绍如下）\n\n除此之外，一些获取DOM结构和布局的操作也会触发重排，比如：\n* offsetTop , offsetLeft , offsetWidth , offsetHeight\n* scrollTop , scrollLeft , scrollWidth , scrollHeight\n* clientTop , clientLeft , clientWidth , clientHeight\n* getComputedStyle() ( currentStyle in IE )\n\n#### 为什么说重排比重绘更耗费性能\n\n当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。\n\n重排会导致大量的计算，而重绘的区域已经计算好，相对而言开销小一些，但是要注意，两种情况都是需要一定开销的，一定要尽量减少；\n\n#### 我可以怎么做来避免呢？\n1. 合并多次对样式属性的操作/使用class\n2. 批量修改DOM - 通过生成一个DOM片段后一次性插入文档（可以通过脱离文档流来减少开销）\n3. 缓存布局信息减少获取的操作\n4. 将需要多次重排的元素，position 属性设置为 absolute 或 fixed","source":"_posts/fe/浏览器的重绘-repaint-与重排-reflow-机制.md","raw":"---\ntags:\n- 前端\ncategories: Frontend\ntitle: 浏览器的重绘（Repaint）与重排（Reflow）机制\ndate: 2019-08-21T00:00:00.000+08:00\nexcerpt: 优化重绘与重排是日常优化页面性能较为常见的手段，了解其机制非常重要。\nthumbnail: ''\n\n---\n#### 什么时候会触发重排？\n\n- 添加或删除可见的 DOM 元素\n- 元素位置改变\n- 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）\n- 内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替\n- 页面渲染器初始化\n- 浏览器窗口尺寸改变\n- 获取会导致渲染队列刷新的属性（详细介绍如下）\n\n除此之外，一些获取DOM结构和布局的操作也会触发重排，比如：\n* offsetTop , offsetLeft , offsetWidth , offsetHeight\n* scrollTop , scrollLeft , scrollWidth , scrollHeight\n* clientTop , clientLeft , clientWidth , clientHeight\n* getComputedStyle() ( currentStyle in IE )\n\n#### 为什么说重排比重绘更耗费性能\n\n当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。\n\n重排会导致大量的计算，而重绘的区域已经计算好，相对而言开销小一些，但是要注意，两种情况都是需要一定开销的，一定要尽量减少；\n\n#### 我可以怎么做来避免呢？\n1. 合并多次对样式属性的操作/使用class\n2. 批量修改DOM - 通过生成一个DOM片段后一次性插入文档（可以通过脱离文档流来减少开销）\n3. 缓存布局信息减少获取的操作\n4. 将需要多次重排的元素，position 属性设置为 absolute 或 fixed","slug":"fe/浏览器的重绘-repaint-与重排-reflow-机制","published":1,"updated":"2020-08-02T12:34:30.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5iba0034j1wt9x7j1rxm","content":"<h4 id=\"什么时候会触发重排？\"><a href=\"#什么时候会触发重排？\" class=\"headerlink\" title=\"什么时候会触发重排？\"></a>什么时候会触发重排？</h4><ul>\n<li>添加或删除可见的 DOM 元素</li>\n<li>元素位置改变</li>\n<li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）</li>\n<li>内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替</li>\n<li>页面渲染器初始化</li>\n<li>浏览器窗口尺寸改变</li>\n<li>获取会导致渲染队列刷新的属性（详细介绍如下）</li>\n</ul>\n<p>除此之外，一些获取DOM结构和布局的操作也会触发重排，比如：</p>\n<ul>\n<li>offsetTop , offsetLeft , offsetWidth , offsetHeight</li>\n<li>scrollTop , scrollLeft , scrollWidth , scrollHeight</li>\n<li>clientTop , clientLeft , clientWidth , clientHeight</li>\n<li>getComputedStyle() ( currentStyle in IE )</li>\n</ul>\n<h4 id=\"为什么说重排比重绘更耗费性能\"><a href=\"#为什么说重排比重绘更耗费性能\" class=\"headerlink\" title=\"为什么说重排比重绘更耗费性能\"></a>为什么说重排比重绘更耗费性能</h4><p>当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。</p>\n<p>重排会导致大量的计算，而重绘的区域已经计算好，相对而言开销小一些，但是要注意，两种情况都是需要一定开销的，一定要尽量减少；</p>\n<h4 id=\"我可以怎么做来避免呢？\"><a href=\"#我可以怎么做来避免呢？\" class=\"headerlink\" title=\"我可以怎么做来避免呢？\"></a>我可以怎么做来避免呢？</h4><ol>\n<li>合并多次对样式属性的操作/使用class</li>\n<li>批量修改DOM - 通过生成一个DOM片段后一次性插入文档（可以通过脱离文档流来减少开销）</li>\n<li>缓存布局信息减少获取的操作</li>\n<li>将需要多次重排的元素，position 属性设置为 absolute 或 fixed</li>\n</ol>\n","site":{"data":{}},"more":"<h4 id=\"什么时候会触发重排？\"><a href=\"#什么时候会触发重排？\" class=\"headerlink\" title=\"什么时候会触发重排？\"></a>什么时候会触发重排？</h4><ul>\n<li>添加或删除可见的 DOM 元素</li>\n<li>元素位置改变</li>\n<li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）</li>\n<li>内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替</li>\n<li>页面渲染器初始化</li>\n<li>浏览器窗口尺寸改变</li>\n<li>获取会导致渲染队列刷新的属性（详细介绍如下）</li>\n</ul>\n<p>除此之外，一些获取DOM结构和布局的操作也会触发重排，比如：</p>\n<ul>\n<li>offsetTop , offsetLeft , offsetWidth , offsetHeight</li>\n<li>scrollTop , scrollLeft , scrollWidth , scrollHeight</li>\n<li>clientTop , clientLeft , clientWidth , clientHeight</li>\n<li>getComputedStyle() ( currentStyle in IE )</li>\n</ul>\n<h4 id=\"为什么说重排比重绘更耗费性能\"><a href=\"#为什么说重排比重绘更耗费性能\" class=\"headerlink\" title=\"为什么说重排比重绘更耗费性能\"></a>为什么说重排比重绘更耗费性能</h4><p>当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。</p>\n<p>重排会导致大量的计算，而重绘的区域已经计算好，相对而言开销小一些，但是要注意，两种情况都是需要一定开销的，一定要尽量减少；</p>\n<h4 id=\"我可以怎么做来避免呢？\"><a href=\"#我可以怎么做来避免呢？\" class=\"headerlink\" title=\"我可以怎么做来避免呢？\"></a>我可以怎么做来避免呢？</h4><ol>\n<li>合并多次对样式属性的操作/使用class</li>\n<li>批量修改DOM - 通过生成一个DOM片段后一次性插入文档（可以通过脱离文档流来减少开销）</li>\n<li>缓存布局信息减少获取的操作</li>\n<li>将需要多次重排的元素，position 属性设置为 absolute 或 fixed</li>\n</ol>\n"},{"title":"SaaS, laaS, PaaS这些名词的快速理解","date":"2020-01-06T08:00:00.000Z","excerpt":"\\*aaS，现在这些概念被各大云平台提来提去，简单说明下概念。","thumbnail":"","_content":"## SaaS (软件即服务：Software as a Service)\n\n> 举个不是非常恰当的例子，我想吃汉堡，我去汉堡店直接点汉堡，这是提供了“产品”来使用。\n\n比如“石墨文档”这一类的在线应用，使用了他人提供好的成品软件，底层硬件和运行环境都交由平台管理，这种模式可以称为SaaS。\n\n## PaaS (平台即服务：Platform as a service)\n\n> 还是汉堡的例子，我觉得汉堡店的汉堡没那味儿，找了个可以DIY的店，这家店不提供成品的汉堡，但是会给我炉灶、炊具之类的，还有相关的材料，我可以自己做出自己需要的汉堡，这里提供了“平台”。\n\n比如国外已经商业化的平台Heroku，这里并不需要用户去配置底层的硬件，只需要在容器内编写业务所需的代码即可。底层的操作系统、语言支持、硬件环境均由平台管理，这种可以称为PaaS。\n\n## laaS (基础设施即服务：Infrastructure as a Service)\n\n> 我觉得DIY的也不够好吃，想了想决定组一片地自己种原料自己管理店铺，自己组装一条生产线专门生产自己喜欢的汉堡。这些资源可以产出各式各样的产品，但是我只是借助它的“基础设施”完成我的需要，这种可以称为laaS。\n\n比如目前的云平台，国外的DigitalOcean等，提供实际的基础设施，用户可以将自己的服务部署在相应的机器上使其运行并得到我们需要的结果，这种可以称为laaS。\n\n## 其他新兴的模式\n\n- 桌面即服务（DaaS）\n- 无服务器计算（Serverless or FaaS）\n\t> 无服务器运算（英语：Serverless computing），又被称为功能即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。—— Wikipedia\n- 安全即服务（Security as a service，SECaaS）\n- 后端即服务（BaaS）\n- 容器即服务 （Containers-as-a-Service）","source":"_posts/other/saas-laas-paas这些名词的快速理解.md","raw":"---\ntags:\n- 概念\ncategories: Other\ntitle: SaaS, laaS, PaaS这些名词的快速理解\ndate: 2020-01-07T00:00:00.000+08:00\nexcerpt: \"\\\\*aaS，现在这些概念被各大云平台提来提去，简单说明下概念。\"\nthumbnail: ''\n\n---\n## SaaS (软件即服务：Software as a Service)\n\n> 举个不是非常恰当的例子，我想吃汉堡，我去汉堡店直接点汉堡，这是提供了“产品”来使用。\n\n比如“石墨文档”这一类的在线应用，使用了他人提供好的成品软件，底层硬件和运行环境都交由平台管理，这种模式可以称为SaaS。\n\n## PaaS (平台即服务：Platform as a service)\n\n> 还是汉堡的例子，我觉得汉堡店的汉堡没那味儿，找了个可以DIY的店，这家店不提供成品的汉堡，但是会给我炉灶、炊具之类的，还有相关的材料，我可以自己做出自己需要的汉堡，这里提供了“平台”。\n\n比如国外已经商业化的平台Heroku，这里并不需要用户去配置底层的硬件，只需要在容器内编写业务所需的代码即可。底层的操作系统、语言支持、硬件环境均由平台管理，这种可以称为PaaS。\n\n## laaS (基础设施即服务：Infrastructure as a Service)\n\n> 我觉得DIY的也不够好吃，想了想决定组一片地自己种原料自己管理店铺，自己组装一条生产线专门生产自己喜欢的汉堡。这些资源可以产出各式各样的产品，但是我只是借助它的“基础设施”完成我的需要，这种可以称为laaS。\n\n比如目前的云平台，国外的DigitalOcean等，提供实际的基础设施，用户可以将自己的服务部署在相应的机器上使其运行并得到我们需要的结果，这种可以称为laaS。\n\n## 其他新兴的模式\n\n- 桌面即服务（DaaS）\n- 无服务器计算（Serverless or FaaS）\n\t> 无服务器运算（英语：Serverless computing），又被称为功能即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。—— Wikipedia\n- 安全即服务（Security as a service，SECaaS）\n- 后端即服务（BaaS）\n- 容器即服务 （Containers-as-a-Service）","slug":"other/saas-laas-paas这些名词的快速理解","published":1,"updated":"2020-11-17T14:15:40.854Z","_id":"ckdev5ibb0038j1wtbug73v9u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"SaaS-软件即服务：Software-as-a-Service\"><a href=\"#SaaS-软件即服务：Software-as-a-Service\" class=\"headerlink\" title=\"SaaS (软件即服务：Software as a Service)\"></a>SaaS (软件即服务：Software as a Service)</h2><blockquote>\n<p>举个不是非常恰当的例子，我想吃汉堡，我去汉堡店直接点汉堡，这是提供了“产品”来使用。</p>\n</blockquote>\n<p>比如“石墨文档”这一类的在线应用，使用了他人提供好的成品软件，底层硬件和运行环境都交由平台管理，这种模式可以称为SaaS。</p>\n<h2 id=\"PaaS-平台即服务：Platform-as-a-service\"><a href=\"#PaaS-平台即服务：Platform-as-a-service\" class=\"headerlink\" title=\"PaaS (平台即服务：Platform as a service)\"></a>PaaS (平台即服务：Platform as a service)</h2><blockquote>\n<p>还是汉堡的例子，我觉得汉堡店的汉堡没那味儿，找了个可以DIY的店，这家店不提供成品的汉堡，但是会给我炉灶、炊具之类的，还有相关的材料，我可以自己做出自己需要的汉堡，这里提供了“平台”。</p>\n</blockquote>\n<p>比如国外已经商业化的平台Heroku，这里并不需要用户去配置底层的硬件，只需要在容器内编写业务所需的代码即可。底层的操作系统、语言支持、硬件环境均由平台管理，这种可以称为PaaS。</p>\n<h2 id=\"laaS-基础设施即服务：Infrastructure-as-a-Service\"><a href=\"#laaS-基础设施即服务：Infrastructure-as-a-Service\" class=\"headerlink\" title=\"laaS (基础设施即服务：Infrastructure as a Service)\"></a>laaS (基础设施即服务：Infrastructure as a Service)</h2><blockquote>\n<p>我觉得DIY的也不够好吃，想了想决定组一片地自己种原料自己管理店铺，自己组装一条生产线专门生产自己喜欢的汉堡。这些资源可以产出各式各样的产品，但是我只是借助它的“基础设施”完成我的需要，这种可以称为laaS。</p>\n</blockquote>\n<p>比如目前的云平台，国外的DigitalOcean等，提供实际的基础设施，用户可以将自己的服务部署在相应的机器上使其运行并得到我们需要的结果，这种可以称为laaS。</p>\n<h2 id=\"其他新兴的模式\"><a href=\"#其他新兴的模式\" class=\"headerlink\" title=\"其他新兴的模式\"></a>其他新兴的模式</h2><ul>\n<li>桌面即服务（DaaS）</li>\n<li>无服务器计算（Serverless or FaaS）<blockquote>\n<p>无服务器运算（英语：Serverless computing），又被称为功能即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。—— Wikipedia</p>\n</blockquote>\n</li>\n<li>安全即服务（Security as a service，SECaaS）</li>\n<li>后端即服务（BaaS）</li>\n<li>容器即服务 （Containers-as-a-Service）</li>\n</ul>\n","site":{"data":{}},"more":"<h2 id=\"SaaS-软件即服务：Software-as-a-Service\"><a href=\"#SaaS-软件即服务：Software-as-a-Service\" class=\"headerlink\" title=\"SaaS (软件即服务：Software as a Service)\"></a>SaaS (软件即服务：Software as a Service)</h2><blockquote>\n<p>举个不是非常恰当的例子，我想吃汉堡，我去汉堡店直接点汉堡，这是提供了“产品”来使用。</p>\n</blockquote>\n<p>比如“石墨文档”这一类的在线应用，使用了他人提供好的成品软件，底层硬件和运行环境都交由平台管理，这种模式可以称为SaaS。</p>\n<h2 id=\"PaaS-平台即服务：Platform-as-a-service\"><a href=\"#PaaS-平台即服务：Platform-as-a-service\" class=\"headerlink\" title=\"PaaS (平台即服务：Platform as a service)\"></a>PaaS (平台即服务：Platform as a service)</h2><blockquote>\n<p>还是汉堡的例子，我觉得汉堡店的汉堡没那味儿，找了个可以DIY的店，这家店不提供成品的汉堡，但是会给我炉灶、炊具之类的，还有相关的材料，我可以自己做出自己需要的汉堡，这里提供了“平台”。</p>\n</blockquote>\n<p>比如国外已经商业化的平台Heroku，这里并不需要用户去配置底层的硬件，只需要在容器内编写业务所需的代码即可。底层的操作系统、语言支持、硬件环境均由平台管理，这种可以称为PaaS。</p>\n<h2 id=\"laaS-基础设施即服务：Infrastructure-as-a-Service\"><a href=\"#laaS-基础设施即服务：Infrastructure-as-a-Service\" class=\"headerlink\" title=\"laaS (基础设施即服务：Infrastructure as a Service)\"></a>laaS (基础设施即服务：Infrastructure as a Service)</h2><blockquote>\n<p>我觉得DIY的也不够好吃，想了想决定组一片地自己种原料自己管理店铺，自己组装一条生产线专门生产自己喜欢的汉堡。这些资源可以产出各式各样的产品，但是我只是借助它的“基础设施”完成我的需要，这种可以称为laaS。</p>\n</blockquote>\n<p>比如目前的云平台，国外的DigitalOcean等，提供实际的基础设施，用户可以将自己的服务部署在相应的机器上使其运行并得到我们需要的结果，这种可以称为laaS。</p>\n<h2 id=\"其他新兴的模式\"><a href=\"#其他新兴的模式\" class=\"headerlink\" title=\"其他新兴的模式\"></a>其他新兴的模式</h2><ul>\n<li>桌面即服务（DaaS）</li>\n<li>无服务器计算（Serverless or FaaS）<blockquote>\n<p>无服务器运算（英语：Serverless computing），又被称为功能即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。—— Wikipedia</p>\n</blockquote>\n</li>\n<li>安全即服务（Security as a service，SECaaS）</li>\n<li>后端即服务（BaaS）</li>\n<li>容器即服务 （Containers-as-a-Service）</li>\n</ul>\n"},{"title":"Git常用命令速览","date":"2019-08-11T08:00:00.000Z","excerpt":"Git命令的CheatSheet","thumbnail":"","_content":"### git基本概念\n\n### 设置git信息\n- `git config --global user.name \"[name]\"`\n  设置提交时的用户名\n- `git config --global user.email \"[email]\"`\n  设置提交时的用户邮箱\n- `git config --global color.ui auto`\n  设置命令行颜色\n\n### 新建仓库\n- `git init [project-name]`\n  代码文件夹初始化git\n- `git clone [url]`\n  克隆项目仓库（包含整个版本信息）\n\n### 修改\n- `git status`\n  列出所有即将被提交的新建和更改的文件\n- `git diff`\n  显示所有未加入暂存区的差异\n- `git add [file]`\n  1. git add -A: [`<path>`]表示把`<path>`中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。\n  2. git add -i: [`<path>`]查看`<path>`中被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看`<path>`中所有untracted的文件，同时进入一个子命令系统。\n- `git diff --staged`\n  显示暂存区文件与最新文件版本的差异\n- `git reset [file]`\n  取消文件暂存，但保留其内容\n- `git commit -m \"[descriptive message]\"`\n  1. `-m`指后面可以直接输入message，否则需要调用编辑器\n  2. `-a`命令后，与单独执行`git add`类似，但不会将新文件加入暂存区，因而不推荐使用\n  3. `-v`命令可以在提交时显示所有diff信息\n\n### 分工协作\n- `git branch`\n  默认无参数时，列出所有本地的当前仓库的分支\n- `git branch [branch-name]`\n  在本地创建一个新的分支\n- `git checkout [branch-name]`\n  切换到指定的分支并更新当前工作区\n- `git merge [branch]`\n  将指定分支的代码历史拼合到当前分支\n- `git branch -d [branch-name]`\n  删除指定的分支（慎用）\n\n### 文件编辑\n- `git rm [file]`\n  将文件从当前工作区删除，暂存删除操作\n- `git rm --cached [file]`\n  将文件从版本控制中移除，但本地保留文件\n- `git mv [file-original] [file-renamed]`\n  修改文件名称，准备提交\n\n### 跟踪设置\n- `.gitignore`\n  设置当前目录下版本控制自动忽略的文件，后缀或指定文件夹均可 \n- `git ls-files --other --ignored --exclude-standard`\n  列出当前项目下所有忽略的文件\n\n### 碎片储存\n- `git stash`\n  临时保存所有的已跟踪的修改，以下命令都可以通过传入@n删除指定的更改\n- `git stash pop`\n  恢复最近一次暂存的修改，并从栈中移除\n- `git stash list`\n  列出栈中所有已暂存的修改条目\n- `git stash drop`\n  直接放弃最近一次暂存的更改\n\n### 查看历史\n- `git log`\n  列出当前分支的版本历史\n- `git log --follow [file]`\n  列出指定的文件的版本历史，包括重命名\n- `git diff [first-branch]...[second-branch]`\n  显示两个分支的内容差异\n- `git show [commit]`\n  输出指定提交的metadata以及内容变化\n\n### 撤销操作\n- `git reset [commit]`\n  撤销指定`[commit]`后所有的提交，保留本地更改\n- `git reset --hard [commit]`\n  删除所有的更改和历史，回退到指定的`[commit]`\n\n### 同步更改\n- `git fetch [bookmark]`\n  下载从`[bookmark]`所有的更改历史\n- `git merge [bookmark]/[branch]`\n  组合`[bookmark]`分支到当前分支\n- `git push [alias] [branch]`\n  上传所有本地分支的提交到git服务器\n- `git pull`\n  下载书签历史以及非协作变化","source":"_posts/other/git常用命令速览.md","raw":"---\ntags:\n- CheatSheet\ncategories: Other\ntitle: Git常用命令速览\ndate: 2019-08-12T00:00:00.000+08:00\nexcerpt: Git命令的CheatSheet\nthumbnail: ''\n\n---\n### git基本概念\n\n### 设置git信息\n- `git config --global user.name \"[name]\"`\n  设置提交时的用户名\n- `git config --global user.email \"[email]\"`\n  设置提交时的用户邮箱\n- `git config --global color.ui auto`\n  设置命令行颜色\n\n### 新建仓库\n- `git init [project-name]`\n  代码文件夹初始化git\n- `git clone [url]`\n  克隆项目仓库（包含整个版本信息）\n\n### 修改\n- `git status`\n  列出所有即将被提交的新建和更改的文件\n- `git diff`\n  显示所有未加入暂存区的差异\n- `git add [file]`\n  1. git add -A: [`<path>`]表示把`<path>`中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。\n  2. git add -i: [`<path>`]查看`<path>`中被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看`<path>`中所有untracted的文件，同时进入一个子命令系统。\n- `git diff --staged`\n  显示暂存区文件与最新文件版本的差异\n- `git reset [file]`\n  取消文件暂存，但保留其内容\n- `git commit -m \"[descriptive message]\"`\n  1. `-m`指后面可以直接输入message，否则需要调用编辑器\n  2. `-a`命令后，与单独执行`git add`类似，但不会将新文件加入暂存区，因而不推荐使用\n  3. `-v`命令可以在提交时显示所有diff信息\n\n### 分工协作\n- `git branch`\n  默认无参数时，列出所有本地的当前仓库的分支\n- `git branch [branch-name]`\n  在本地创建一个新的分支\n- `git checkout [branch-name]`\n  切换到指定的分支并更新当前工作区\n- `git merge [branch]`\n  将指定分支的代码历史拼合到当前分支\n- `git branch -d [branch-name]`\n  删除指定的分支（慎用）\n\n### 文件编辑\n- `git rm [file]`\n  将文件从当前工作区删除，暂存删除操作\n- `git rm --cached [file]`\n  将文件从版本控制中移除，但本地保留文件\n- `git mv [file-original] [file-renamed]`\n  修改文件名称，准备提交\n\n### 跟踪设置\n- `.gitignore`\n  设置当前目录下版本控制自动忽略的文件，后缀或指定文件夹均可 \n- `git ls-files --other --ignored --exclude-standard`\n  列出当前项目下所有忽略的文件\n\n### 碎片储存\n- `git stash`\n  临时保存所有的已跟踪的修改，以下命令都可以通过传入@n删除指定的更改\n- `git stash pop`\n  恢复最近一次暂存的修改，并从栈中移除\n- `git stash list`\n  列出栈中所有已暂存的修改条目\n- `git stash drop`\n  直接放弃最近一次暂存的更改\n\n### 查看历史\n- `git log`\n  列出当前分支的版本历史\n- `git log --follow [file]`\n  列出指定的文件的版本历史，包括重命名\n- `git diff [first-branch]...[second-branch]`\n  显示两个分支的内容差异\n- `git show [commit]`\n  输出指定提交的metadata以及内容变化\n\n### 撤销操作\n- `git reset [commit]`\n  撤销指定`[commit]`后所有的提交，保留本地更改\n- `git reset --hard [commit]`\n  删除所有的更改和历史，回退到指定的`[commit]`\n\n### 同步更改\n- `git fetch [bookmark]`\n  下载从`[bookmark]`所有的更改历史\n- `git merge [bookmark]/[branch]`\n  组合`[bookmark]`分支到当前分支\n- `git push [alias] [branch]`\n  上传所有本地分支的提交到git服务器\n- `git pull`\n  下载书签历史以及非协作变化","slug":"other/git常用命令速览","published":1,"updated":"2020-08-01T18:21:52.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ibc003bj1wt8j359qwi","content":"<h3 id=\"git基本概念\"><a href=\"#git基本概念\" class=\"headerlink\" title=\"git基本概念\"></a>git基本概念</h3><h3 id=\"设置git信息\"><a href=\"#设置git信息\" class=\"headerlink\" title=\"设置git信息\"></a>设置git信息</h3><ul>\n<li><code>git config --global user.name &quot;[name]&quot;</code><br>设置提交时的用户名</li>\n<li><code>git config --global user.email &quot;[email]&quot;</code><br>设置提交时的用户邮箱</li>\n<li><code>git config --global color.ui auto</code><br>设置命令行颜色</li>\n</ul>\n<h3 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h3><ul>\n<li><code>git init [project-name]</code><br>代码文件夹初始化git</li>\n<li><code>git clone [url]</code><br>克隆项目仓库（包含整个版本信息）</li>\n</ul>\n<h3 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h3><ul>\n<li><code>git status</code><br>列出所有即将被提交的新建和更改的文件</li>\n<li><code>git diff</code><br>显示所有未加入暂存区的差异</li>\n<li><code>git add [file]</code><ol>\n<li>git add -A: [<code>&lt;path&gt;</code>]表示把<code>&lt;path&gt;</code>中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。</li>\n<li>git add -i: [<code>&lt;path&gt;</code>]查看<code>&lt;path&gt;</code>中被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看<code>&lt;path&gt;</code>中所有untracted的文件，同时进入一个子命令系统。</li>\n</ol>\n</li>\n<li><code>git diff --staged</code><br>显示暂存区文件与最新文件版本的差异</li>\n<li><code>git reset [file]</code><br>取消文件暂存，但保留其内容</li>\n<li><code>git commit -m &quot;[descriptive message]&quot;</code><ol>\n<li><code>-m</code>指后面可以直接输入message，否则需要调用编辑器</li>\n<li><code>-a</code>命令后，与单独执行<code>git add</code>类似，但不会将新文件加入暂存区，因而不推荐使用</li>\n<li><code>-v</code>命令可以在提交时显示所有diff信息</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"分工协作\"><a href=\"#分工协作\" class=\"headerlink\" title=\"分工协作\"></a>分工协作</h3><ul>\n<li><code>git branch</code><br>默认无参数时，列出所有本地的当前仓库的分支</li>\n<li><code>git branch [branch-name]</code><br>在本地创建一个新的分支</li>\n<li><code>git checkout [branch-name]</code><br>切换到指定的分支并更新当前工作区</li>\n<li><code>git merge [branch]</code><br>将指定分支的代码历史拼合到当前分支</li>\n<li><code>git branch -d [branch-name]</code><br>删除指定的分支（慎用）</li>\n</ul>\n<h3 id=\"文件编辑\"><a href=\"#文件编辑\" class=\"headerlink\" title=\"文件编辑\"></a>文件编辑</h3><ul>\n<li><code>git rm [file]</code><br>将文件从当前工作区删除，暂存删除操作</li>\n<li><code>git rm --cached [file]</code><br>将文件从版本控制中移除，但本地保留文件</li>\n<li><code>git mv [file-original] [file-renamed]</code><br>修改文件名称，准备提交</li>\n</ul>\n<h3 id=\"跟踪设置\"><a href=\"#跟踪设置\" class=\"headerlink\" title=\"跟踪设置\"></a>跟踪设置</h3><ul>\n<li><code>.gitignore</code><br>设置当前目录下版本控制自动忽略的文件，后缀或指定文件夹均可 </li>\n<li><code>git ls-files --other --ignored --exclude-standard</code><br>列出当前项目下所有忽略的文件</li>\n</ul>\n<h3 id=\"碎片储存\"><a href=\"#碎片储存\" class=\"headerlink\" title=\"碎片储存\"></a>碎片储存</h3><ul>\n<li><code>git stash</code><br>临时保存所有的已跟踪的修改，以下命令都可以通过传入@n删除指定的更改</li>\n<li><code>git stash pop</code><br>恢复最近一次暂存的修改，并从栈中移除</li>\n<li><code>git stash list</code><br>列出栈中所有已暂存的修改条目</li>\n<li><code>git stash drop</code><br>直接放弃最近一次暂存的更改</li>\n</ul>\n<h3 id=\"查看历史\"><a href=\"#查看历史\" class=\"headerlink\" title=\"查看历史\"></a>查看历史</h3><ul>\n<li><code>git log</code><br>列出当前分支的版本历史</li>\n<li><code>git log --follow [file]</code><br>列出指定的文件的版本历史，包括重命名</li>\n<li><code>git diff [first-branch]...[second-branch]</code><br>显示两个分支的内容差异</li>\n<li><code>git show [commit]</code><br>输出指定提交的metadata以及内容变化</li>\n</ul>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><ul>\n<li><code>git reset [commit]</code><br>撤销指定<code>[commit]</code>后所有的提交，保留本地更改</li>\n<li><code>git reset --hard [commit]</code><br>删除所有的更改和历史，回退到指定的<code>[commit]</code></li>\n</ul>\n<h3 id=\"同步更改\"><a href=\"#同步更改\" class=\"headerlink\" title=\"同步更改\"></a>同步更改</h3><ul>\n<li><code>git fetch [bookmark]</code><br>下载从<code>[bookmark]</code>所有的更改历史</li>\n<li><code>git merge [bookmark]/[branch]</code><br>组合<code>[bookmark]</code>分支到当前分支</li>\n<li><code>git push [alias] [branch]</code><br>上传所有本地分支的提交到git服务器</li>\n<li><code>git pull</code><br>下载书签历史以及非协作变化</li>\n</ul>\n","site":{"data":{}},"more":"<h3 id=\"git基本概念\"><a href=\"#git基本概念\" class=\"headerlink\" title=\"git基本概念\"></a>git基本概念</h3><h3 id=\"设置git信息\"><a href=\"#设置git信息\" class=\"headerlink\" title=\"设置git信息\"></a>设置git信息</h3><ul>\n<li><code>git config --global user.name &quot;[name]&quot;</code><br>设置提交时的用户名</li>\n<li><code>git config --global user.email &quot;[email]&quot;</code><br>设置提交时的用户邮箱</li>\n<li><code>git config --global color.ui auto</code><br>设置命令行颜色</li>\n</ul>\n<h3 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h3><ul>\n<li><code>git init [project-name]</code><br>代码文件夹初始化git</li>\n<li><code>git clone [url]</code><br>克隆项目仓库（包含整个版本信息）</li>\n</ul>\n<h3 id=\"修改\"><a href=\"#修改\" class=\"headerlink\" title=\"修改\"></a>修改</h3><ul>\n<li><code>git status</code><br>列出所有即将被提交的新建和更改的文件</li>\n<li><code>git diff</code><br>显示所有未加入暂存区的差异</li>\n<li><code>git add [file]</code><ol>\n<li>git add -A: [<code>&lt;path&gt;</code>]表示把<code>&lt;path&gt;</code>中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。</li>\n<li>git add -i: [<code>&lt;path&gt;</code>]查看<code>&lt;path&gt;</code>中被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看<code>&lt;path&gt;</code>中所有untracted的文件，同时进入一个子命令系统。</li>\n</ol>\n</li>\n<li><code>git diff --staged</code><br>显示暂存区文件与最新文件版本的差异</li>\n<li><code>git reset [file]</code><br>取消文件暂存，但保留其内容</li>\n<li><code>git commit -m &quot;[descriptive message]&quot;</code><ol>\n<li><code>-m</code>指后面可以直接输入message，否则需要调用编辑器</li>\n<li><code>-a</code>命令后，与单独执行<code>git add</code>类似，但不会将新文件加入暂存区，因而不推荐使用</li>\n<li><code>-v</code>命令可以在提交时显示所有diff信息</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"分工协作\"><a href=\"#分工协作\" class=\"headerlink\" title=\"分工协作\"></a>分工协作</h3><ul>\n<li><code>git branch</code><br>默认无参数时，列出所有本地的当前仓库的分支</li>\n<li><code>git branch [branch-name]</code><br>在本地创建一个新的分支</li>\n<li><code>git checkout [branch-name]</code><br>切换到指定的分支并更新当前工作区</li>\n<li><code>git merge [branch]</code><br>将指定分支的代码历史拼合到当前分支</li>\n<li><code>git branch -d [branch-name]</code><br>删除指定的分支（慎用）</li>\n</ul>\n<h3 id=\"文件编辑\"><a href=\"#文件编辑\" class=\"headerlink\" title=\"文件编辑\"></a>文件编辑</h3><ul>\n<li><code>git rm [file]</code><br>将文件从当前工作区删除，暂存删除操作</li>\n<li><code>git rm --cached [file]</code><br>将文件从版本控制中移除，但本地保留文件</li>\n<li><code>git mv [file-original] [file-renamed]</code><br>修改文件名称，准备提交</li>\n</ul>\n<h3 id=\"跟踪设置\"><a href=\"#跟踪设置\" class=\"headerlink\" title=\"跟踪设置\"></a>跟踪设置</h3><ul>\n<li><code>.gitignore</code><br>设置当前目录下版本控制自动忽略的文件，后缀或指定文件夹均可 </li>\n<li><code>git ls-files --other --ignored --exclude-standard</code><br>列出当前项目下所有忽略的文件</li>\n</ul>\n<h3 id=\"碎片储存\"><a href=\"#碎片储存\" class=\"headerlink\" title=\"碎片储存\"></a>碎片储存</h3><ul>\n<li><code>git stash</code><br>临时保存所有的已跟踪的修改，以下命令都可以通过传入@n删除指定的更改</li>\n<li><code>git stash pop</code><br>恢复最近一次暂存的修改，并从栈中移除</li>\n<li><code>git stash list</code><br>列出栈中所有已暂存的修改条目</li>\n<li><code>git stash drop</code><br>直接放弃最近一次暂存的更改</li>\n</ul>\n<h3 id=\"查看历史\"><a href=\"#查看历史\" class=\"headerlink\" title=\"查看历史\"></a>查看历史</h3><ul>\n<li><code>git log</code><br>列出当前分支的版本历史</li>\n<li><code>git log --follow [file]</code><br>列出指定的文件的版本历史，包括重命名</li>\n<li><code>git diff [first-branch]...[second-branch]</code><br>显示两个分支的内容差异</li>\n<li><code>git show [commit]</code><br>输出指定提交的metadata以及内容变化</li>\n</ul>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><ul>\n<li><code>git reset [commit]</code><br>撤销指定<code>[commit]</code>后所有的提交，保留本地更改</li>\n<li><code>git reset --hard [commit]</code><br>删除所有的更改和历史，回退到指定的<code>[commit]</code></li>\n</ul>\n<h3 id=\"同步更改\"><a href=\"#同步更改\" class=\"headerlink\" title=\"同步更改\"></a>同步更改</h3><ul>\n<li><code>git fetch [bookmark]</code><br>下载从<code>[bookmark]</code>所有的更改历史</li>\n<li><code>git merge [bookmark]/[branch]</code><br>组合<code>[bookmark]</code>分支到当前分支</li>\n<li><code>git push [alias] [branch]</code><br>上传所有本地分支的提交到git服务器</li>\n<li><code>git pull</code><br>下载书签历史以及非协作变化</li>\n</ul>\n"},{"date":"2020-03-25T09:18:34.000Z","title":"利用Docker管理VPS——Nginx篇","excerpt":"未完待续，nginx直接安装在主机上会比较方便管理。","thumbnail":"","_content":"## 写在前面\n\n在我个人使用VPS时，一开始的思路时独立尽可能少的服务到独立的VPS内，这导致我有很多最低配的服务器，服务没用到的时候其实运行负载并不高，低配置又不能支持诸如Sentry等服务的启动，因此，采用Docker将同类型的服务进行合并是更好的策略，但随之而来的是需要对配置有合理的规划\n\n## 为什么先写Nginx\n\n首先我们要清楚一点，Docker的部分权限是和系统平级的，比如 __防火墙__ (操作端口时会同时添加iptables)，这导致如果只做简单映射，就会把对应端口暴露在外网，需要限制哪些服务可以通过外网访问，哪些服务只暴露对应端口给Dashboard。\n\n> 请在平时启动Docker容器时，不想暴露到外网必须指定port的时候加127.0.0.1。\n\n> 如果端口只暴露而不需要映射到主机端口，请使用`--expose`代替`-p`。\n\n## 默认配置\n\n最方便的方式其实就是从已经运行的默认nginx镜像复制一份配置文件出来\n\n```bash\ndokcer cp YOUR_NGINX_ID:/etc/nginx/conf.d/default.conf ./\ndokcer cp YOUR_NGINX_ID:/etc/nginx/nginx.conf ./\n```\n\n## 配置方案\n\n由于是同一机器上多个容器，因此只将Nginx暴露到外网，其他容器均由Nginx进行反向代理。\n\n端口之间各种复杂的映射并不是最好的办法，选择有两种：\n\n- Nginx安装在实际的机器内，反代各种Docker容器；\n- Nginx以容器形式安装，通过网络或者link方式组成一体的网络；\n\n我的机器为了统一管理，这里选择第一种。","source":"_posts/other/利用docker管理vps-nginx篇.md","raw":"---\ncategories: Other\ntags:\n- Linux\ndate: 2020-03-26T01:18:34.000+08:00\ntitle: 利用Docker管理VPS——Nginx篇\nexcerpt: 未完待续，nginx直接安装在主机上会比较方便管理。\nthumbnail: ''\n\n---\n## 写在前面\n\n在我个人使用VPS时，一开始的思路时独立尽可能少的服务到独立的VPS内，这导致我有很多最低配的服务器，服务没用到的时候其实运行负载并不高，低配置又不能支持诸如Sentry等服务的启动，因此，采用Docker将同类型的服务进行合并是更好的策略，但随之而来的是需要对配置有合理的规划\n\n## 为什么先写Nginx\n\n首先我们要清楚一点，Docker的部分权限是和系统平级的，比如 __防火墙__ (操作端口时会同时添加iptables)，这导致如果只做简单映射，就会把对应端口暴露在外网，需要限制哪些服务可以通过外网访问，哪些服务只暴露对应端口给Dashboard。\n\n> 请在平时启动Docker容器时，不想暴露到外网必须指定port的时候加127.0.0.1。\n\n> 如果端口只暴露而不需要映射到主机端口，请使用`--expose`代替`-p`。\n\n## 默认配置\n\n最方便的方式其实就是从已经运行的默认nginx镜像复制一份配置文件出来\n\n```bash\ndokcer cp YOUR_NGINX_ID:/etc/nginx/conf.d/default.conf ./\ndokcer cp YOUR_NGINX_ID:/etc/nginx/nginx.conf ./\n```\n\n## 配置方案\n\n由于是同一机器上多个容器，因此只将Nginx暴露到外网，其他容器均由Nginx进行反向代理。\n\n端口之间各种复杂的映射并不是最好的办法，选择有两种：\n\n- Nginx安装在实际的机器内，反代各种Docker容器；\n- Nginx以容器形式安装，通过网络或者link方式组成一体的网络；\n\n我的机器为了统一管理，这里选择第一种。","slug":"other/利用docker管理vps-nginx篇","published":1,"updated":"2020-08-01T18:21:52.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ibd003ej1wtgq7w74t2","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在我个人使用VPS时，一开始的思路时独立尽可能少的服务到独立的VPS内，这导致我有很多最低配的服务器，服务没用到的时候其实运行负载并不高，低配置又不能支持诸如Sentry等服务的启动，因此，采用Docker将同类型的服务进行合并是更好的策略，但随之而来的是需要对配置有合理的规划</p>\n<h2 id=\"为什么先写Nginx\"><a href=\"#为什么先写Nginx\" class=\"headerlink\" title=\"为什么先写Nginx\"></a>为什么先写Nginx</h2><p>首先我们要清楚一点，Docker的部分权限是和系统平级的，比如 <strong>防火墙</strong> (操作端口时会同时添加iptables)，这导致如果只做简单映射，就会把对应端口暴露在外网，需要限制哪些服务可以通过外网访问，哪些服务只暴露对应端口给Dashboard。</p>\n<blockquote>\n<p>请在平时启动Docker容器时，不想暴露到外网必须指定port的时候加127.0.0.1。</p>\n</blockquote>\n<blockquote>\n<p>如果端口只暴露而不需要映射到主机端口，请使用<code>--expose</code>代替<code>-p</code>。</p>\n</blockquote>\n<h2 id=\"默认配置\"><a href=\"#默认配置\" class=\"headerlink\" title=\"默认配置\"></a>默认配置</h2><p>最方便的方式其实就是从已经运行的默认nginx镜像复制一份配置文件出来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dokcer cp YOUR_NGINX_ID:/etc/nginx/conf.d/default.conf ./</span><br><span class=\"line\">dokcer cp YOUR_NGINX_ID:/etc/nginx/nginx.conf ./</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置方案\"><a href=\"#配置方案\" class=\"headerlink\" title=\"配置方案\"></a>配置方案</h2><p>由于是同一机器上多个容器，因此只将Nginx暴露到外网，其他容器均由Nginx进行反向代理。</p>\n<p>端口之间各种复杂的映射并不是最好的办法，选择有两种：</p>\n<ul>\n<li>Nginx安装在实际的机器内，反代各种Docker容器；</li>\n<li>Nginx以容器形式安装，通过网络或者link方式组成一体的网络；</li>\n</ul>\n<p>我的机器为了统一管理，这里选择第一种。</p>\n","site":{"data":{}},"more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>在我个人使用VPS时，一开始的思路时独立尽可能少的服务到独立的VPS内，这导致我有很多最低配的服务器，服务没用到的时候其实运行负载并不高，低配置又不能支持诸如Sentry等服务的启动，因此，采用Docker将同类型的服务进行合并是更好的策略，但随之而来的是需要对配置有合理的规划</p>\n<h2 id=\"为什么先写Nginx\"><a href=\"#为什么先写Nginx\" class=\"headerlink\" title=\"为什么先写Nginx\"></a>为什么先写Nginx</h2><p>首先我们要清楚一点，Docker的部分权限是和系统平级的，比如 <strong>防火墙</strong> (操作端口时会同时添加iptables)，这导致如果只做简单映射，就会把对应端口暴露在外网，需要限制哪些服务可以通过外网访问，哪些服务只暴露对应端口给Dashboard。</p>\n<blockquote>\n<p>请在平时启动Docker容器时，不想暴露到外网必须指定port的时候加127.0.0.1。</p>\n</blockquote>\n<blockquote>\n<p>如果端口只暴露而不需要映射到主机端口，请使用<code>--expose</code>代替<code>-p</code>。</p>\n</blockquote>\n<h2 id=\"默认配置\"><a href=\"#默认配置\" class=\"headerlink\" title=\"默认配置\"></a>默认配置</h2><p>最方便的方式其实就是从已经运行的默认nginx镜像复制一份配置文件出来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dokcer cp YOUR_NGINX_ID:/etc/nginx/conf.d/default.conf ./</span><br><span class=\"line\">dokcer cp YOUR_NGINX_ID:/etc/nginx/nginx.conf ./</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置方案\"><a href=\"#配置方案\" class=\"headerlink\" title=\"配置方案\"></a>配置方案</h2><p>由于是同一机器上多个容器，因此只将Nginx暴露到外网，其他容器均由Nginx进行反向代理。</p>\n<p>端口之间各种复杂的映射并不是最好的办法，选择有两种：</p>\n<ul>\n<li>Nginx安装在实际的机器内，反代各种Docker容器；</li>\n<li>Nginx以容器形式安装，通过网络或者link方式组成一体的网络；</li>\n</ul>\n<p>我的机器为了统一管理，这里选择第一种。</p>\n"},{"date":"2020-06-14T00:34:26.000Z","title":"红米RM2100+AX200诡异跳ping问题","excerpt":"更新：使用了恩山的“啊Dee”的Padavan固件，稳定使用160Mhz。","thumbnail":"","_content":"## 开篇先说结论\n\n结论是：AX200在连接RM2100(Padavan)的5G 160Mhz无线信号时，出现跳ping（波动至250+）。\n\n解决方案：设置RM2100的5G WiFi以20/40/80Mhz使用，目前跳ping得到缓解。\n\n更新：使用了恩山的“啊Dee”的Padavan固件，稳定使用160Mhz，给一个[论坛链接](https://www.right.com.cn/forum/thread-4033492-1-1.html) 如果后续遇到新的问题会在本文中更新。\n\n## 我的网络搭配\n\n红米 AC2100主路由，刷入[C大的Padavan固件](https://github.com/chongshengB/rt-n56u/releases)，不开启任何插件的情况下，打开5G的20/40/80/160Mhz自动协商 ；\n\n主机由于一居室的距离问题，因而加装了一个无线网卡（COMFAST AX200），测速和日常直播没有感受到速度问题，偶尔出现无法打开页面的情况，考虑到AC2100的CPU比较差，关闭了SmartDNS等插件。\n\n而后，平时页面打开出现无法打开情况减少，但跳ping情况依然明显，在游戏(Insurgancy第三方服务器)内ping会几分钟内突然飙升至250左右，网页同时也速度极慢。\n\n更新固件，修改信道等等方案都尝试后，决定降级到20/40/80Mhz自动协商，跳ping状况基本解决，不更改AX200配置的情况下，稳定在80Mhz传输。\n\n## 后续更新驱动\n\n希望后续能有稳定的AX200驱动能够支持ac模式下的160Mhz。不过目前来看各大第三方都不够稳定，个人使用C大的0604版还可以接受，地址上方自取。\n\n目前来说，AC2100适合折腾人士，如果作为家里主路由的还不够稳定,刷入第三方后又不容易支持加速器等。","source":"_posts/other/rm2100-ax200-ping.md","raw":"---\ncategories: Other\ntags:\n- 记录\ndate: 2020-06-14T16:34:26.000+08:00\ntitle: 红米RM2100+AX200诡异跳ping问题\nexcerpt: 更新：使用了恩山的“啊Dee”的Padavan固件，稳定使用160Mhz。\nthumbnail: ''\n\n---\n## 开篇先说结论\n\n结论是：AX200在连接RM2100(Padavan)的5G 160Mhz无线信号时，出现跳ping（波动至250+）。\n\n解决方案：设置RM2100的5G WiFi以20/40/80Mhz使用，目前跳ping得到缓解。\n\n更新：使用了恩山的“啊Dee”的Padavan固件，稳定使用160Mhz，给一个[论坛链接](https://www.right.com.cn/forum/thread-4033492-1-1.html) 如果后续遇到新的问题会在本文中更新。\n\n## 我的网络搭配\n\n红米 AC2100主路由，刷入[C大的Padavan固件](https://github.com/chongshengB/rt-n56u/releases)，不开启任何插件的情况下，打开5G的20/40/80/160Mhz自动协商 ；\n\n主机由于一居室的距离问题，因而加装了一个无线网卡（COMFAST AX200），测速和日常直播没有感受到速度问题，偶尔出现无法打开页面的情况，考虑到AC2100的CPU比较差，关闭了SmartDNS等插件。\n\n而后，平时页面打开出现无法打开情况减少，但跳ping情况依然明显，在游戏(Insurgancy第三方服务器)内ping会几分钟内突然飙升至250左右，网页同时也速度极慢。\n\n更新固件，修改信道等等方案都尝试后，决定降级到20/40/80Mhz自动协商，跳ping状况基本解决，不更改AX200配置的情况下，稳定在80Mhz传输。\n\n## 后续更新驱动\n\n希望后续能有稳定的AX200驱动能够支持ac模式下的160Mhz。不过目前来看各大第三方都不够稳定，个人使用C大的0604版还可以接受，地址上方自取。\n\n目前来说，AC2100适合折腾人士，如果作为家里主路由的还不够稳定,刷入第三方后又不容易支持加速器等。","slug":"other/rm2100-ax200-ping","published":1,"updated":"2020-11-17T14:15:40.853Z","_id":"ckdev5ibe003ij1wt3hcv6de1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"开篇先说结论\"><a href=\"#开篇先说结论\" class=\"headerlink\" title=\"开篇先说结论\"></a>开篇先说结论</h2><p>结论是：AX200在连接RM2100(Padavan)的5G 160Mhz无线信号时，出现跳ping（波动至250+）。</p>\n<p>解决方案：设置RM2100的5G WiFi以20/40/80Mhz使用，目前跳ping得到缓解。</p>\n<p>更新：使用了恩山的“啊Dee”的Padavan固件，稳定使用160Mhz，给一个<a href=\"https://www.right.com.cn/forum/thread-4033492-1-1.html\">论坛链接</a> 如果后续遇到新的问题会在本文中更新。</p>\n<h2 id=\"我的网络搭配\"><a href=\"#我的网络搭配\" class=\"headerlink\" title=\"我的网络搭配\"></a>我的网络搭配</h2><p>红米 AC2100主路由，刷入<a href=\"https://github.com/chongshengB/rt-n56u/releases\">C大的Padavan固件</a>，不开启任何插件的情况下，打开5G的20/40/80/160Mhz自动协商 ；</p>\n<p>主机由于一居室的距离问题，因而加装了一个无线网卡（COMFAST AX200），测速和日常直播没有感受到速度问题，偶尔出现无法打开页面的情况，考虑到AC2100的CPU比较差，关闭了SmartDNS等插件。</p>\n<p>而后，平时页面打开出现无法打开情况减少，但跳ping情况依然明显，在游戏(Insurgancy第三方服务器)内ping会几分钟内突然飙升至250左右，网页同时也速度极慢。</p>\n<p>更新固件，修改信道等等方案都尝试后，决定降级到20/40/80Mhz自动协商，跳ping状况基本解决，不更改AX200配置的情况下，稳定在80Mhz传输。</p>\n<h2 id=\"后续更新驱动\"><a href=\"#后续更新驱动\" class=\"headerlink\" title=\"后续更新驱动\"></a>后续更新驱动</h2><p>希望后续能有稳定的AX200驱动能够支持ac模式下的160Mhz。不过目前来看各大第三方都不够稳定，个人使用C大的0604版还可以接受，地址上方自取。</p>\n<p>目前来说，AC2100适合折腾人士，如果作为家里主路由的还不够稳定,刷入第三方后又不容易支持加速器等。</p>\n","site":{"data":{}},"more":"<h2 id=\"开篇先说结论\"><a href=\"#开篇先说结论\" class=\"headerlink\" title=\"开篇先说结论\"></a>开篇先说结论</h2><p>结论是：AX200在连接RM2100(Padavan)的5G 160Mhz无线信号时，出现跳ping（波动至250+）。</p>\n<p>解决方案：设置RM2100的5G WiFi以20/40/80Mhz使用，目前跳ping得到缓解。</p>\n<p>更新：使用了恩山的“啊Dee”的Padavan固件，稳定使用160Mhz，给一个<a href=\"https://www.right.com.cn/forum/thread-4033492-1-1.html\">论坛链接</a> 如果后续遇到新的问题会在本文中更新。</p>\n<h2 id=\"我的网络搭配\"><a href=\"#我的网络搭配\" class=\"headerlink\" title=\"我的网络搭配\"></a>我的网络搭配</h2><p>红米 AC2100主路由，刷入<a href=\"https://github.com/chongshengB/rt-n56u/releases\">C大的Padavan固件</a>，不开启任何插件的情况下，打开5G的20/40/80/160Mhz自动协商 ；</p>\n<p>主机由于一居室的距离问题，因而加装了一个无线网卡（COMFAST AX200），测速和日常直播没有感受到速度问题，偶尔出现无法打开页面的情况，考虑到AC2100的CPU比较差，关闭了SmartDNS等插件。</p>\n<p>而后，平时页面打开出现无法打开情况减少，但跳ping情况依然明显，在游戏(Insurgancy第三方服务器)内ping会几分钟内突然飙升至250左右，网页同时也速度极慢。</p>\n<p>更新固件，修改信道等等方案都尝试后，决定降级到20/40/80Mhz自动协商，跳ping状况基本解决，不更改AX200配置的情况下，稳定在80Mhz传输。</p>\n<h2 id=\"后续更新驱动\"><a href=\"#后续更新驱动\" class=\"headerlink\" title=\"后续更新驱动\"></a>后续更新驱动</h2><p>希望后续能有稳定的AX200驱动能够支持ac模式下的160Mhz。不过目前来看各大第三方都不够稳定，个人使用C大的0604版还可以接受，地址上方自取。</p>\n<p>目前来说，AC2100适合折腾人士，如果作为家里主路由的还不够稳定,刷入第三方后又不容易支持加速器等。</p>\n"},{"date":"2020-05-07T08:22:15.000Z","title":"Sentry——一站式错误监控平台部署记录","excerpt":"Sentry这个平台除了部署稍微麻烦些，其实还是很好用的，简单记录了自己私有部署Sentry遇到的一些坑","thumbnail":"","_content":"## Sentry是什么？\n\n> Sentry helps all software teams create the best software, faster.\n\nSentry是一个SaaS服务，提供了多种语言、多种环境的错误收集提示等自动化处理功能。\n\n它的优势主要有以下几点：\n\n* 接入简单，node & flutter都是在主入口几行搞定;\n* 支持平台和语言极广，几乎涵盖了市面上常见的语言和框架，能够为整个开发团队提供错误收集能力;\n* 支持扩展，能够快速扩展到Gitlab、Github、Trello、Slack等平台，国内也有非常好的支持，飞书等平台也有对应的助手或Bot能够方便的扩展到日常开发上;\n* 支持私有部署（虽然有坑……），这一点是最为重要的，能够让小团队快速利用Docker和官方命令进行部署，极快地为开发赋能。\n\nSaaS版本我也曾使用过，但是如果没有配置好或者网络环境一般，可能会付出比较高的成本（定时器未清除导致的报错会瞬间烧光你的免费额度……），因此强烈推荐私有部署，相关教程也比较丰富。\n\n> getsentry: [Github](https://github.com/getsentry/onpremise)\n\n> 飞书官方的Sentry助手，[文档](https://getfeishu.cn/hc/zh-cn/articles/360041217373-%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A3%9E%E4%B9%A6%E4%B8%AD%E9%85%8D%E7%BD%AE-Sentry-%E5%8A%A9%E6%89%8B-)，如果其他平台没有原生支持也可以使用Webhook等方式“曲线救国”。\n\n## 简单说说私有部署\n\n其实按照官方的仓库指导，很容易能够部署，只需要一些docker的基础知识并且能够利用docker-compose工具就可以运行起来，但是有很多细节比如Nginx反代Sentry，以及邮箱配置等还是需要对其他相关的东西有一些了解。\n\n### 配置\n\n官方推荐的配置为2400MB内存起步，但是可以通过修改[install.sh](https://github.com/getsentry/onpremise/blob/master/install.sh)，调整最低内存，可以完成安装，但是不保证运行效率，如果较大量的请求可能会导致内存100%。\n\n    MIN_RAM=2400 # MB\n\n### 一些运行设置\n\n以邮件配置举例，目前版本(onpremise, Sentry 10.1.0.dev09b99a3b)如果希望配置生效首先需要找到sentry目录下的config.yml文件（如果没有说明是全新安装，可以从config.example.yml复制一份进行修改），利用环境变量先配置对应的参数。\n\n更新配置后，执行以下命令：\n\n```bash\n# docker-compose.yml 目录下\ndocker-compose stop\ndocker-compose run --rm web upgrade\ndocker-compose up -d\n```\n\n如果相关程序启动成功，则可以到系统管理界面查看是否应用配置，并发送测试邮件。\n\n### 更新版本\n\n随着一些API的变更，官方会更新相应的版本，私有部署的可以通过执行以下命令来进行升级。\n\n```bash\n# 避免onpremise版本安装脚本问题，建议手工拉取最新镜像tag，同时将onpremise仓库升级到对应tag\n# docker pull getsentry/sentry:xx.xx.xx && git checkout xx.xx.xx\ndocker-compose build && docker-compose run --rm web upgrade && docker-compose up -d\n```\n\n> 目前已知Github集成存在API被废弃，相关[链接](https://developer.github.com/changes/2020-04-15-replacing-create-installation-access-token-endpoint/) ，目前onpremise 10.0.0版本存在此问题，10.0.1未确认，官方修正于20.7.0，鉴于私有部署版本更新过于激进，暂时不进行升级等待10版本后续更新。\n\n## 坑\n\n私有部署依赖于Sentry和它的很多镜像，以及一些第三方镜像。由于Sentry 20的自建版本仍在 __非常积极地__ 开发迭代中，强烈推荐使用docker的原始源进行安装，成功率较高，如果使用镜像，可能存在Bug导致无法安装，需要注意。\n\n强烈建议将postgres数据和sentry-data挂载到机器目录上，可以较好的保存持久化的信息。\n\n## Sentry依赖的一堆容器，究竟做了什么？\n\n这里强烈推荐看[官方开发博客](https://blog.sentry.io/)了解每一个组件背后的由来。\n\n### Snuba\n\n### tianon/exim4\n\n### symbolicator\n\n### memcache + redis ？","source":"_posts/other/sentry-一站式错误监控平台部署记录.md","raw":"---\ncategories: Other\ntags:\n- 工具\ndate: 2020-05-08T00:22:15.000+08:00\ntitle: Sentry——一站式错误监控平台部署记录\nexcerpt: Sentry这个平台除了部署稍微麻烦些，其实还是很好用的，简单记录了自己私有部署Sentry遇到的一些坑\nthumbnail: ''\n\n---\n## Sentry是什么？\n\n> Sentry helps all software teams create the best software, faster.\n\nSentry是一个SaaS服务，提供了多种语言、多种环境的错误收集提示等自动化处理功能。\n\n它的优势主要有以下几点：\n\n* 接入简单，node & flutter都是在主入口几行搞定;\n* 支持平台和语言极广，几乎涵盖了市面上常见的语言和框架，能够为整个开发团队提供错误收集能力;\n* 支持扩展，能够快速扩展到Gitlab、Github、Trello、Slack等平台，国内也有非常好的支持，飞书等平台也有对应的助手或Bot能够方便的扩展到日常开发上;\n* 支持私有部署（虽然有坑……），这一点是最为重要的，能够让小团队快速利用Docker和官方命令进行部署，极快地为开发赋能。\n\nSaaS版本我也曾使用过，但是如果没有配置好或者网络环境一般，可能会付出比较高的成本（定时器未清除导致的报错会瞬间烧光你的免费额度……），因此强烈推荐私有部署，相关教程也比较丰富。\n\n> getsentry: [Github](https://github.com/getsentry/onpremise)\n\n> 飞书官方的Sentry助手，[文档](https://getfeishu.cn/hc/zh-cn/articles/360041217373-%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A3%9E%E4%B9%A6%E4%B8%AD%E9%85%8D%E7%BD%AE-Sentry-%E5%8A%A9%E6%89%8B-)，如果其他平台没有原生支持也可以使用Webhook等方式“曲线救国”。\n\n## 简单说说私有部署\n\n其实按照官方的仓库指导，很容易能够部署，只需要一些docker的基础知识并且能够利用docker-compose工具就可以运行起来，但是有很多细节比如Nginx反代Sentry，以及邮箱配置等还是需要对其他相关的东西有一些了解。\n\n### 配置\n\n官方推荐的配置为2400MB内存起步，但是可以通过修改[install.sh](https://github.com/getsentry/onpremise/blob/master/install.sh)，调整最低内存，可以完成安装，但是不保证运行效率，如果较大量的请求可能会导致内存100%。\n\n    MIN_RAM=2400 # MB\n\n### 一些运行设置\n\n以邮件配置举例，目前版本(onpremise, Sentry 10.1.0.dev09b99a3b)如果希望配置生效首先需要找到sentry目录下的config.yml文件（如果没有说明是全新安装，可以从config.example.yml复制一份进行修改），利用环境变量先配置对应的参数。\n\n更新配置后，执行以下命令：\n\n```bash\n# docker-compose.yml 目录下\ndocker-compose stop\ndocker-compose run --rm web upgrade\ndocker-compose up -d\n```\n\n如果相关程序启动成功，则可以到系统管理界面查看是否应用配置，并发送测试邮件。\n\n### 更新版本\n\n随着一些API的变更，官方会更新相应的版本，私有部署的可以通过执行以下命令来进行升级。\n\n```bash\n# 避免onpremise版本安装脚本问题，建议手工拉取最新镜像tag，同时将onpremise仓库升级到对应tag\n# docker pull getsentry/sentry:xx.xx.xx && git checkout xx.xx.xx\ndocker-compose build && docker-compose run --rm web upgrade && docker-compose up -d\n```\n\n> 目前已知Github集成存在API被废弃，相关[链接](https://developer.github.com/changes/2020-04-15-replacing-create-installation-access-token-endpoint/) ，目前onpremise 10.0.0版本存在此问题，10.0.1未确认，官方修正于20.7.0，鉴于私有部署版本更新过于激进，暂时不进行升级等待10版本后续更新。\n\n## 坑\n\n私有部署依赖于Sentry和它的很多镜像，以及一些第三方镜像。由于Sentry 20的自建版本仍在 __非常积极地__ 开发迭代中，强烈推荐使用docker的原始源进行安装，成功率较高，如果使用镜像，可能存在Bug导致无法安装，需要注意。\n\n强烈建议将postgres数据和sentry-data挂载到机器目录上，可以较好的保存持久化的信息。\n\n## Sentry依赖的一堆容器，究竟做了什么？\n\n这里强烈推荐看[官方开发博客](https://blog.sentry.io/)了解每一个组件背后的由来。\n\n### Snuba\n\n### tianon/exim4\n\n### symbolicator\n\n### memcache + redis ？","slug":"other/sentry-一站式错误监控平台部署记录","published":1,"updated":"2020-08-04T17:25:12.584Z","_id":"ckdev5ibf003lj1wtbxjyejqs","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Sentry是什么？\"><a href=\"#Sentry是什么？\" class=\"headerlink\" title=\"Sentry是什么？\"></a>Sentry是什么？</h2><blockquote>\n<p>Sentry helps all software teams create the best software, faster.</p>\n</blockquote>\n<p>Sentry是一个SaaS服务，提供了多种语言、多种环境的错误收集提示等自动化处理功能。</p>\n<p>它的优势主要有以下几点：</p>\n<ul>\n<li>接入简单，node &amp; flutter都是在主入口几行搞定;</li>\n<li>支持平台和语言极广，几乎涵盖了市面上常见的语言和框架，能够为整个开发团队提供错误收集能力;</li>\n<li>支持扩展，能够快速扩展到Gitlab、Github、Trello、Slack等平台，国内也有非常好的支持，飞书等平台也有对应的助手或Bot能够方便的扩展到日常开发上;</li>\n<li>支持私有部署（虽然有坑……），这一点是最为重要的，能够让小团队快速利用Docker和官方命令进行部署，极快地为开发赋能。</li>\n</ul>\n<p>SaaS版本我也曾使用过，但是如果没有配置好或者网络环境一般，可能会付出比较高的成本（定时器未清除导致的报错会瞬间烧光你的免费额度……），因此强烈推荐私有部署，相关教程也比较丰富。</p>\n<blockquote>\n<p>getsentry: <a href=\"https://github.com/getsentry/onpremise\">Github</a></p>\n</blockquote>\n<blockquote>\n<p>飞书官方的Sentry助手，<a href=\"https://getfeishu.cn/hc/zh-cn/articles/360041217373-%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A3%9E%E4%B9%A6%E4%B8%AD%E9%85%8D%E7%BD%AE-Sentry-%E5%8A%A9%E6%89%8B-\">文档</a>，如果其他平台没有原生支持也可以使用Webhook等方式“曲线救国”。</p>\n</blockquote>\n<h2 id=\"简单说说私有部署\"><a href=\"#简单说说私有部署\" class=\"headerlink\" title=\"简单说说私有部署\"></a>简单说说私有部署</h2><p>其实按照官方的仓库指导，很容易能够部署，只需要一些docker的基础知识并且能够利用docker-compose工具就可以运行起来，但是有很多细节比如Nginx反代Sentry，以及邮箱配置等还是需要对其他相关的东西有一些了解。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>官方推荐的配置为2400MB内存起步，但是可以通过修改<a href=\"https://github.com/getsentry/onpremise/blob/master/install.sh\">install.sh</a>，调整最低内存，可以完成安装，但是不保证运行效率，如果较大量的请求可能会导致内存100%。</p>\n<pre><code>MIN_RAM=2400 # MB</code></pre>\n<h3 id=\"一些运行设置\"><a href=\"#一些运行设置\" class=\"headerlink\" title=\"一些运行设置\"></a>一些运行设置</h3><p>以邮件配置举例，目前版本(onpremise, Sentry 10.1.0.dev09b99a3b)如果希望配置生效首先需要找到sentry目录下的config.yml文件（如果没有说明是全新安装，可以从config.example.yml复制一份进行修改），利用环境变量先配置对应的参数。</p>\n<p>更新配置后，执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker-compose.yml 目录下</span></span><br><span class=\"line\">docker-compose stop</span><br><span class=\"line\">docker-compose run --rm web upgrade</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<p>如果相关程序启动成功，则可以到系统管理界面查看是否应用配置，并发送测试邮件。</p>\n<h3 id=\"更新版本\"><a href=\"#更新版本\" class=\"headerlink\" title=\"更新版本\"></a>更新版本</h3><p>随着一些API的变更，官方会更新相应的版本，私有部署的可以通过执行以下命令来进行升级。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 避免onpremise版本安装脚本问题，建议手工拉取最新镜像tag，同时将onpremise仓库升级到对应tag</span></span><br><span class=\"line\"><span class=\"comment\"># docker pull getsentry/sentry:xx.xx.xx &amp;&amp; git checkout xx.xx.xx</span></span><br><span class=\"line\">docker-compose build &amp;&amp; docker-compose run --rm web upgrade &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>目前已知Github集成存在API被废弃，相关<a href=\"https://developer.github.com/changes/2020-04-15-replacing-create-installation-access-token-endpoint/\">链接</a> ，目前onpremise 10.0.0版本存在此问题，10.0.1未确认，官方修正于20.7.0，鉴于私有部署版本更新过于激进，暂时不进行升级等待10版本后续更新。</p>\n</blockquote>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><p>私有部署依赖于Sentry和它的很多镜像，以及一些第三方镜像。由于Sentry 20的自建版本仍在 <strong>非常积极地</strong> 开发迭代中，强烈推荐使用docker的原始源进行安装，成功率较高，如果使用镜像，可能存在Bug导致无法安装，需要注意。</p>\n<p>强烈建议将postgres数据和sentry-data挂载到机器目录上，可以较好的保存持久化的信息。</p>\n<h2 id=\"Sentry依赖的一堆容器，究竟做了什么？\"><a href=\"#Sentry依赖的一堆容器，究竟做了什么？\" class=\"headerlink\" title=\"Sentry依赖的一堆容器，究竟做了什么？\"></a>Sentry依赖的一堆容器，究竟做了什么？</h2><p>这里强烈推荐看<a href=\"https://blog.sentry.io/\">官方开发博客</a>了解每一个组件背后的由来。</p>\n<h3 id=\"Snuba\"><a href=\"#Snuba\" class=\"headerlink\" title=\"Snuba\"></a>Snuba</h3><h3 id=\"tianon-exim4\"><a href=\"#tianon-exim4\" class=\"headerlink\" title=\"tianon/exim4\"></a>tianon/exim4</h3><h3 id=\"symbolicator\"><a href=\"#symbolicator\" class=\"headerlink\" title=\"symbolicator\"></a>symbolicator</h3><h3 id=\"memcache-redis-？\"><a href=\"#memcache-redis-？\" class=\"headerlink\" title=\"memcache + redis ？\"></a>memcache + redis ？</h3>","site":{"data":{}},"more":"<h2 id=\"Sentry是什么？\"><a href=\"#Sentry是什么？\" class=\"headerlink\" title=\"Sentry是什么？\"></a>Sentry是什么？</h2><blockquote>\n<p>Sentry helps all software teams create the best software, faster.</p>\n</blockquote>\n<p>Sentry是一个SaaS服务，提供了多种语言、多种环境的错误收集提示等自动化处理功能。</p>\n<p>它的优势主要有以下几点：</p>\n<ul>\n<li>接入简单，node &amp; flutter都是在主入口几行搞定;</li>\n<li>支持平台和语言极广，几乎涵盖了市面上常见的语言和框架，能够为整个开发团队提供错误收集能力;</li>\n<li>支持扩展，能够快速扩展到Gitlab、Github、Trello、Slack等平台，国内也有非常好的支持，飞书等平台也有对应的助手或Bot能够方便的扩展到日常开发上;</li>\n<li>支持私有部署（虽然有坑……），这一点是最为重要的，能够让小团队快速利用Docker和官方命令进行部署，极快地为开发赋能。</li>\n</ul>\n<p>SaaS版本我也曾使用过，但是如果没有配置好或者网络环境一般，可能会付出比较高的成本（定时器未清除导致的报错会瞬间烧光你的免费额度……），因此强烈推荐私有部署，相关教程也比较丰富。</p>\n<blockquote>\n<p>getsentry: <a href=\"https://github.com/getsentry/onpremise\">Github</a></p>\n</blockquote>\n<blockquote>\n<p>飞书官方的Sentry助手，<a href=\"https://getfeishu.cn/hc/zh-cn/articles/360041217373-%E6%9C%BA%E5%99%A8%E4%BA%BA-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A3%9E%E4%B9%A6%E4%B8%AD%E9%85%8D%E7%BD%AE-Sentry-%E5%8A%A9%E6%89%8B-\">文档</a>，如果其他平台没有原生支持也可以使用Webhook等方式“曲线救国”。</p>\n</blockquote>\n<h2 id=\"简单说说私有部署\"><a href=\"#简单说说私有部署\" class=\"headerlink\" title=\"简单说说私有部署\"></a>简单说说私有部署</h2><p>其实按照官方的仓库指导，很容易能够部署，只需要一些docker的基础知识并且能够利用docker-compose工具就可以运行起来，但是有很多细节比如Nginx反代Sentry，以及邮箱配置等还是需要对其他相关的东西有一些了解。</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>官方推荐的配置为2400MB内存起步，但是可以通过修改<a href=\"https://github.com/getsentry/onpremise/blob/master/install.sh\">install.sh</a>，调整最低内存，可以完成安装，但是不保证运行效率，如果较大量的请求可能会导致内存100%。</p>\n<pre><code>MIN_RAM=2400 # MB</code></pre>\n<h3 id=\"一些运行设置\"><a href=\"#一些运行设置\" class=\"headerlink\" title=\"一些运行设置\"></a>一些运行设置</h3><p>以邮件配置举例，目前版本(onpremise, Sentry 10.1.0.dev09b99a3b)如果希望配置生效首先需要找到sentry目录下的config.yml文件（如果没有说明是全新安装，可以从config.example.yml复制一份进行修改），利用环境变量先配置对应的参数。</p>\n<p>更新配置后，执行以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker-compose.yml 目录下</span></span><br><span class=\"line\">docker-compose stop</span><br><span class=\"line\">docker-compose run --rm web upgrade</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<p>如果相关程序启动成功，则可以到系统管理界面查看是否应用配置，并发送测试邮件。</p>\n<h3 id=\"更新版本\"><a href=\"#更新版本\" class=\"headerlink\" title=\"更新版本\"></a>更新版本</h3><p>随着一些API的变更，官方会更新相应的版本，私有部署的可以通过执行以下命令来进行升级。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 避免onpremise版本安装脚本问题，建议手工拉取最新镜像tag，同时将onpremise仓库升级到对应tag</span></span><br><span class=\"line\"><span class=\"comment\"># docker pull getsentry/sentry:xx.xx.xx &amp;&amp; git checkout xx.xx.xx</span></span><br><span class=\"line\">docker-compose build &amp;&amp; docker-compose run --rm web upgrade &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>目前已知Github集成存在API被废弃，相关<a href=\"https://developer.github.com/changes/2020-04-15-replacing-create-installation-access-token-endpoint/\">链接</a> ，目前onpremise 10.0.0版本存在此问题，10.0.1未确认，官方修正于20.7.0，鉴于私有部署版本更新过于激进，暂时不进行升级等待10版本后续更新。</p>\n</blockquote>\n<h2 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h2><p>私有部署依赖于Sentry和它的很多镜像，以及一些第三方镜像。由于Sentry 20的自建版本仍在 <strong>非常积极地</strong> 开发迭代中，强烈推荐使用docker的原始源进行安装，成功率较高，如果使用镜像，可能存在Bug导致无法安装，需要注意。</p>\n<p>强烈建议将postgres数据和sentry-data挂载到机器目录上，可以较好的保存持久化的信息。</p>\n<h2 id=\"Sentry依赖的一堆容器，究竟做了什么？\"><a href=\"#Sentry依赖的一堆容器，究竟做了什么？\" class=\"headerlink\" title=\"Sentry依赖的一堆容器，究竟做了什么？\"></a>Sentry依赖的一堆容器，究竟做了什么？</h2><p>这里强烈推荐看<a href=\"https://blog.sentry.io/\">官方开发博客</a>了解每一个组件背后的由来。</p>\n<h3 id=\"Snuba\"><a href=\"#Snuba\" class=\"headerlink\" title=\"Snuba\"></a>Snuba</h3><h3 id=\"tianon-exim4\"><a href=\"#tianon-exim4\" class=\"headerlink\" title=\"tianon/exim4\"></a>tianon/exim4</h3><h3 id=\"symbolicator\"><a href=\"#symbolicator\" class=\"headerlink\" title=\"symbolicator\"></a>symbolicator</h3><h3 id=\"memcache-redis-？\"><a href=\"#memcache-redis-？\" class=\"headerlink\" title=\"memcache + redis ？\"></a>memcache + redis ？</h3>"},{"date":"2020-04-21T22:44:42.000Z","title":"利用WSL在Windows下获得更好的开发体验","excerpt":"WSL和WSL2都是大坑，这篇先介绍如何配置，先用起来，之后再更新一篇文章来细数WSL的问题与缺陷……","thumbnail":"","_content":"## 为什么Windows不适合作为开发使用？\n\n对于我个人的前端开发体验而言，主要在这几个方面：\n\n- 利用Node.js实现一些自动化功能，代码内经常混入一些Windows无法运行的bash命令；\n- Windows下一般不只有开发环境，还会安装一些其他的软件、游戏等等，相互影响；\n- 部分库没有做`cross-env`兼容，在Windows下执行会有意料之外的bug；\n- Windows的目录结构在实际使用时会有意料之外的问题；\n\n因此，WSL是在Windows下进行开发更好的选择。\n\n> 截止本文编写时，我仍不建议使用WSL2的版本，会给开发带来一些不必要的困扰，稳定后再体验。\n\n## 开启WSL\n\n有关于如何在Windows下开启WSL功能，很多文章在一年前都进行了说明。在当前版本号1909下，只需要注意以下几点：\n\n1. 可以正常使用Microsoft Store（也支持利用zip包安装，具体详见[官方文档](https://docs.microsoft.com/en-us/windows/wsl/install-manual)）；\n2. 开启“适用于Linux的Windows子系统”，设置路径在：控制面板\\程序\\程序和功能 -> 左侧“启用或关闭Windows功能”，这一步骤需要进行重启使得更改生效；\n\n## 安装\n\n安装比较简单，利用Microsoft Store搜索“Linux”，选择你喜欢的版本进行安装即可。\n\n> 安装会默认安装至C盘，如果你的C盘容量非常“宝贵”，建议使用[LxRunOffline](https://github.com/DDoSolitary/LxRunOffline)工具进行迁移，这个工具还可以进行管理等等功能，有兴趣的可以研究一下。我们下载它的Release并在Windows下解压到合适的目录下，利用PowerShell环境运行exe即可执行相关命令。\n\n等待下载完成后启动，需要等待一些时间，系统会自动对你选择的Linux发行版进行配置和初始化，输入你的用户名密码即可开始使用。\n\n## 配置\n\n配置上正常先将系统自带的各种包更新升级`sudo apt update && sudo apt upgrade`\n\n### ProxyChains\n\n由于WSL使用的是父主机（即Windows系统）的网络环境，因此在WSL环境下，部分软件安装配置时，会存在无法访问的情况（例如Github Release的文件分发地址……），强烈建议先配置[ProxyChains-NG](https://github.com/rofl0r/proxychains-ng)，可以选择手工下载源码make安装，也可以利用包管理器（目前包管理器版本较低，为3.x版本，仓库目前已经到了4.x版本，如果有能力建议使用源码安装，我使用的Ubuntu-18.04版本需要安装make与gcc包），`sudo apt install proxychains`进行安装，这里不赘述。\n\n安装好后在`/etc`目录下编辑（如果是源码安装，这里是创建）`proxychains.conf`文件，在文件内写入配置信息：\n\n```bash\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to \"tor\"\nsocks5 127.0.0.1 1080\n```\n\n在配置完成后，运行命令前带有`proxychains`即可通过代理，例如如下命令即可测试是否成功应用代理：\n\n```bash\nproxychains curl myip.ipip.net\n```\n\n如果显示代理，即配置成功。\n\n### Node.js & NPM\n\n这里其实没什么需要详细说明的，和我们在服务器环境配置Node.js同理。\n\n> 在官网的角落可以找到一个相对隐蔽的Node源地址，配置后可以直接通过包管理器快捷安装Node，相比于二进制与源码安装更为简单，其[仓库地址](https://github.com/nodesource/distributions)\n\n这里我遇到了Bug，在配置WSL环境前，我没有移除Windows下的Node环境，在完成了上述安装步骤后，`npm -v`提示“Unable to correct problems, you have held broken packages.”，看到对应报错地址指向了`/mnt/c`下的node目录时，明白了npm命令是调用了Windows环境下的npm，因此，卸载Windows下的nvm(__请通过“控制面板”内的软件功能进行卸载__)与Node.js后，移除WSL内已安装的Node.js并重新安装，一切正常工作，完美。\n\n### Oh my Zsh\n\n前文提到过，curl和wget目前都可以通过proxychains进行代理，这里其实没有太大的困难，但是，考虑到可能的DNS污染相关，这里我把官方的curl地址修改为`sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"`并使用代理，安装成功。\n\n> 如果提示SSL相关问题，wget下可以通过`wget --no-check-certificate`临时关闭SSL检查。\n\n这里我还遇到了一个无法连接的问题，我在安装的时候提示我`raw.githubusercontent.com`指向了0.0.0.0，查找[相关issue](https://github.com/microsoft/WSL/issues/3761)，执行以下命令查询是否有相关的软件控制网络或代理，检查发现我的“火绒”影响了，临时退出即可。\n\n```bash\npowershell.exe \"Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct\" | grep displayName\n```\n\n### SSH\n\n配置WSL的git环境需要对应的SSH-key，按照正常的方法，可以生成，但是无法复制出来，__WSL具有可以直接执行Windows环境exe程序的特性__，因此可以通过`cat ~/.ssh/id_rsa | clip.exe`直接复制出来。\n\n然而生成的key无法被Github识别，提示“key is invalid”，查阅得到[这个结果](https://stackoverflow.com/questions/47859437/windows-10-openssh-key-invalid-format)，虽然并不是完全一致的问题，但是提供了思路，将SSH生成的命令修改，删除指定长度“4096”的设置（-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。）\n\n```bash\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n配置到Github，成功。\n\n## 卸载与导出\n\n如果之后不再需要WSL环境，可以通过如下命令进行卸载：\n\n```bash\nwslconfig /unregister <wslconfig /list得到的对应名称>\n```\n\n额外的，建议将对应的UWP程序同时右键卸载进行彻底移除。\n\n如果希望备份迁移，可以使用前文提到过的LxRunOffline工具进行处理，可以参考项目的Readme进行操作。","source":"_posts/other/利用wsl在windows下获得更好的开发体验.md","raw":"---\ncategories: Other\ntags:\n- WSL\ndate: 2020-04-22T14:44:42.000+08:00\ntitle: 利用WSL在Windows下获得更好的开发体验\nexcerpt: WSL和WSL2都是大坑，这篇先介绍如何配置，先用起来，之后再更新一篇文章来细数WSL的问题与缺陷……\nthumbnail: ''\n\n---\n## 为什么Windows不适合作为开发使用？\n\n对于我个人的前端开发体验而言，主要在这几个方面：\n\n- 利用Node.js实现一些自动化功能，代码内经常混入一些Windows无法运行的bash命令；\n- Windows下一般不只有开发环境，还会安装一些其他的软件、游戏等等，相互影响；\n- 部分库没有做`cross-env`兼容，在Windows下执行会有意料之外的bug；\n- Windows的目录结构在实际使用时会有意料之外的问题；\n\n因此，WSL是在Windows下进行开发更好的选择。\n\n> 截止本文编写时，我仍不建议使用WSL2的版本，会给开发带来一些不必要的困扰，稳定后再体验。\n\n## 开启WSL\n\n有关于如何在Windows下开启WSL功能，很多文章在一年前都进行了说明。在当前版本号1909下，只需要注意以下几点：\n\n1. 可以正常使用Microsoft Store（也支持利用zip包安装，具体详见[官方文档](https://docs.microsoft.com/en-us/windows/wsl/install-manual)）；\n2. 开启“适用于Linux的Windows子系统”，设置路径在：控制面板\\程序\\程序和功能 -> 左侧“启用或关闭Windows功能”，这一步骤需要进行重启使得更改生效；\n\n## 安装\n\n安装比较简单，利用Microsoft Store搜索“Linux”，选择你喜欢的版本进行安装即可。\n\n> 安装会默认安装至C盘，如果你的C盘容量非常“宝贵”，建议使用[LxRunOffline](https://github.com/DDoSolitary/LxRunOffline)工具进行迁移，这个工具还可以进行管理等等功能，有兴趣的可以研究一下。我们下载它的Release并在Windows下解压到合适的目录下，利用PowerShell环境运行exe即可执行相关命令。\n\n等待下载完成后启动，需要等待一些时间，系统会自动对你选择的Linux发行版进行配置和初始化，输入你的用户名密码即可开始使用。\n\n## 配置\n\n配置上正常先将系统自带的各种包更新升级`sudo apt update && sudo apt upgrade`\n\n### ProxyChains\n\n由于WSL使用的是父主机（即Windows系统）的网络环境，因此在WSL环境下，部分软件安装配置时，会存在无法访问的情况（例如Github Release的文件分发地址……），强烈建议先配置[ProxyChains-NG](https://github.com/rofl0r/proxychains-ng)，可以选择手工下载源码make安装，也可以利用包管理器（目前包管理器版本较低，为3.x版本，仓库目前已经到了4.x版本，如果有能力建议使用源码安装，我使用的Ubuntu-18.04版本需要安装make与gcc包），`sudo apt install proxychains`进行安装，这里不赘述。\n\n安装好后在`/etc`目录下编辑（如果是源码安装，这里是创建）`proxychains.conf`文件，在文件内写入配置信息：\n\n```bash\n[ProxyList]\n# add proxy here ...\n# meanwile\n# defaults set to \"tor\"\nsocks5 127.0.0.1 1080\n```\n\n在配置完成后，运行命令前带有`proxychains`即可通过代理，例如如下命令即可测试是否成功应用代理：\n\n```bash\nproxychains curl myip.ipip.net\n```\n\n如果显示代理，即配置成功。\n\n### Node.js & NPM\n\n这里其实没什么需要详细说明的，和我们在服务器环境配置Node.js同理。\n\n> 在官网的角落可以找到一个相对隐蔽的Node源地址，配置后可以直接通过包管理器快捷安装Node，相比于二进制与源码安装更为简单，其[仓库地址](https://github.com/nodesource/distributions)\n\n这里我遇到了Bug，在配置WSL环境前，我没有移除Windows下的Node环境，在完成了上述安装步骤后，`npm -v`提示“Unable to correct problems, you have held broken packages.”，看到对应报错地址指向了`/mnt/c`下的node目录时，明白了npm命令是调用了Windows环境下的npm，因此，卸载Windows下的nvm(__请通过“控制面板”内的软件功能进行卸载__)与Node.js后，移除WSL内已安装的Node.js并重新安装，一切正常工作，完美。\n\n### Oh my Zsh\n\n前文提到过，curl和wget目前都可以通过proxychains进行代理，这里其实没有太大的困难，但是，考虑到可能的DNS污染相关，这里我把官方的curl地址修改为`sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"`并使用代理，安装成功。\n\n> 如果提示SSL相关问题，wget下可以通过`wget --no-check-certificate`临时关闭SSL检查。\n\n这里我还遇到了一个无法连接的问题，我在安装的时候提示我`raw.githubusercontent.com`指向了0.0.0.0，查找[相关issue](https://github.com/microsoft/WSL/issues/3761)，执行以下命令查询是否有相关的软件控制网络或代理，检查发现我的“火绒”影响了，临时退出即可。\n\n```bash\npowershell.exe \"Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct\" | grep displayName\n```\n\n### SSH\n\n配置WSL的git环境需要对应的SSH-key，按照正常的方法，可以生成，但是无法复制出来，__WSL具有可以直接执行Windows环境exe程序的特性__，因此可以通过`cat ~/.ssh/id_rsa | clip.exe`直接复制出来。\n\n然而生成的key无法被Github识别，提示“key is invalid”，查阅得到[这个结果](https://stackoverflow.com/questions/47859437/windows-10-openssh-key-invalid-format)，虽然并不是完全一致的问题，但是提供了思路，将SSH生成的命令修改，删除指定长度“4096”的设置（-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。）\n\n```bash\nssh-keygen -t rsa -C \"your_email@example.com\"\n```\n\n配置到Github，成功。\n\n## 卸载与导出\n\n如果之后不再需要WSL环境，可以通过如下命令进行卸载：\n\n```bash\nwslconfig /unregister <wslconfig /list得到的对应名称>\n```\n\n额外的，建议将对应的UWP程序同时右键卸载进行彻底移除。\n\n如果希望备份迁移，可以使用前文提到过的LxRunOffline工具进行处理，可以参考项目的Readme进行操作。","slug":"other/利用wsl在windows下获得更好的开发体验","published":1,"updated":"2020-08-01T18:21:52.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ibg003oj1wtg77g4wd2","content":"<h2 id=\"为什么Windows不适合作为开发使用？\"><a href=\"#为什么Windows不适合作为开发使用？\" class=\"headerlink\" title=\"为什么Windows不适合作为开发使用？\"></a>为什么Windows不适合作为开发使用？</h2><p>对于我个人的前端开发体验而言，主要在这几个方面：</p>\n<ul>\n<li>利用Node.js实现一些自动化功能，代码内经常混入一些Windows无法运行的bash命令；</li>\n<li>Windows下一般不只有开发环境，还会安装一些其他的软件、游戏等等，相互影响；</li>\n<li>部分库没有做<code>cross-env</code>兼容，在Windows下执行会有意料之外的bug；</li>\n<li>Windows的目录结构在实际使用时会有意料之外的问题；</li>\n</ul>\n<p>因此，WSL是在Windows下进行开发更好的选择。</p>\n<blockquote>\n<p>截止本文编写时，我仍不建议使用WSL2的版本，会给开发带来一些不必要的困扰，稳定后再体验。</p>\n</blockquote>\n<h2 id=\"开启WSL\"><a href=\"#开启WSL\" class=\"headerlink\" title=\"开启WSL\"></a>开启WSL</h2><p>有关于如何在Windows下开启WSL功能，很多文章在一年前都进行了说明。在当前版本号1909下，只需要注意以下几点：</p>\n<ol>\n<li>可以正常使用Microsoft Store（也支持利用zip包安装，具体详见<a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-manual\">官方文档</a>）；</li>\n<li>开启“适用于Linux的Windows子系统”，设置路径在：控制面板\\程序\\程序和功能 -&gt; 左侧“启用或关闭Windows功能”，这一步骤需要进行重启使得更改生效；</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装比较简单，利用Microsoft Store搜索“Linux”，选择你喜欢的版本进行安装即可。</p>\n<blockquote>\n<p>安装会默认安装至C盘，如果你的C盘容量非常“宝贵”，建议使用<a href=\"https://github.com/DDoSolitary/LxRunOffline\">LxRunOffline</a>工具进行迁移，这个工具还可以进行管理等等功能，有兴趣的可以研究一下。我们下载它的Release并在Windows下解压到合适的目录下，利用PowerShell环境运行exe即可执行相关命令。</p>\n</blockquote>\n<p>等待下载完成后启动，需要等待一些时间，系统会自动对你选择的Linux发行版进行配置和初始化，输入你的用户名密码即可开始使用。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>配置上正常先将系统自带的各种包更新升级<code>sudo apt update &amp;&amp; sudo apt upgrade</code></p>\n<h3 id=\"ProxyChains\"><a href=\"#ProxyChains\" class=\"headerlink\" title=\"ProxyChains\"></a>ProxyChains</h3><p>由于WSL使用的是父主机（即Windows系统）的网络环境，因此在WSL环境下，部分软件安装配置时，会存在无法访问的情况（例如Github Release的文件分发地址……），强烈建议先配置<a href=\"https://github.com/rofl0r/proxychains-ng\">ProxyChains-NG</a>，可以选择手工下载源码make安装，也可以利用包管理器（目前包管理器版本较低，为3.x版本，仓库目前已经到了4.x版本，如果有能力建议使用源码安装，我使用的Ubuntu-18.04版本需要安装make与gcc包），<code>sudo apt install proxychains</code>进行安装，这里不赘述。</p>\n<p>安装好后在<code>/etc</code>目录下编辑（如果是源码安装，这里是创建）<code>proxychains.conf</code>文件，在文件内写入配置信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ProxyList]</span><br><span class=\"line\"><span class=\"comment\"># add proxy here ...</span></span><br><span class=\"line\"><span class=\"comment\"># meanwile</span></span><br><span class=\"line\"><span class=\"comment\"># defaults set to \"tor\"</span></span><br><span class=\"line\">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>\n\n<p>在配置完成后，运行命令前带有<code>proxychains</code>即可通过代理，例如如下命令即可测试是否成功应用代理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxychains curl myip.ipip.net</span><br></pre></td></tr></table></figure>\n\n<p>如果显示代理，即配置成功。</p>\n<h3 id=\"Node-js-amp-NPM\"><a href=\"#Node-js-amp-NPM\" class=\"headerlink\" title=\"Node.js &amp; NPM\"></a>Node.js &amp; NPM</h3><p>这里其实没什么需要详细说明的，和我们在服务器环境配置Node.js同理。</p>\n<blockquote>\n<p>在官网的角落可以找到一个相对隐蔽的Node源地址，配置后可以直接通过包管理器快捷安装Node，相比于二进制与源码安装更为简单，其<a href=\"https://github.com/nodesource/distributions\">仓库地址</a></p>\n</blockquote>\n<p>这里我遇到了Bug，在配置WSL环境前，我没有移除Windows下的Node环境，在完成了上述安装步骤后，<code>npm -v</code>提示“Unable to correct problems, you have held broken packages.”，看到对应报错地址指向了<code>/mnt/c</code>下的node目录时，明白了npm命令是调用了Windows环境下的npm，因此，卸载Windows下的nvm(<strong>请通过“控制面板”内的软件功能进行卸载</strong>)与Node.js后，移除WSL内已安装的Node.js并重新安装，一切正常工作，完美。</p>\n<h3 id=\"Oh-my-Zsh\"><a href=\"#Oh-my-Zsh\" class=\"headerlink\" title=\"Oh my Zsh\"></a>Oh my Zsh</h3><p>前文提到过，curl和wget目前都可以通过proxychains进行代理，这里其实没有太大的困难，但是，考虑到可能的DNS污染相关，这里我把官方的curl地址修改为<code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code>并使用代理，安装成功。</p>\n<blockquote>\n<p>如果提示SSL相关问题，wget下可以通过<code>wget --no-check-certificate</code>临时关闭SSL检查。</p>\n</blockquote>\n<p>这里我还遇到了一个无法连接的问题，我在安装的时候提示我<code>raw.githubusercontent.com</code>指向了0.0.0.0，查找<a href=\"https://github.com/microsoft/WSL/issues/3761\">相关issue</a>，执行以下命令查询是否有相关的软件控制网络或代理，检查发现我的“火绒”影响了，临时退出即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell.exe <span class=\"string\">\"Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct\"</span> | grep displayName</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><p>配置WSL的git环境需要对应的SSH-key，按照正常的方法，可以生成，但是无法复制出来，__WSL具有可以直接执行Windows环境exe程序的特性__，因此可以通过<code>cat ~/.ssh/id_rsa | clip.exe</code>直接复制出来。</p>\n<p>然而生成的key无法被Github识别，提示“key is invalid”，查阅得到<a href=\"https://stackoverflow.com/questions/47859437/windows-10-openssh-key-invalid-format\">这个结果</a>，虽然并不是完全一致的问题，但是提供了思路，将SSH生成的命令修改，删除指定长度“4096”的设置（-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"your_email@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>配置到Github，成功。</p>\n<h2 id=\"卸载与导出\"><a href=\"#卸载与导出\" class=\"headerlink\" title=\"卸载与导出\"></a>卸载与导出</h2><p>如果之后不再需要WSL环境，可以通过如下命令进行卸载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wslconfig /unregister &lt;wslconfig /list得到的对应名称&gt;</span><br></pre></td></tr></table></figure>\n\n<p>额外的，建议将对应的UWP程序同时右键卸载进行彻底移除。</p>\n<p>如果希望备份迁移，可以使用前文提到过的LxRunOffline工具进行处理，可以参考项目的Readme进行操作。</p>\n","site":{"data":{}},"more":"<h2 id=\"为什么Windows不适合作为开发使用？\"><a href=\"#为什么Windows不适合作为开发使用？\" class=\"headerlink\" title=\"为什么Windows不适合作为开发使用？\"></a>为什么Windows不适合作为开发使用？</h2><p>对于我个人的前端开发体验而言，主要在这几个方面：</p>\n<ul>\n<li>利用Node.js实现一些自动化功能，代码内经常混入一些Windows无法运行的bash命令；</li>\n<li>Windows下一般不只有开发环境，还会安装一些其他的软件、游戏等等，相互影响；</li>\n<li>部分库没有做<code>cross-env</code>兼容，在Windows下执行会有意料之外的bug；</li>\n<li>Windows的目录结构在实际使用时会有意料之外的问题；</li>\n</ul>\n<p>因此，WSL是在Windows下进行开发更好的选择。</p>\n<blockquote>\n<p>截止本文编写时，我仍不建议使用WSL2的版本，会给开发带来一些不必要的困扰，稳定后再体验。</p>\n</blockquote>\n<h2 id=\"开启WSL\"><a href=\"#开启WSL\" class=\"headerlink\" title=\"开启WSL\"></a>开启WSL</h2><p>有关于如何在Windows下开启WSL功能，很多文章在一年前都进行了说明。在当前版本号1909下，只需要注意以下几点：</p>\n<ol>\n<li>可以正常使用Microsoft Store（也支持利用zip包安装，具体详见<a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-manual\">官方文档</a>）；</li>\n<li>开启“适用于Linux的Windows子系统”，设置路径在：控制面板\\程序\\程序和功能 -&gt; 左侧“启用或关闭Windows功能”，这一步骤需要进行重启使得更改生效；</li>\n</ol>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装比较简单，利用Microsoft Store搜索“Linux”，选择你喜欢的版本进行安装即可。</p>\n<blockquote>\n<p>安装会默认安装至C盘，如果你的C盘容量非常“宝贵”，建议使用<a href=\"https://github.com/DDoSolitary/LxRunOffline\">LxRunOffline</a>工具进行迁移，这个工具还可以进行管理等等功能，有兴趣的可以研究一下。我们下载它的Release并在Windows下解压到合适的目录下，利用PowerShell环境运行exe即可执行相关命令。</p>\n</blockquote>\n<p>等待下载完成后启动，需要等待一些时间，系统会自动对你选择的Linux发行版进行配置和初始化，输入你的用户名密码即可开始使用。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>配置上正常先将系统自带的各种包更新升级<code>sudo apt update &amp;&amp; sudo apt upgrade</code></p>\n<h3 id=\"ProxyChains\"><a href=\"#ProxyChains\" class=\"headerlink\" title=\"ProxyChains\"></a>ProxyChains</h3><p>由于WSL使用的是父主机（即Windows系统）的网络环境，因此在WSL环境下，部分软件安装配置时，会存在无法访问的情况（例如Github Release的文件分发地址……），强烈建议先配置<a href=\"https://github.com/rofl0r/proxychains-ng\">ProxyChains-NG</a>，可以选择手工下载源码make安装，也可以利用包管理器（目前包管理器版本较低，为3.x版本，仓库目前已经到了4.x版本，如果有能力建议使用源码安装，我使用的Ubuntu-18.04版本需要安装make与gcc包），<code>sudo apt install proxychains</code>进行安装，这里不赘述。</p>\n<p>安装好后在<code>/etc</code>目录下编辑（如果是源码安装，这里是创建）<code>proxychains.conf</code>文件，在文件内写入配置信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ProxyList]</span><br><span class=\"line\"><span class=\"comment\"># add proxy here ...</span></span><br><span class=\"line\"><span class=\"comment\"># meanwile</span></span><br><span class=\"line\"><span class=\"comment\"># defaults set to \"tor\"</span></span><br><span class=\"line\">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>\n\n<p>在配置完成后，运行命令前带有<code>proxychains</code>即可通过代理，例如如下命令即可测试是否成功应用代理：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxychains curl myip.ipip.net</span><br></pre></td></tr></table></figure>\n\n<p>如果显示代理，即配置成功。</p>\n<h3 id=\"Node-js-amp-NPM\"><a href=\"#Node-js-amp-NPM\" class=\"headerlink\" title=\"Node.js &amp; NPM\"></a>Node.js &amp; NPM</h3><p>这里其实没什么需要详细说明的，和我们在服务器环境配置Node.js同理。</p>\n<blockquote>\n<p>在官网的角落可以找到一个相对隐蔽的Node源地址，配置后可以直接通过包管理器快捷安装Node，相比于二进制与源码安装更为简单，其<a href=\"https://github.com/nodesource/distributions\">仓库地址</a></p>\n</blockquote>\n<p>这里我遇到了Bug，在配置WSL环境前，我没有移除Windows下的Node环境，在完成了上述安装步骤后，<code>npm -v</code>提示“Unable to correct problems, you have held broken packages.”，看到对应报错地址指向了<code>/mnt/c</code>下的node目录时，明白了npm命令是调用了Windows环境下的npm，因此，卸载Windows下的nvm(<strong>请通过“控制面板”内的软件功能进行卸载</strong>)与Node.js后，移除WSL内已安装的Node.js并重新安装，一切正常工作，完美。</p>\n<h3 id=\"Oh-my-Zsh\"><a href=\"#Oh-my-Zsh\" class=\"headerlink\" title=\"Oh my Zsh\"></a>Oh my Zsh</h3><p>前文提到过，curl和wget目前都可以通过proxychains进行代理，这里其实没有太大的困难，但是，考虑到可能的DNS污染相关，这里我把官方的curl地址修改为<code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code>并使用代理，安装成功。</p>\n<blockquote>\n<p>如果提示SSL相关问题，wget下可以通过<code>wget --no-check-certificate</code>临时关闭SSL检查。</p>\n</blockquote>\n<p>这里我还遇到了一个无法连接的问题，我在安装的时候提示我<code>raw.githubusercontent.com</code>指向了0.0.0.0，查找<a href=\"https://github.com/microsoft/WSL/issues/3761\">相关issue</a>，执行以下命令查询是否有相关的软件控制网络或代理，检查发现我的“火绒”影响了，临时退出即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell.exe <span class=\"string\">\"Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct\"</span> | grep displayName</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SSH\"><a href=\"#SSH\" class=\"headerlink\" title=\"SSH\"></a>SSH</h3><p>配置WSL的git环境需要对应的SSH-key，按照正常的方法，可以生成，但是无法复制出来，__WSL具有可以直接执行Windows环境exe程序的特性__，因此可以通过<code>cat ~/.ssh/id_rsa | clip.exe</code>直接复制出来。</p>\n<p>然而生成的key无法被Github识别，提示“key is invalid”，查阅得到<a href=\"https://stackoverflow.com/questions/47859437/windows-10-openssh-key-invalid-format\">这个结果</a>，虽然并不是完全一致的问题，但是提供了思路，将SSH生成的命令修改，删除指定长度“4096”的设置（-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">\"your_email@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>配置到Github，成功。</p>\n<h2 id=\"卸载与导出\"><a href=\"#卸载与导出\" class=\"headerlink\" title=\"卸载与导出\"></a>卸载与导出</h2><p>如果之后不再需要WSL环境，可以通过如下命令进行卸载：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wslconfig /unregister &lt;wslconfig /list得到的对应名称&gt;</span><br></pre></td></tr></table></figure>\n\n<p>额外的，建议将对应的UWP程序同时右键卸载进行彻底移除。</p>\n<p>如果希望备份迁移，可以使用前文提到过的LxRunOffline工具进行处理，可以参考项目的Readme进行操作。</p>\n"},{"title":"我的博客更新日志","date":"2020-02-26T08:00:00.000Z","excerpt":"没事总要手欠改改博客……，从hexo转到netlify/now.sh，如今又要转回hexo","thumbnail":"","_content":"# 更新日志\n\n### v0.2.0\n\n* 从Now.sh 迁移到 Cloudflare Worker Sites，从Next.js迁移到Hexo（为了更丰富的插件环境）；\n* 个人所有域名从sparking.app迁移到sparkling.land，公开服务则配置在sparkling.fun；\n* 正在二次开发Icarus主题……\n* 使用Amazon S3存储博客图片，体验一个月感受费用\n\n### v0.1.0\n\n* 使用Serverless架构重构博客，技术栈目前为(Next.js + Now.sh + Tailwind CSS)\n* 重新配置Disqus评论模块\n* 重新设计整体样式，使用React组件重构整体\n\n### v0.0.1\n\n* 通过Netlify + Foresty.io + Hexo完成自动部署，脱离纯git提交模式；\n* 添加GA统计；\n* 添加Disqus评论；\n\n### 测试功能\n\n上传一张图片\n\n![Persona 5 S](https://cdn.sparkling.land/public/blog/images/p5s.jpg)","source":"_posts/other/我的博客更新日志.md","raw":"---\ntags:\n- 记录\ncategories: Other\ntitle: 我的博客更新日志\ndate: 2020-02-27T00:00:00.000+08:00\nexcerpt: 没事总要手欠改改博客……，从hexo转到netlify/now.sh，如今又要转回hexo\nthumbnail: ''\n\n---\n# 更新日志\n\n### v0.2.0\n\n* 从Now.sh 迁移到 Cloudflare Worker Sites，从Next.js迁移到Hexo（为了更丰富的插件环境）；\n* 个人所有域名从sparking.app迁移到sparkling.land，公开服务则配置在sparkling.fun；\n* 正在二次开发Icarus主题……\n* 使用Amazon S3存储博客图片，体验一个月感受费用\n\n### v0.1.0\n\n* 使用Serverless架构重构博客，技术栈目前为(Next.js + Now.sh + Tailwind CSS)\n* 重新配置Disqus评论模块\n* 重新设计整体样式，使用React组件重构整体\n\n### v0.0.1\n\n* 通过Netlify + Foresty.io + Hexo完成自动部署，脱离纯git提交模式；\n* 添加GA统计；\n* 添加Disqus评论；\n\n### 测试功能\n\n上传一张图片\n\n![Persona 5 S](https://cdn.sparkling.land/public/blog/images/p5s.jpg)","slug":"other/我的博客更新日志","published":1,"updated":"2020-08-02T12:34:30.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ibh003qj1wt4q0ta2kb","content":"<h1 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h1><h3 id=\"v0-2-0\"><a href=\"#v0-2-0\" class=\"headerlink\" title=\"v0.2.0\"></a>v0.2.0</h3><ul>\n<li>从Now.sh 迁移到 Cloudflare Worker Sites，从Next.js迁移到Hexo（为了更丰富的插件环境）；</li>\n<li>个人所有域名从sparking.app迁移到sparkling.land，公开服务则配置在sparkling.fun；</li>\n<li>正在二次开发Icarus主题……</li>\n<li>使用Amazon S3存储博客图片，体验一个月感受费用</li>\n</ul>\n<h3 id=\"v0-1-0\"><a href=\"#v0-1-0\" class=\"headerlink\" title=\"v0.1.0\"></a>v0.1.0</h3><ul>\n<li>使用Serverless架构重构博客，技术栈目前为(Next.js + Now.sh + Tailwind CSS)</li>\n<li>重新配置Disqus评论模块</li>\n<li>重新设计整体样式，使用React组件重构整体</li>\n</ul>\n<h3 id=\"v0-0-1\"><a href=\"#v0-0-1\" class=\"headerlink\" title=\"v0.0.1\"></a>v0.0.1</h3><ul>\n<li>通过Netlify + Foresty.io + Hexo完成自动部署，脱离纯git提交模式；</li>\n<li>添加GA统计；</li>\n<li>添加Disqus评论；</li>\n</ul>\n<h3 id=\"测试功能\"><a href=\"#测试功能\" class=\"headerlink\" title=\"测试功能\"></a>测试功能</h3><p>上传一张图片</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/p5s.jpg\" alt=\"Persona 5 S\"></p>\n","site":{"data":{}},"more":"<h1 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h1><h3 id=\"v0-2-0\"><a href=\"#v0-2-0\" class=\"headerlink\" title=\"v0.2.0\"></a>v0.2.0</h3><ul>\n<li>从Now.sh 迁移到 Cloudflare Worker Sites，从Next.js迁移到Hexo（为了更丰富的插件环境）；</li>\n<li>个人所有域名从sparking.app迁移到sparkling.land，公开服务则配置在sparkling.fun；</li>\n<li>正在二次开发Icarus主题……</li>\n<li>使用Amazon S3存储博客图片，体验一个月感受费用</li>\n</ul>\n<h3 id=\"v0-1-0\"><a href=\"#v0-1-0\" class=\"headerlink\" title=\"v0.1.0\"></a>v0.1.0</h3><ul>\n<li>使用Serverless架构重构博客，技术栈目前为(Next.js + Now.sh + Tailwind CSS)</li>\n<li>重新配置Disqus评论模块</li>\n<li>重新设计整体样式，使用React组件重构整体</li>\n</ul>\n<h3 id=\"v0-0-1\"><a href=\"#v0-0-1\" class=\"headerlink\" title=\"v0.0.1\"></a>v0.0.1</h3><ul>\n<li>通过Netlify + Foresty.io + Hexo完成自动部署，脱离纯git提交模式；</li>\n<li>添加GA统计；</li>\n<li>添加Disqus评论；</li>\n</ul>\n<h3 id=\"测试功能\"><a href=\"#测试功能\" class=\"headerlink\" title=\"测试功能\"></a>测试功能</h3><p>上传一张图片</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/p5s.jpg\" alt=\"Persona 5 S\"></p>\n"},{"date":"2020-03-01T02:18:25.000Z","title":"\"Speaking JavaScript\"阅读笔记（三）","excerpt":"JavaScript阅读笔记第三部分，这部分进入到了核心部分——函数，变量，对象。","thumbnail":"","_content":"_本章开始写函数与对象，内容相对较多单起一章专门记录_\n\n### 10. 函数\n\nJavaScript中的函数一共有三种形式：\n\n* 非方法的函数（“普通函数”）；\n* 构造器；\n* 方法；\n\n因此我们创建函数一共有三种：\n\n* 通过函数表达式；\n* 通过函数声明；\n* 通过Function()构造器（不推荐）；\n\n所有的函数都是对象、Function构造器的实例。\n\n具名函数表达式只能在函数表达式的内部被访问。\n\n在函数的内部，有两个特殊的对象，arguments和this。\n\n> this引用的值是函数数据以执行的环境对象——或者也可以说是this值。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。\n\n> ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。\n\n#### 10.1. 控制函数调用，`call()`, `apply()`和`bind()`\n\n_bind()方法非原生，本节末尾会给出使用apply实现bind。_\n\n使用：\n\n```javascript\nfunc.apply(thisValue, argArray)\nfunc.call(thisValue, arg1, ..., argN)\nfunc.bind(thisValue, arg1, ..., argN) // 创建一个新函数，会调用func，再绑定this到新的thisValue\n```\n\n一个非常有趣的陷阱：\n\n```javascript\n['1', '2', '3'].map(parseInt) // [1, NaN, NaN]\n```\n\n这是因为parseInt只接受一个参数，map的期望函数签名`function(element, index, array)`，而parseInt的签名则是`parseInt(string, radix?)`, 这会导致radix也被传入。\n\n#### 10.1.1 实现bind\n\n_本节的实现来自JS高程_\n\n1. apply\n\n```javascript\nfunction bind(fn, context) {\n  return function () {\n    return fn.apply(context, arguments);\n  }\n}\n```\n\n1. apply的柯里化版本\n\n```javascript\nfunction bind(fn, context) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  return function () {\n    var innerArgs = Array.prototype.slice.call(arguments);\n    var finalArgs = args.concat(innerArgs);\n    return fn.apply(context, finalArgs);\n  }\n}\n```\n\n### 11. 变量：作用域、环境和闭包\n\n> 全局执行环境是最外围的一个执行环境，每个函数都有自己的执行环境，eval也会创建一个独立的执行环境。\n\n#### 11.1. 作用域\n\nJavaScript的变量是函数级作用域的，**只有函数可以产生新的作用域**。\n\nJavaScript会提前所有的变量声明，它会把所有的声明移到直接作用域的最前面。\n\n#### 11.2. IIFE\n\n* 它是立即执行的；\n* 它必须是一个表达式；\n* 连续的两个IIFE之间需要分号，不然会导致解析错误。\n\nIIFE也可以前缀运算符，比如!, void都是可以的，避免了分号的问题。\n\n```javascript\nvar File = function () { // open IIFE\n\t// do something...\n}(); // close IIFE\n```\n\n#### 11.3. 全局对象\n\n全局对象是有原型的。\n\n#### 11.4. 环境\n\n无论一个函数被调用多少次，它总要访问它自己（最新）的本地变量和外部作用域的变量。当多次调用自己的时候，每次调用都会创建一个新的环境。\n\n通过闭包可以使得函数可以维持其创建时所在的作用域。但如果创建时受到了当前作用域变量的影响，会存在环境公用的影响。\n\n#### 11.5. 垃圾收集\n\n两种垃圾收集机制，__标记清除__，__引用计数__，两种都有使用，标记清除更为常用，引用计数一般用于COM对象。\n\n#### 11.6. 闭包\n\n> __闭包__ 是指有权访问另一个函数作用域中的变量的函数。\n\n创建闭包的常见方式，就是在一个函数内部创建另一个函数。\n\n闭包只能取得包含函数中任何变量的最后一个值。\n\n#### 11.7. 闭包中的this\n\n在闭包中使用this对象会导致一些问题，因为this对象是在运行时基于函数的执行环境绑定的。\n\n> 如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。\n\n### 12. 对象与继承\n\nJavaScript中的面向对象编程（OOP）分为以下几层：\n\n* 第一层，单一对象的面向对象；\n* 第二层，对象间的原型链；\n* 第三层，作为实例工厂的构造函数，类似于其他语言的类；\n* 第四层，子类，通过继承已有的构造函数，创建新的构造函数。\n\n#### 12.1. 第一层，单一对象的面向对象\n\n##### 12.1.1 属性\n\n属性分为三种：\n\n1. 属性\n2. 访问器\n3. 内置属性（规范将内置属性的键置于方括号中，例如`[[Prototype]]`）\n\ndelete只影响一个对象的直接“自有”的，非继承的属性，delete成功则返回true，如果是自有属性但不能删除则返回false。\n\n##### 12.1.2 对象字面量\n\n```javascript\nvar jane = {\n  name: 'jane',\n  describe: function () {\n    return 'Person named ' + this.name;\n  }\n}\n```\n\n#### 12.2. 第二层，对象间的关系——原型链\n\n```javascript\nvar proto = {\n  describe: function () {\n    return 'name: ' + this.name;\n  }\n};\nvar obj = {\n  [[Prototype]]: proto, // 实际不可访问\n  name: 'obj'\n}\n```\n\n对象obj从proto继承了describe属性。\n\n当通过obj访问属性时，JS首先从本对象中查找，接着是它的原型，以及它原型的原型。\n\n在ES5后，我们可以通过`Object.create(proto, propDescObj?)`完成使用给定prototype创建新对象。\n\n检测时，可以使用：\n\n```javascript\nObject.prototype.isPrototypeOf(obj); // 会检索整个链上\n```\n\n#### 12.2.1 特殊属性__proto__\n\n某些JavaScript引擎有特殊属性可以获取和设置对象的原型：`__proto__`。这样可以直接访问`[[Prototype]]`。其在ES6内将会作为标准。\n\n方法区分：\n\n* `Object.getOwnPropertyNames(obj)` 返回obj的所有 **自有** 的属性键。\n* `Object.keys(obj)` 返回obj的所有 **可枚举** 的属性键。\n\n#### 12.3 访问器\n\n```javascript\nvar obj = {\n  get foo() { // 取值调用，getter\n    return 'getter';\n  },\n  set foo(value) { // 赋值调用，setter\n    console.log('setter: '+value);\n  }\n}\n```\n\n#### 12.4 属性特性和属性描述符\n\n* Value\n* Writable\n* Get\n* Set\n* Enumerable\n* Configurable\n\n#### 12.5 复制对象\n\n复制要保证：\n\n1. 拷贝必须具有与原对象相同的原型；\n2. 拷贝必须具有与原对象相同的属性和特性；\n\n```javascript\nfunction copyObject(orig) {\n  // copy prototype\n  var copy = Object.create(Object.getPrototypeOf(orig));\n  // copy all properties\n  copyOwnPropertiesFrom(copy, orig);\n  return copy;\n}\n\nfunction copyOwnPropertiesFrom(target, source) {\n  Object.getOwnPropertyNames(source).forEach(function (propKey) {\n    var desc = Object.getOwnProperyDescriptor(source, propKey);\n    Object.defineProperty(target, propKey, desc);  // 使用获取的属性描述符创建target的自有属性\n  });\n  return target;\n}\n```\n\n#### 12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类\n\nSpeaking JavaScript内推荐的构造函数写法：\n\n> ```javascript\n> function Person(name) {\n>   this.name = name;\n> }\n> Person.prototype.describe = function () {\n>   return 'Person named ' + this.name;\n> };\n> ```\n\n经典面试内容：\nQ：new操作符都做了什么？\nA：\n\n1. 创建一个新对象；\n2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；\n3. 执行构造函数中的代码（为这个新对象添加属性）；\n4. 返回新对象。\n\n> 引用类型与基本包装类型（“装箱”）的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。\n\nSpeaking JavaScript内对这个过程的描述：\n\n> 首先设置行为：创建一个新对象，其原型为Person.prototype;\n> 然后设置数据：Person接受对象作为隐式参数this，并添加实例属性。\n\n代码模拟如下:\n\n```javascript\nfunction newOperator(Constr,args) {\n  var thisValue = Object.create(Constr.prototype);\n  var result = Constr.apply(thisValue, args);\n  if(typeof result === 'object' && result !== null) {\n  \treturn result;\n  }\n  return thisValue;\n}\n```\n\n每个函数包含一个实例原型对象，它的constructor属性指回函数。\n\n### 12.7 泛型方法：借用原型方法\n\n```javascript\nWine.prototyte.incAge.call(john, 3) // 类似于这样的模式\n```\n\n对于泛型方法，最常用的是处理一些“Array like”的元素，借用数组方法进行处理。\n\n通过 `Array.isArray` 也可以作为数组的判断，能够区分Array-like。","source":"_posts/fe/speaking-javascript-阅读笔记-三.md","raw":"---\ncategories: Frontend\ntags:\n- JavaScript\ndate: 2020-03-01T10:18:25.000+00:00\ntitle: '\"Speaking JavaScript\"阅读笔记（三）'\nexcerpt: JavaScript阅读笔记第三部分，这部分进入到了核心部分——函数，变量，对象。\nthumbnail: ''\n\n---\n_本章开始写函数与对象，内容相对较多单起一章专门记录_\n\n### 10. 函数\n\nJavaScript中的函数一共有三种形式：\n\n* 非方法的函数（“普通函数”）；\n* 构造器；\n* 方法；\n\n因此我们创建函数一共有三种：\n\n* 通过函数表达式；\n* 通过函数声明；\n* 通过Function()构造器（不推荐）；\n\n所有的函数都是对象、Function构造器的实例。\n\n具名函数表达式只能在函数表达式的内部被访问。\n\n在函数的内部，有两个特殊的对象，arguments和this。\n\n> this引用的值是函数数据以执行的环境对象——或者也可以说是this值。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。\n\n> ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。\n\n#### 10.1. 控制函数调用，`call()`, `apply()`和`bind()`\n\n_bind()方法非原生，本节末尾会给出使用apply实现bind。_\n\n使用：\n\n```javascript\nfunc.apply(thisValue, argArray)\nfunc.call(thisValue, arg1, ..., argN)\nfunc.bind(thisValue, arg1, ..., argN) // 创建一个新函数，会调用func，再绑定this到新的thisValue\n```\n\n一个非常有趣的陷阱：\n\n```javascript\n['1', '2', '3'].map(parseInt) // [1, NaN, NaN]\n```\n\n这是因为parseInt只接受一个参数，map的期望函数签名`function(element, index, array)`，而parseInt的签名则是`parseInt(string, radix?)`, 这会导致radix也被传入。\n\n#### 10.1.1 实现bind\n\n_本节的实现来自JS高程_\n\n1. apply\n\n```javascript\nfunction bind(fn, context) {\n  return function () {\n    return fn.apply(context, arguments);\n  }\n}\n```\n\n1. apply的柯里化版本\n\n```javascript\nfunction bind(fn, context) {\n  var args = Array.prototype.slice.call(arguments, 2);\n  return function () {\n    var innerArgs = Array.prototype.slice.call(arguments);\n    var finalArgs = args.concat(innerArgs);\n    return fn.apply(context, finalArgs);\n  }\n}\n```\n\n### 11. 变量：作用域、环境和闭包\n\n> 全局执行环境是最外围的一个执行环境，每个函数都有自己的执行环境，eval也会创建一个独立的执行环境。\n\n#### 11.1. 作用域\n\nJavaScript的变量是函数级作用域的，**只有函数可以产生新的作用域**。\n\nJavaScript会提前所有的变量声明，它会把所有的声明移到直接作用域的最前面。\n\n#### 11.2. IIFE\n\n* 它是立即执行的；\n* 它必须是一个表达式；\n* 连续的两个IIFE之间需要分号，不然会导致解析错误。\n\nIIFE也可以前缀运算符，比如!, void都是可以的，避免了分号的问题。\n\n```javascript\nvar File = function () { // open IIFE\n\t// do something...\n}(); // close IIFE\n```\n\n#### 11.3. 全局对象\n\n全局对象是有原型的。\n\n#### 11.4. 环境\n\n无论一个函数被调用多少次，它总要访问它自己（最新）的本地变量和外部作用域的变量。当多次调用自己的时候，每次调用都会创建一个新的环境。\n\n通过闭包可以使得函数可以维持其创建时所在的作用域。但如果创建时受到了当前作用域变量的影响，会存在环境公用的影响。\n\n#### 11.5. 垃圾收集\n\n两种垃圾收集机制，__标记清除__，__引用计数__，两种都有使用，标记清除更为常用，引用计数一般用于COM对象。\n\n#### 11.6. 闭包\n\n> __闭包__ 是指有权访问另一个函数作用域中的变量的函数。\n\n创建闭包的常见方式，就是在一个函数内部创建另一个函数。\n\n闭包只能取得包含函数中任何变量的最后一个值。\n\n#### 11.7. 闭包中的this\n\n在闭包中使用this对象会导致一些问题，因为this对象是在运行时基于函数的执行环境绑定的。\n\n> 如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。\n\n### 12. 对象与继承\n\nJavaScript中的面向对象编程（OOP）分为以下几层：\n\n* 第一层，单一对象的面向对象；\n* 第二层，对象间的原型链；\n* 第三层，作为实例工厂的构造函数，类似于其他语言的类；\n* 第四层，子类，通过继承已有的构造函数，创建新的构造函数。\n\n#### 12.1. 第一层，单一对象的面向对象\n\n##### 12.1.1 属性\n\n属性分为三种：\n\n1. 属性\n2. 访问器\n3. 内置属性（规范将内置属性的键置于方括号中，例如`[[Prototype]]`）\n\ndelete只影响一个对象的直接“自有”的，非继承的属性，delete成功则返回true，如果是自有属性但不能删除则返回false。\n\n##### 12.1.2 对象字面量\n\n```javascript\nvar jane = {\n  name: 'jane',\n  describe: function () {\n    return 'Person named ' + this.name;\n  }\n}\n```\n\n#### 12.2. 第二层，对象间的关系——原型链\n\n```javascript\nvar proto = {\n  describe: function () {\n    return 'name: ' + this.name;\n  }\n};\nvar obj = {\n  [[Prototype]]: proto, // 实际不可访问\n  name: 'obj'\n}\n```\n\n对象obj从proto继承了describe属性。\n\n当通过obj访问属性时，JS首先从本对象中查找，接着是它的原型，以及它原型的原型。\n\n在ES5后，我们可以通过`Object.create(proto, propDescObj?)`完成使用给定prototype创建新对象。\n\n检测时，可以使用：\n\n```javascript\nObject.prototype.isPrototypeOf(obj); // 会检索整个链上\n```\n\n#### 12.2.1 特殊属性__proto__\n\n某些JavaScript引擎有特殊属性可以获取和设置对象的原型：`__proto__`。这样可以直接访问`[[Prototype]]`。其在ES6内将会作为标准。\n\n方法区分：\n\n* `Object.getOwnPropertyNames(obj)` 返回obj的所有 **自有** 的属性键。\n* `Object.keys(obj)` 返回obj的所有 **可枚举** 的属性键。\n\n#### 12.3 访问器\n\n```javascript\nvar obj = {\n  get foo() { // 取值调用，getter\n    return 'getter';\n  },\n  set foo(value) { // 赋值调用，setter\n    console.log('setter: '+value);\n  }\n}\n```\n\n#### 12.4 属性特性和属性描述符\n\n* Value\n* Writable\n* Get\n* Set\n* Enumerable\n* Configurable\n\n#### 12.5 复制对象\n\n复制要保证：\n\n1. 拷贝必须具有与原对象相同的原型；\n2. 拷贝必须具有与原对象相同的属性和特性；\n\n```javascript\nfunction copyObject(orig) {\n  // copy prototype\n  var copy = Object.create(Object.getPrototypeOf(orig));\n  // copy all properties\n  copyOwnPropertiesFrom(copy, orig);\n  return copy;\n}\n\nfunction copyOwnPropertiesFrom(target, source) {\n  Object.getOwnPropertyNames(source).forEach(function (propKey) {\n    var desc = Object.getOwnProperyDescriptor(source, propKey);\n    Object.defineProperty(target, propKey, desc);  // 使用获取的属性描述符创建target的自有属性\n  });\n  return target;\n}\n```\n\n#### 12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类\n\nSpeaking JavaScript内推荐的构造函数写法：\n\n> ```javascript\n> function Person(name) {\n>   this.name = name;\n> }\n> Person.prototype.describe = function () {\n>   return 'Person named ' + this.name;\n> };\n> ```\n\n经典面试内容：\nQ：new操作符都做了什么？\nA：\n\n1. 创建一个新对象；\n2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；\n3. 执行构造函数中的代码（为这个新对象添加属性）；\n4. 返回新对象。\n\n> 引用类型与基本包装类型（“装箱”）的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。\n\nSpeaking JavaScript内对这个过程的描述：\n\n> 首先设置行为：创建一个新对象，其原型为Person.prototype;\n> 然后设置数据：Person接受对象作为隐式参数this，并添加实例属性。\n\n代码模拟如下:\n\n```javascript\nfunction newOperator(Constr,args) {\n  var thisValue = Object.create(Constr.prototype);\n  var result = Constr.apply(thisValue, args);\n  if(typeof result === 'object' && result !== null) {\n  \treturn result;\n  }\n  return thisValue;\n}\n```\n\n每个函数包含一个实例原型对象，它的constructor属性指回函数。\n\n### 12.7 泛型方法：借用原型方法\n\n```javascript\nWine.prototyte.incAge.call(john, 3) // 类似于这样的模式\n```\n\n对于泛型方法，最常用的是处理一些“Array like”的元素，借用数组方法进行处理。\n\n通过 `Array.isArray` 也可以作为数组的判断，能够区分Array-like。","slug":"fe/speaking-javascript-阅读笔记-三","published":1,"updated":"2020-08-01T18:21:52.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ibi003uj1wt5ufw4c84","content":"<p><em>本章开始写函数与对象，内容相对较多单起一章专门记录</em></p>\n<h3 id=\"10-函数\"><a href=\"#10-函数\" class=\"headerlink\" title=\"10. 函数\"></a>10. 函数</h3><p>JavaScript中的函数一共有三种形式：</p>\n<ul>\n<li>非方法的函数（“普通函数”）；</li>\n<li>构造器；</li>\n<li>方法；</li>\n</ul>\n<p>因此我们创建函数一共有三种：</p>\n<ul>\n<li>通过函数表达式；</li>\n<li>通过函数声明；</li>\n<li>通过Function()构造器（不推荐）；</li>\n</ul>\n<p>所有的函数都是对象、Function构造器的实例。</p>\n<p>具名函数表达式只能在函数表达式的内部被访问。</p>\n<p>在函数的内部，有两个特殊的对象，arguments和this。</p>\n<blockquote>\n<p>this引用的值是函数数据以执行的环境对象——或者也可以说是this值。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。</p>\n</blockquote>\n<blockquote>\n<p>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</p>\n</blockquote>\n<h4 id=\"10-1-控制函数调用，call-apply-和bind\"><a href=\"#10-1-控制函数调用，call-apply-和bind\" class=\"headerlink\" title=\"10.1. 控制函数调用，call(), apply()和bind()\"></a>10.1. 控制函数调用，<code>call()</code>, <code>apply()</code>和<code>bind()</code></h4><p><em>bind()方法非原生，本节末尾会给出使用apply实现bind。</em></p>\n<p>使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(thisValue, argArray)</span><br><span class=\"line\">func.call(thisValue, arg1, ..., argN)</span><br><span class=\"line\">func.bind(thisValue, arg1, ..., argN) <span class=\"comment\">// 创建一个新函数，会调用func，再绑定this到新的thisValue</span></span><br></pre></td></tr></table></figure>\n\n<p>一个非常有趣的陷阱：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>].map(<span class=\"built_in\">parseInt</span>) <span class=\"comment\">// [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为parseInt只接受一个参数，map的期望函数签名<code>function(element, index, array)</code>，而parseInt的签名则是<code>parseInt(string, radix?)</code>, 这会导致radix也被传入。</p>\n<h4 id=\"10-1-1-实现bind\"><a href=\"#10-1-1-实现bind\" class=\"headerlink\" title=\"10.1.1 实现bind\"></a>10.1.1 实现bind</h4><p><em>本节的实现来自JS高程</em></p>\n<ol>\n<li>apply</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(context, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>apply的柯里化版本</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> finalArgs = args.concat(innerArgs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(context, finalArgs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-变量：作用域、环境和闭包\"><a href=\"#11-变量：作用域、环境和闭包\" class=\"headerlink\" title=\"11. 变量：作用域、环境和闭包\"></a>11. 变量：作用域、环境和闭包</h3><blockquote>\n<p>全局执行环境是最外围的一个执行环境，每个函数都有自己的执行环境，eval也会创建一个独立的执行环境。</p>\n</blockquote>\n<h4 id=\"11-1-作用域\"><a href=\"#11-1-作用域\" class=\"headerlink\" title=\"11.1. 作用域\"></a>11.1. 作用域</h4><p>JavaScript的变量是函数级作用域的，<strong>只有函数可以产生新的作用域</strong>。</p>\n<p>JavaScript会提前所有的变量声明，它会把所有的声明移到直接作用域的最前面。</p>\n<h4 id=\"11-2-IIFE\"><a href=\"#11-2-IIFE\" class=\"headerlink\" title=\"11.2. IIFE\"></a>11.2. IIFE</h4><ul>\n<li>它是立即执行的；</li>\n<li>它必须是一个表达式；</li>\n<li>连续的两个IIFE之间需要分号，不然会导致解析错误。</li>\n</ul>\n<p>IIFE也可以前缀运算符，比如!, void都是可以的，避免了分号的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> File = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// open IIFE</span></span><br><span class=\"line\">\t<span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;(); <span class=\"comment\">// close IIFE</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-3-全局对象\"><a href=\"#11-3-全局对象\" class=\"headerlink\" title=\"11.3. 全局对象\"></a>11.3. 全局对象</h4><p>全局对象是有原型的。</p>\n<h4 id=\"11-4-环境\"><a href=\"#11-4-环境\" class=\"headerlink\" title=\"11.4. 环境\"></a>11.4. 环境</h4><p>无论一个函数被调用多少次，它总要访问它自己（最新）的本地变量和外部作用域的变量。当多次调用自己的时候，每次调用都会创建一个新的环境。</p>\n<p>通过闭包可以使得函数可以维持其创建时所在的作用域。但如果创建时受到了当前作用域变量的影响，会存在环境公用的影响。</p>\n<h4 id=\"11-5-垃圾收集\"><a href=\"#11-5-垃圾收集\" class=\"headerlink\" title=\"11.5. 垃圾收集\"></a>11.5. 垃圾收集</h4><p>两种垃圾收集机制，__标记清除__，__引用计数__，两种都有使用，标记清除更为常用，引用计数一般用于COM对象。</p>\n<h4 id=\"11-6-闭包\"><a href=\"#11-6-闭包\" class=\"headerlink\" title=\"11.6. 闭包\"></a>11.6. 闭包</h4><blockquote>\n<p><strong>闭包</strong> 是指有权访问另一个函数作用域中的变量的函数。</p>\n</blockquote>\n<p>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>\n<p>闭包只能取得包含函数中任何变量的最后一个值。</p>\n<h4 id=\"11-7-闭包中的this\"><a href=\"#11-7-闭包中的this\" class=\"headerlink\" title=\"11.7. 闭包中的this\"></a>11.7. 闭包中的this</h4><p>在闭包中使用this对象会导致一些问题，因为this对象是在运行时基于函数的执行环境绑定的。</p>\n<blockquote>\n<p>如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。</p>\n</blockquote>\n<h3 id=\"12-对象与继承\"><a href=\"#12-对象与继承\" class=\"headerlink\" title=\"12. 对象与继承\"></a>12. 对象与继承</h3><p>JavaScript中的面向对象编程（OOP）分为以下几层：</p>\n<ul>\n<li>第一层，单一对象的面向对象；</li>\n<li>第二层，对象间的原型链；</li>\n<li>第三层，作为实例工厂的构造函数，类似于其他语言的类；</li>\n<li>第四层，子类，通过继承已有的构造函数，创建新的构造函数。</li>\n</ul>\n<h4 id=\"12-1-第一层，单一对象的面向对象\"><a href=\"#12-1-第一层，单一对象的面向对象\" class=\"headerlink\" title=\"12.1. 第一层，单一对象的面向对象\"></a>12.1. 第一层，单一对象的面向对象</h4><h5 id=\"12-1-1-属性\"><a href=\"#12-1-1-属性\" class=\"headerlink\" title=\"12.1.1 属性\"></a>12.1.1 属性</h5><p>属性分为三种：</p>\n<ol>\n<li>属性</li>\n<li>访问器</li>\n<li>内置属性（规范将内置属性的键置于方括号中，例如<code>[[Prototype]]</code>）</li>\n</ol>\n<p>delete只影响一个对象的直接“自有”的，非继承的属性，delete成功则返回true，如果是自有属性但不能删除则返回false。</p>\n<h5 id=\"12-1-2-对象字面量\"><a href=\"#12-1-2-对象字面量\" class=\"headerlink\" title=\"12.1.2 对象字面量\"></a>12.1.2 对象字面量</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jane = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'jane'</span>,</span><br><span class=\"line\">  describe: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Person named '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-2-第二层，对象间的关系——原型链\"><a href=\"#12-2-第二层，对象间的关系——原型链\" class=\"headerlink\" title=\"12.2. 第二层，对象间的关系——原型链\"></a>12.2. 第二层，对象间的关系——原型链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proto = &#123;</span><br><span class=\"line\">  describe: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'name: '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  [[Prototype]]: proto, <span class=\"comment\">// 实际不可访问</span></span><br><span class=\"line\">  name: <span class=\"string\">'obj'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对象obj从proto继承了describe属性。</p>\n<p>当通过obj访问属性时，JS首先从本对象中查找，接着是它的原型，以及它原型的原型。</p>\n<p>在ES5后，我们可以通过<code>Object.create(proto, propDescObj?)</code>完成使用给定prototype创建新对象。</p>\n<p>检测时，可以使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(obj); <span class=\"comment\">// 会检索整个链上</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-2-1-特殊属性proto\"><a href=\"#12-2-1-特殊属性proto\" class=\"headerlink\" title=\"12.2.1 特殊属性proto\"></a>12.2.1 特殊属性<strong>proto</strong></h4><p>某些JavaScript引擎有特殊属性可以获取和设置对象的原型：<code>__proto__</code>。这样可以直接访问<code>[[Prototype]]</code>。其在ES6内将会作为标准。</p>\n<p>方法区分：</p>\n<ul>\n<li><code>Object.getOwnPropertyNames(obj)</code> 返回obj的所有 <strong>自有</strong> 的属性键。</li>\n<li><code>Object.keys(obj)</code> 返回obj的所有 <strong>可枚举</strong> 的属性键。</li>\n</ul>\n<h4 id=\"12-3-访问器\"><a href=\"#12-3-访问器\" class=\"headerlink\" title=\"12.3 访问器\"></a>12.3 访问器</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> foo() &#123; <span class=\"comment\">// 取值调用，getter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> foo(value) &#123; <span class=\"comment\">// 赋值调用，setter</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter: '</span>+value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-4-属性特性和属性描述符\"><a href=\"#12-4-属性特性和属性描述符\" class=\"headerlink\" title=\"12.4 属性特性和属性描述符\"></a>12.4 属性特性和属性描述符</h4><ul>\n<li>Value</li>\n<li>Writable</li>\n<li>Get</li>\n<li>Set</li>\n<li>Enumerable</li>\n<li>Configurable</li>\n</ul>\n<h4 id=\"12-5-复制对象\"><a href=\"#12-5-复制对象\" class=\"headerlink\" title=\"12.5 复制对象\"></a>12.5 复制对象</h4><p>复制要保证：</p>\n<ol>\n<li>拷贝必须具有与原对象相同的原型；</li>\n<li>拷贝必须具有与原对象相同的属性和特性；</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObject</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// copy prototype</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(orig));</span><br><span class=\"line\">  <span class=\"comment\">// copy all properties</span></span><br><span class=\"line\">  copyOwnPropertiesFrom(copy, orig);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyOwnPropertiesFrom</span>(<span class=\"params\">target, source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.getOwnPropertyNames(source).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">propKey</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnProperyDescriptor(source, propKey);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(target, propKey, desc);  <span class=\"comment\">// 使用获取的属性描述符创建target的自有属性</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-6-第三层，作为实例工厂的构造函数，类似于其他语言的类\"><a href=\"#12-6-第三层，作为实例工厂的构造函数，类似于其他语言的类\" class=\"headerlink\" title=\"12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类\"></a>12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类</h4><p>Speaking JavaScript内推荐的构造函数写法：</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.describe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Person named '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>经典面试内容：<br>Q：new操作符都做了什么？<br>A：</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）；</li>\n<li>返回新对象。</li>\n</ol>\n<blockquote>\n<p>引用类型与基本包装类型（“装箱”）的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>\n</blockquote>\n<p>Speaking JavaScript内对这个过程的描述：</p>\n<blockquote>\n<p>首先设置行为：创建一个新对象，其原型为Person.prototype;<br>然后设置数据：Person接受对象作为隐式参数this，并添加实例属性。</p>\n</blockquote>\n<p>代码模拟如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newOperator</span>(<span class=\"params\">Constr,args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> thisValue = <span class=\"built_in\">Object</span>.create(Constr.prototype);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = Constr.apply(thisValue, args);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> result === <span class=\"string\">'object'</span> &amp;&amp; result !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> thisValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个函数包含一个实例原型对象，它的constructor属性指回函数。</p>\n<h3 id=\"12-7-泛型方法：借用原型方法\"><a href=\"#12-7-泛型方法：借用原型方法\" class=\"headerlink\" title=\"12.7 泛型方法：借用原型方法\"></a>12.7 泛型方法：借用原型方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wine.prototyte.incAge.call(john, <span class=\"number\">3</span>) <span class=\"comment\">// 类似于这样的模式</span></span><br></pre></td></tr></table></figure>\n\n<p>对于泛型方法，最常用的是处理一些“Array like”的元素，借用数组方法进行处理。</p>\n<p>通过 <code>Array.isArray</code> 也可以作为数组的判断，能够区分Array-like。</p>\n","site":{"data":{}},"more":"<p><em>本章开始写函数与对象，内容相对较多单起一章专门记录</em></p>\n<h3 id=\"10-函数\"><a href=\"#10-函数\" class=\"headerlink\" title=\"10. 函数\"></a>10. 函数</h3><p>JavaScript中的函数一共有三种形式：</p>\n<ul>\n<li>非方法的函数（“普通函数”）；</li>\n<li>构造器；</li>\n<li>方法；</li>\n</ul>\n<p>因此我们创建函数一共有三种：</p>\n<ul>\n<li>通过函数表达式；</li>\n<li>通过函数声明；</li>\n<li>通过Function()构造器（不推荐）；</li>\n</ul>\n<p>所有的函数都是对象、Function构造器的实例。</p>\n<p>具名函数表达式只能在函数表达式的内部被访问。</p>\n<p>在函数的内部，有两个特殊的对象，arguments和this。</p>\n<blockquote>\n<p>this引用的值是函数数据以执行的环境对象——或者也可以说是this值。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。</p>\n</blockquote>\n<blockquote>\n<p>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</p>\n</blockquote>\n<h4 id=\"10-1-控制函数调用，call-apply-和bind\"><a href=\"#10-1-控制函数调用，call-apply-和bind\" class=\"headerlink\" title=\"10.1. 控制函数调用，call(), apply()和bind()\"></a>10.1. 控制函数调用，<code>call()</code>, <code>apply()</code>和<code>bind()</code></h4><p><em>bind()方法非原生，本节末尾会给出使用apply实现bind。</em></p>\n<p>使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(thisValue, argArray)</span><br><span class=\"line\">func.call(thisValue, arg1, ..., argN)</span><br><span class=\"line\">func.bind(thisValue, arg1, ..., argN) <span class=\"comment\">// 创建一个新函数，会调用func，再绑定this到新的thisValue</span></span><br></pre></td></tr></table></figure>\n\n<p>一个非常有趣的陷阱：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'1'</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'3'</span>].map(<span class=\"built_in\">parseInt</span>) <span class=\"comment\">// [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为parseInt只接受一个参数，map的期望函数签名<code>function(element, index, array)</code>，而parseInt的签名则是<code>parseInt(string, radix?)</code>, 这会导致radix也被传入。</p>\n<h4 id=\"10-1-1-实现bind\"><a href=\"#10-1-1-实现bind\" class=\"headerlink\" title=\"10.1.1 实现bind\"></a>10.1.1 实现bind</h4><p><em>本节的实现来自JS高程</em></p>\n<ol>\n<li>apply</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(context, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>apply的柯里化版本</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bind</span>(<span class=\"params\">fn, context</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> innerArgs = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> finalArgs = args.concat(innerArgs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fn.apply(context, finalArgs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-变量：作用域、环境和闭包\"><a href=\"#11-变量：作用域、环境和闭包\" class=\"headerlink\" title=\"11. 变量：作用域、环境和闭包\"></a>11. 变量：作用域、环境和闭包</h3><blockquote>\n<p>全局执行环境是最外围的一个执行环境，每个函数都有自己的执行环境，eval也会创建一个独立的执行环境。</p>\n</blockquote>\n<h4 id=\"11-1-作用域\"><a href=\"#11-1-作用域\" class=\"headerlink\" title=\"11.1. 作用域\"></a>11.1. 作用域</h4><p>JavaScript的变量是函数级作用域的，<strong>只有函数可以产生新的作用域</strong>。</p>\n<p>JavaScript会提前所有的变量声明，它会把所有的声明移到直接作用域的最前面。</p>\n<h4 id=\"11-2-IIFE\"><a href=\"#11-2-IIFE\" class=\"headerlink\" title=\"11.2. IIFE\"></a>11.2. IIFE</h4><ul>\n<li>它是立即执行的；</li>\n<li>它必须是一个表达式；</li>\n<li>连续的两个IIFE之间需要分号，不然会导致解析错误。</li>\n</ul>\n<p>IIFE也可以前缀运算符，比如!, void都是可以的，避免了分号的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> File = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// open IIFE</span></span><br><span class=\"line\">\t<span class=\"comment\">// do something...</span></span><br><span class=\"line\">&#125;(); <span class=\"comment\">// close IIFE</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-3-全局对象\"><a href=\"#11-3-全局对象\" class=\"headerlink\" title=\"11.3. 全局对象\"></a>11.3. 全局对象</h4><p>全局对象是有原型的。</p>\n<h4 id=\"11-4-环境\"><a href=\"#11-4-环境\" class=\"headerlink\" title=\"11.4. 环境\"></a>11.4. 环境</h4><p>无论一个函数被调用多少次，它总要访问它自己（最新）的本地变量和外部作用域的变量。当多次调用自己的时候，每次调用都会创建一个新的环境。</p>\n<p>通过闭包可以使得函数可以维持其创建时所在的作用域。但如果创建时受到了当前作用域变量的影响，会存在环境公用的影响。</p>\n<h4 id=\"11-5-垃圾收集\"><a href=\"#11-5-垃圾收集\" class=\"headerlink\" title=\"11.5. 垃圾收集\"></a>11.5. 垃圾收集</h4><p>两种垃圾收集机制，__标记清除__，__引用计数__，两种都有使用，标记清除更为常用，引用计数一般用于COM对象。</p>\n<h4 id=\"11-6-闭包\"><a href=\"#11-6-闭包\" class=\"headerlink\" title=\"11.6. 闭包\"></a>11.6. 闭包</h4><blockquote>\n<p><strong>闭包</strong> 是指有权访问另一个函数作用域中的变量的函数。</p>\n</blockquote>\n<p>创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p>\n<p>闭包只能取得包含函数中任何变量的最后一个值。</p>\n<h4 id=\"11-7-闭包中的this\"><a href=\"#11-7-闭包中的this\" class=\"headerlink\" title=\"11.7. 闭包中的this\"></a>11.7. 闭包中的this</h4><p>在闭包中使用this对象会导致一些问题，因为this对象是在运行时基于函数的执行环境绑定的。</p>\n<blockquote>\n<p>如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。</p>\n</blockquote>\n<h3 id=\"12-对象与继承\"><a href=\"#12-对象与继承\" class=\"headerlink\" title=\"12. 对象与继承\"></a>12. 对象与继承</h3><p>JavaScript中的面向对象编程（OOP）分为以下几层：</p>\n<ul>\n<li>第一层，单一对象的面向对象；</li>\n<li>第二层，对象间的原型链；</li>\n<li>第三层，作为实例工厂的构造函数，类似于其他语言的类；</li>\n<li>第四层，子类，通过继承已有的构造函数，创建新的构造函数。</li>\n</ul>\n<h4 id=\"12-1-第一层，单一对象的面向对象\"><a href=\"#12-1-第一层，单一对象的面向对象\" class=\"headerlink\" title=\"12.1. 第一层，单一对象的面向对象\"></a>12.1. 第一层，单一对象的面向对象</h4><h5 id=\"12-1-1-属性\"><a href=\"#12-1-1-属性\" class=\"headerlink\" title=\"12.1.1 属性\"></a>12.1.1 属性</h5><p>属性分为三种：</p>\n<ol>\n<li>属性</li>\n<li>访问器</li>\n<li>内置属性（规范将内置属性的键置于方括号中，例如<code>[[Prototype]]</code>）</li>\n</ol>\n<p>delete只影响一个对象的直接“自有”的，非继承的属性，delete成功则返回true，如果是自有属性但不能删除则返回false。</p>\n<h5 id=\"12-1-2-对象字面量\"><a href=\"#12-1-2-对象字面量\" class=\"headerlink\" title=\"12.1.2 对象字面量\"></a>12.1.2 对象字面量</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jane = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'jane'</span>,</span><br><span class=\"line\">  describe: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Person named '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-2-第二层，对象间的关系——原型链\"><a href=\"#12-2-第二层，对象间的关系——原型链\" class=\"headerlink\" title=\"12.2. 第二层，对象间的关系——原型链\"></a>12.2. 第二层，对象间的关系——原型链</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proto = &#123;</span><br><span class=\"line\">  describe: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'name: '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  [[Prototype]]: proto, <span class=\"comment\">// 实际不可访问</span></span><br><span class=\"line\">  name: <span class=\"string\">'obj'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对象obj从proto继承了describe属性。</p>\n<p>当通过obj访问属性时，JS首先从本对象中查找，接着是它的原型，以及它原型的原型。</p>\n<p>在ES5后，我们可以通过<code>Object.create(proto, propDescObj?)</code>完成使用给定prototype创建新对象。</p>\n<p>检测时，可以使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.isPrototypeOf(obj); <span class=\"comment\">// 会检索整个链上</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-2-1-特殊属性proto\"><a href=\"#12-2-1-特殊属性proto\" class=\"headerlink\" title=\"12.2.1 特殊属性proto\"></a>12.2.1 特殊属性<strong>proto</strong></h4><p>某些JavaScript引擎有特殊属性可以获取和设置对象的原型：<code>__proto__</code>。这样可以直接访问<code>[[Prototype]]</code>。其在ES6内将会作为标准。</p>\n<p>方法区分：</p>\n<ul>\n<li><code>Object.getOwnPropertyNames(obj)</code> 返回obj的所有 <strong>自有</strong> 的属性键。</li>\n<li><code>Object.keys(obj)</code> 返回obj的所有 <strong>可枚举</strong> 的属性键。</li>\n</ul>\n<h4 id=\"12-3-访问器\"><a href=\"#12-3-访问器\" class=\"headerlink\" title=\"12.3 访问器\"></a>12.3 访问器</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span> foo() &#123; <span class=\"comment\">// 取值调用，getter</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> foo(value) &#123; <span class=\"comment\">// 赋值调用，setter</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter: '</span>+value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-4-属性特性和属性描述符\"><a href=\"#12-4-属性特性和属性描述符\" class=\"headerlink\" title=\"12.4 属性特性和属性描述符\"></a>12.4 属性特性和属性描述符</h4><ul>\n<li>Value</li>\n<li>Writable</li>\n<li>Get</li>\n<li>Set</li>\n<li>Enumerable</li>\n<li>Configurable</li>\n</ul>\n<h4 id=\"12-5-复制对象\"><a href=\"#12-5-复制对象\" class=\"headerlink\" title=\"12.5 复制对象\"></a>12.5 复制对象</h4><p>复制要保证：</p>\n<ol>\n<li>拷贝必须具有与原对象相同的原型；</li>\n<li>拷贝必须具有与原对象相同的属性和特性；</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyObject</span>(<span class=\"params\">orig</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// copy prototype</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> copy = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(orig));</span><br><span class=\"line\">  <span class=\"comment\">// copy all properties</span></span><br><span class=\"line\">  copyOwnPropertiesFrom(copy, orig);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> copy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">copyOwnPropertiesFrom</span>(<span class=\"params\">target, source</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.getOwnPropertyNames(source).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">propKey</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> desc = <span class=\"built_in\">Object</span>.getOwnProperyDescriptor(source, propKey);</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(target, propKey, desc);  <span class=\"comment\">// 使用获取的属性描述符创建target的自有属性</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-6-第三层，作为实例工厂的构造函数，类似于其他语言的类\"><a href=\"#12-6-第三层，作为实例工厂的构造函数，类似于其他语言的类\" class=\"headerlink\" title=\"12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类\"></a>12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类</h4><p>Speaking JavaScript内推荐的构造函数写法：</p>\n<blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.describe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'Person named '</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>经典面试内容：<br>Q：new操作符都做了什么？<br>A：</p>\n<ol>\n<li>创建一个新对象；</li>\n<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li>\n<li>执行构造函数中的代码（为这个新对象添加属性）；</li>\n<li>返回新对象。</li>\n</ol>\n<blockquote>\n<p>引用类型与基本包装类型（“装箱”）的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。</p>\n</blockquote>\n<p>Speaking JavaScript内对这个过程的描述：</p>\n<blockquote>\n<p>首先设置行为：创建一个新对象，其原型为Person.prototype;<br>然后设置数据：Person接受对象作为隐式参数this，并添加实例属性。</p>\n</blockquote>\n<p>代码模拟如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newOperator</span>(<span class=\"params\">Constr,args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> thisValue = <span class=\"built_in\">Object</span>.create(Constr.prototype);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = Constr.apply(thisValue, args);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> result === <span class=\"string\">'object'</span> &amp;&amp; result !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> thisValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个函数包含一个实例原型对象，它的constructor属性指回函数。</p>\n<h3 id=\"12-7-泛型方法：借用原型方法\"><a href=\"#12-7-泛型方法：借用原型方法\" class=\"headerlink\" title=\"12.7 泛型方法：借用原型方法\"></a>12.7 泛型方法：借用原型方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wine.prototyte.incAge.call(john, <span class=\"number\">3</span>) <span class=\"comment\">// 类似于这样的模式</span></span><br></pre></td></tr></table></figure>\n\n<p>对于泛型方法，最常用的是处理一些“Array like”的元素，借用数组方法进行处理。</p>\n<p>通过 <code>Array.isArray</code> 也可以作为数组的判断，能够区分Array-like。</p>\n"},{"date":"2020-08-01T09:49:59.000Z","title":"使用forestry.io管理你的博客","excerpt":"[forestry.io](https://forestry.io/ \"Forestry.io\") 我使用了约有一年的时间，整体体验下来非常不错，对于书写博客这种轻量化的需求基本可以全面满足，利用模板（Front matter）和多种媒体库接入方式，把更多的精力专注于写作上。","thumbnail":"","_content":"> 如果英文能力还可以的同学可以直接移步 [官网文档](https://forestry.io/docs/welcome/)\n\n## 原来的写博客方式\n\n现在比较多的写博客模式是利用Github仓库，连接Github Page或者一些第三方服务如Netlify, Vercel(Now.sh)来进行部署，写好文章提交后的流程已经基本自动，而且大部分平台的服务都是免费的。\n\n> 博主之前使用Vercel部署时，需要注意免费计划 **每个小时不能超过30次构建部署** 。\n\n然而写博客主要是内容，那么书写平台就是一大问题，我们虽然可以用本地IDE（亦或是Code Server/VSCode Remote）这一类工具进行编写，但是未免仍不够轻量，如果是iPad这一类移动设备更是不方便，因而，我发现了这个基于Git的第三方编辑平台—— [Forestry.io](https://forestry.io)\n\n![Forestry.io CMS](https://res.cloudinary.com/forestry-io/image/fetch/c_limit,dpr_auto,f_auto,q_80,w_1028/https://forestry.io/uploads/2018/12/draft-post-editor.png)\n\n## 快速上手\n\nForestry.io支持四种Git来源：Github, Gitlab, Bitbucket, Azure Devops。\n\n一般作为博客我们使用Github，继续后会进入到Github的授权界面，授权即可。\n\n> 默认的授权是读取Public库，如果你需要也可以在CMS左侧的Settings中选择授权Private仓库。\n\n> 如果是Bitbucket和Azure Devops，可能需要更复杂的设置，我没有使用过，可以参考官方文档。\n\n授权完成后，可以进入Dashboard，选择Add Site。\n\n本篇以一个GatsbyJS的模板项目为例子，Hexo，Hugo，Jekyll官网上都有相关的例子可以参考。如果你是Hexo，请选择Other类别。然后点击Next。\n\n![选择静态生成框架](https://cdn.sparkling.land/public/blog/images/step1.png)\n\n进入到“Select your git provider”界面，和原来一样，选择你的Git来源，这里我选择Github。\n\n第三步就来到了仓库选择，直接选择你想要操作的仓库与分支，如果你不想让Forestry提交commit到master，请在此选择一个编辑分支。\n\n![选择仓库与分支](https://cdn.sparkling.land/public/blog/images/step3.png)\n\n导入完成，进入到CMS的主界面。\n\n![CMS主界面](https://cdn.sparkling.land/public/blog/images/step4.png)\n\n## 简单设置\n\n如同上面的CMS显示，我们只要将剩下三步配置完成即可。\n\n### Set up sidebar\n\n侧边栏是一些快捷入口，这里你可以配置三类：\n\n![侧边栏配置](https://cdn.sparkling.land/public/blog/images/setting1.png)\n\n* 目录: 顾名思义，目录可以用作分类等场合，对应的，所有在分类下创建的文档都会进入到对应的目录下；\n* 文档: 直接编辑某一篇文档，适合作为介绍页或者文档页的快捷入口；\n* Heading: Heading是一个 **没有内容** 的侧边栏选项，适合作为分割线等等，来定制你的侧边栏；\n\n这里添加一个Section，可以看到可以配置很多项，一般默认即可，如果不希望分类下额外存在目录，可以将创建内容改为Documents\n\n![创建侧边栏](https://cdn.sparkling.land/public/blog/images/setting2.png)\n\n这里我们先不配置默认模板，先保存。\n\n### Import Media\n\n重头戏来了，之所以选择一个CMS，最重要的就是我们很多时候有上传图片的需求，但是无论是Git手动提交还是第三方工具上传，都费时费力，还需要手工粘贴图片的绝对地址。\n\n而有了CMS，这一切都简化了。\n\n![](https://cdn.sparkling.land/public/blog/images/setting3.png \"配置媒体文件\")\n\n如图所示，可以支持四种图片管理方式，最普通的Git提交，第三方支持了Cloudinary和Amazon S3以及Netlify Large Media。\n\n> Cloudinary可以免费试用，它是一个积分制的服务，如果你的博客流量较小，那么它的免费量其实足以；\n>\n> Amazon S3这里特别提一下，目前有很多VPS厂家会提供Object Storage，他们会提供类似S3的管理方式，但是咨询了Forestry.io的技术支持后，明确表示了 **目前支持的S3仅有Amazon，即你暂时无法通过配置其他域名来实现其他S3的配置** 。\n\n如果配置顺利，在“可视化编辑器”内，你就可以点击这里实现上传直接插入文档中：\n\n![](https://cdn.sparkling.land/public/blog/images/setting4.png \"添加图片\")\n\n点击open后，会跳转到你的媒体库，上传即自动插入到文章中。\n\n## 配置预览\n\nForestry.io支持在发布前进行预览，需要配置预览的相关命令，环境以Node.js为主，也可以进行自定义，本章内容建议详细参阅官方文档的 [配置页面](https://forestry.io/docs/previews/instant-previews/)\n\n## 设置文章模板\n\n这一章也是非常重要的，我们在前面的Section里可以设置默认模板，这就是为了方便统一类别下的文章格式一致(Front matter)，点击左侧的Front matter进入配置界面。\n\n点击添加模板后，可以全新创建，也可以从已有的文章自动分析。\n\n> 我自己使用时发现，文本编辑的识别率较好，如果是类似标签选择的则会识别错误，建议先导入，然后添加一篇新文章进行测试。\n\n一般对于Markdown的博客写作，我们选择左侧的“Fields and big content area”。\n\n![](https://cdn.sparkling.land/public/blog/images/setting5.png)\n\nForestry.io提供了一些Field选项，对于博客写作，它们可以与你的Front matter一一对应，通过交互实现配置Front matter，进而与你的博客主题（如Banner图，文章简介等等）比较好的对应，具体使用可以自己体验一下。","source":"_posts/other/forestry.io.md","raw":"---\ncategories: Other\ndate: 2020-08-02T01:49:59+08:00\ntags:\n- 工具\ntitle: 使用forestry.io管理你的博客\nexcerpt: '[forestry.io](https://forestry.io/ \"Forestry.io\") 我使用了约有一年的时间，整体体验下来非常不错，对于书写博客这种轻量化的需求基本可以全面满足，利用模板（Front\n  matter）和多种媒体库接入方式，把更多的精力专注于写作上。'\nthumbnail: ''\n\n---\n> 如果英文能力还可以的同学可以直接移步 [官网文档](https://forestry.io/docs/welcome/)\n\n## 原来的写博客方式\n\n现在比较多的写博客模式是利用Github仓库，连接Github Page或者一些第三方服务如Netlify, Vercel(Now.sh)来进行部署，写好文章提交后的流程已经基本自动，而且大部分平台的服务都是免费的。\n\n> 博主之前使用Vercel部署时，需要注意免费计划 **每个小时不能超过30次构建部署** 。\n\n然而写博客主要是内容，那么书写平台就是一大问题，我们虽然可以用本地IDE（亦或是Code Server/VSCode Remote）这一类工具进行编写，但是未免仍不够轻量，如果是iPad这一类移动设备更是不方便，因而，我发现了这个基于Git的第三方编辑平台—— [Forestry.io](https://forestry.io)\n\n![Forestry.io CMS](https://res.cloudinary.com/forestry-io/image/fetch/c_limit,dpr_auto,f_auto,q_80,w_1028/https://forestry.io/uploads/2018/12/draft-post-editor.png)\n\n## 快速上手\n\nForestry.io支持四种Git来源：Github, Gitlab, Bitbucket, Azure Devops。\n\n一般作为博客我们使用Github，继续后会进入到Github的授权界面，授权即可。\n\n> 默认的授权是读取Public库，如果你需要也可以在CMS左侧的Settings中选择授权Private仓库。\n\n> 如果是Bitbucket和Azure Devops，可能需要更复杂的设置，我没有使用过，可以参考官方文档。\n\n授权完成后，可以进入Dashboard，选择Add Site。\n\n本篇以一个GatsbyJS的模板项目为例子，Hexo，Hugo，Jekyll官网上都有相关的例子可以参考。如果你是Hexo，请选择Other类别。然后点击Next。\n\n![选择静态生成框架](https://cdn.sparkling.land/public/blog/images/step1.png)\n\n进入到“Select your git provider”界面，和原来一样，选择你的Git来源，这里我选择Github。\n\n第三步就来到了仓库选择，直接选择你想要操作的仓库与分支，如果你不想让Forestry提交commit到master，请在此选择一个编辑分支。\n\n![选择仓库与分支](https://cdn.sparkling.land/public/blog/images/step3.png)\n\n导入完成，进入到CMS的主界面。\n\n![CMS主界面](https://cdn.sparkling.land/public/blog/images/step4.png)\n\n## 简单设置\n\n如同上面的CMS显示，我们只要将剩下三步配置完成即可。\n\n### Set up sidebar\n\n侧边栏是一些快捷入口，这里你可以配置三类：\n\n![侧边栏配置](https://cdn.sparkling.land/public/blog/images/setting1.png)\n\n* 目录: 顾名思义，目录可以用作分类等场合，对应的，所有在分类下创建的文档都会进入到对应的目录下；\n* 文档: 直接编辑某一篇文档，适合作为介绍页或者文档页的快捷入口；\n* Heading: Heading是一个 **没有内容** 的侧边栏选项，适合作为分割线等等，来定制你的侧边栏；\n\n这里添加一个Section，可以看到可以配置很多项，一般默认即可，如果不希望分类下额外存在目录，可以将创建内容改为Documents\n\n![创建侧边栏](https://cdn.sparkling.land/public/blog/images/setting2.png)\n\n这里我们先不配置默认模板，先保存。\n\n### Import Media\n\n重头戏来了，之所以选择一个CMS，最重要的就是我们很多时候有上传图片的需求，但是无论是Git手动提交还是第三方工具上传，都费时费力，还需要手工粘贴图片的绝对地址。\n\n而有了CMS，这一切都简化了。\n\n![](https://cdn.sparkling.land/public/blog/images/setting3.png \"配置媒体文件\")\n\n如图所示，可以支持四种图片管理方式，最普通的Git提交，第三方支持了Cloudinary和Amazon S3以及Netlify Large Media。\n\n> Cloudinary可以免费试用，它是一个积分制的服务，如果你的博客流量较小，那么它的免费量其实足以；\n>\n> Amazon S3这里特别提一下，目前有很多VPS厂家会提供Object Storage，他们会提供类似S3的管理方式，但是咨询了Forestry.io的技术支持后，明确表示了 **目前支持的S3仅有Amazon，即你暂时无法通过配置其他域名来实现其他S3的配置** 。\n\n如果配置顺利，在“可视化编辑器”内，你就可以点击这里实现上传直接插入文档中：\n\n![](https://cdn.sparkling.land/public/blog/images/setting4.png \"添加图片\")\n\n点击open后，会跳转到你的媒体库，上传即自动插入到文章中。\n\n## 配置预览\n\nForestry.io支持在发布前进行预览，需要配置预览的相关命令，环境以Node.js为主，也可以进行自定义，本章内容建议详细参阅官方文档的 [配置页面](https://forestry.io/docs/previews/instant-previews/)\n\n## 设置文章模板\n\n这一章也是非常重要的，我们在前面的Section里可以设置默认模板，这就是为了方便统一类别下的文章格式一致(Front matter)，点击左侧的Front matter进入配置界面。\n\n点击添加模板后，可以全新创建，也可以从已有的文章自动分析。\n\n> 我自己使用时发现，文本编辑的识别率较好，如果是类似标签选择的则会识别错误，建议先导入，然后添加一篇新文章进行测试。\n\n一般对于Markdown的博客写作，我们选择左侧的“Fields and big content area”。\n\n![](https://cdn.sparkling.land/public/blog/images/setting5.png)\n\nForestry.io提供了一些Field选项，对于博客写作，它们可以与你的Front matter一一对应，通过交互实现配置Front matter，进而与你的博客主题（如Banner图，文章简介等等）比较好的对应，具体使用可以自己体验一下。","slug":"other/forestry.io","published":1,"updated":"2020-08-02T09:35:55.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5ica005cj1wtcfyj6gjr","content":"<blockquote>\n<p>如果英文能力还可以的同学可以直接移步 <a href=\"https://forestry.io/docs/welcome/\">官网文档</a></p>\n</blockquote>\n<h2 id=\"原来的写博客方式\"><a href=\"#原来的写博客方式\" class=\"headerlink\" title=\"原来的写博客方式\"></a>原来的写博客方式</h2><p>现在比较多的写博客模式是利用Github仓库，连接Github Page或者一些第三方服务如Netlify, Vercel(Now.sh)来进行部署，写好文章提交后的流程已经基本自动，而且大部分平台的服务都是免费的。</p>\n<blockquote>\n<p>博主之前使用Vercel部署时，需要注意免费计划 <strong>每个小时不能超过30次构建部署</strong> 。</p>\n</blockquote>\n<p>然而写博客主要是内容，那么书写平台就是一大问题，我们虽然可以用本地IDE（亦或是Code Server/VSCode Remote）这一类工具进行编写，但是未免仍不够轻量，如果是iPad这一类移动设备更是不方便，因而，我发现了这个基于Git的第三方编辑平台—— <a href=\"https://forestry.io/\">Forestry.io</a></p>\n<p><img src=\"https://res.cloudinary.com/forestry-io/image/fetch/c_limit,dpr_auto,f_auto,q_80,w_1028/https://forestry.io/uploads/2018/12/draft-post-editor.png\" alt=\"Forestry.io CMS\"></p>\n<h2 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h2><p>Forestry.io支持四种Git来源：Github, Gitlab, Bitbucket, Azure Devops。</p>\n<p>一般作为博客我们使用Github，继续后会进入到Github的授权界面，授权即可。</p>\n<blockquote>\n<p>默认的授权是读取Public库，如果你需要也可以在CMS左侧的Settings中选择授权Private仓库。</p>\n</blockquote>\n<blockquote>\n<p>如果是Bitbucket和Azure Devops，可能需要更复杂的设置，我没有使用过，可以参考官方文档。</p>\n</blockquote>\n<p>授权完成后，可以进入Dashboard，选择Add Site。</p>\n<p>本篇以一个GatsbyJS的模板项目为例子，Hexo，Hugo，Jekyll官网上都有相关的例子可以参考。如果你是Hexo，请选择Other类别。然后点击Next。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/step1.png\" alt=\"选择静态生成框架\"></p>\n<p>进入到“Select your git provider”界面，和原来一样，选择你的Git来源，这里我选择Github。</p>\n<p>第三步就来到了仓库选择，直接选择你想要操作的仓库与分支，如果你不想让Forestry提交commit到master，请在此选择一个编辑分支。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/step3.png\" alt=\"选择仓库与分支\"></p>\n<p>导入完成，进入到CMS的主界面。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/step4.png\" alt=\"CMS主界面\"></p>\n<h2 id=\"简单设置\"><a href=\"#简单设置\" class=\"headerlink\" title=\"简单设置\"></a>简单设置</h2><p>如同上面的CMS显示，我们只要将剩下三步配置完成即可。</p>\n<h3 id=\"Set-up-sidebar\"><a href=\"#Set-up-sidebar\" class=\"headerlink\" title=\"Set up sidebar\"></a>Set up sidebar</h3><p>侧边栏是一些快捷入口，这里你可以配置三类：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting1.png\" alt=\"侧边栏配置\"></p>\n<ul>\n<li>目录: 顾名思义，目录可以用作分类等场合，对应的，所有在分类下创建的文档都会进入到对应的目录下；</li>\n<li>文档: 直接编辑某一篇文档，适合作为介绍页或者文档页的快捷入口；</li>\n<li>Heading: Heading是一个 <strong>没有内容</strong> 的侧边栏选项，适合作为分割线等等，来定制你的侧边栏；</li>\n</ul>\n<p>这里添加一个Section，可以看到可以配置很多项，一般默认即可，如果不希望分类下额外存在目录，可以将创建内容改为Documents</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting2.png\" alt=\"创建侧边栏\"></p>\n<p>这里我们先不配置默认模板，先保存。</p>\n<h3 id=\"Import-Media\"><a href=\"#Import-Media\" class=\"headerlink\" title=\"Import Media\"></a>Import Media</h3><p>重头戏来了，之所以选择一个CMS，最重要的就是我们很多时候有上传图片的需求，但是无论是Git手动提交还是第三方工具上传，都费时费力，还需要手工粘贴图片的绝对地址。</p>\n<p>而有了CMS，这一切都简化了。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting3.png\" title=\"配置媒体文件\"></p>\n<p>如图所示，可以支持四种图片管理方式，最普通的Git提交，第三方支持了Cloudinary和Amazon S3以及Netlify Large Media。</p>\n<blockquote>\n<p>Cloudinary可以免费试用，它是一个积分制的服务，如果你的博客流量较小，那么它的免费量其实足以；</p>\n<p>Amazon S3这里特别提一下，目前有很多VPS厂家会提供Object Storage，他们会提供类似S3的管理方式，但是咨询了Forestry.io的技术支持后，明确表示了 <strong>目前支持的S3仅有Amazon，即你暂时无法通过配置其他域名来实现其他S3的配置</strong> 。</p>\n</blockquote>\n<p>如果配置顺利，在“可视化编辑器”内，你就可以点击这里实现上传直接插入文档中：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting4.png\" title=\"添加图片\"></p>\n<p>点击open后，会跳转到你的媒体库，上传即自动插入到文章中。</p>\n<h2 id=\"配置预览\"><a href=\"#配置预览\" class=\"headerlink\" title=\"配置预览\"></a>配置预览</h2><p>Forestry.io支持在发布前进行预览，需要配置预览的相关命令，环境以Node.js为主，也可以进行自定义，本章内容建议详细参阅官方文档的 <a href=\"https://forestry.io/docs/previews/instant-previews/\">配置页面</a></p>\n<h2 id=\"设置文章模板\"><a href=\"#设置文章模板\" class=\"headerlink\" title=\"设置文章模板\"></a>设置文章模板</h2><p>这一章也是非常重要的，我们在前面的Section里可以设置默认模板，这就是为了方便统一类别下的文章格式一致(Front matter)，点击左侧的Front matter进入配置界面。</p>\n<p>点击添加模板后，可以全新创建，也可以从已有的文章自动分析。</p>\n<blockquote>\n<p>我自己使用时发现，文本编辑的识别率较好，如果是类似标签选择的则会识别错误，建议先导入，然后添加一篇新文章进行测试。</p>\n</blockquote>\n<p>一般对于Markdown的博客写作，我们选择左侧的“Fields and big content area”。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting5.png\"></p>\n<p>Forestry.io提供了一些Field选项，对于博客写作，它们可以与你的Front matter一一对应，通过交互实现配置Front matter，进而与你的博客主题（如Banner图，文章简介等等）比较好的对应，具体使用可以自己体验一下。</p>\n","site":{"data":{}},"more":"<blockquote>\n<p>如果英文能力还可以的同学可以直接移步 <a href=\"https://forestry.io/docs/welcome/\">官网文档</a></p>\n</blockquote>\n<h2 id=\"原来的写博客方式\"><a href=\"#原来的写博客方式\" class=\"headerlink\" title=\"原来的写博客方式\"></a>原来的写博客方式</h2><p>现在比较多的写博客模式是利用Github仓库，连接Github Page或者一些第三方服务如Netlify, Vercel(Now.sh)来进行部署，写好文章提交后的流程已经基本自动，而且大部分平台的服务都是免费的。</p>\n<blockquote>\n<p>博主之前使用Vercel部署时，需要注意免费计划 <strong>每个小时不能超过30次构建部署</strong> 。</p>\n</blockquote>\n<p>然而写博客主要是内容，那么书写平台就是一大问题，我们虽然可以用本地IDE（亦或是Code Server/VSCode Remote）这一类工具进行编写，但是未免仍不够轻量，如果是iPad这一类移动设备更是不方便，因而，我发现了这个基于Git的第三方编辑平台—— <a href=\"https://forestry.io/\">Forestry.io</a></p>\n<p><img src=\"https://res.cloudinary.com/forestry-io/image/fetch/c_limit,dpr_auto,f_auto,q_80,w_1028/https://forestry.io/uploads/2018/12/draft-post-editor.png\" alt=\"Forestry.io CMS\"></p>\n<h2 id=\"快速上手\"><a href=\"#快速上手\" class=\"headerlink\" title=\"快速上手\"></a>快速上手</h2><p>Forestry.io支持四种Git来源：Github, Gitlab, Bitbucket, Azure Devops。</p>\n<p>一般作为博客我们使用Github，继续后会进入到Github的授权界面，授权即可。</p>\n<blockquote>\n<p>默认的授权是读取Public库，如果你需要也可以在CMS左侧的Settings中选择授权Private仓库。</p>\n</blockquote>\n<blockquote>\n<p>如果是Bitbucket和Azure Devops，可能需要更复杂的设置，我没有使用过，可以参考官方文档。</p>\n</blockquote>\n<p>授权完成后，可以进入Dashboard，选择Add Site。</p>\n<p>本篇以一个GatsbyJS的模板项目为例子，Hexo，Hugo，Jekyll官网上都有相关的例子可以参考。如果你是Hexo，请选择Other类别。然后点击Next。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/step1.png\" alt=\"选择静态生成框架\"></p>\n<p>进入到“Select your git provider”界面，和原来一样，选择你的Git来源，这里我选择Github。</p>\n<p>第三步就来到了仓库选择，直接选择你想要操作的仓库与分支，如果你不想让Forestry提交commit到master，请在此选择一个编辑分支。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/step3.png\" alt=\"选择仓库与分支\"></p>\n<p>导入完成，进入到CMS的主界面。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/step4.png\" alt=\"CMS主界面\"></p>\n<h2 id=\"简单设置\"><a href=\"#简单设置\" class=\"headerlink\" title=\"简单设置\"></a>简单设置</h2><p>如同上面的CMS显示，我们只要将剩下三步配置完成即可。</p>\n<h3 id=\"Set-up-sidebar\"><a href=\"#Set-up-sidebar\" class=\"headerlink\" title=\"Set up sidebar\"></a>Set up sidebar</h3><p>侧边栏是一些快捷入口，这里你可以配置三类：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting1.png\" alt=\"侧边栏配置\"></p>\n<ul>\n<li>目录: 顾名思义，目录可以用作分类等场合，对应的，所有在分类下创建的文档都会进入到对应的目录下；</li>\n<li>文档: 直接编辑某一篇文档，适合作为介绍页或者文档页的快捷入口；</li>\n<li>Heading: Heading是一个 <strong>没有内容</strong> 的侧边栏选项，适合作为分割线等等，来定制你的侧边栏；</li>\n</ul>\n<p>这里添加一个Section，可以看到可以配置很多项，一般默认即可，如果不希望分类下额外存在目录，可以将创建内容改为Documents</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting2.png\" alt=\"创建侧边栏\"></p>\n<p>这里我们先不配置默认模板，先保存。</p>\n<h3 id=\"Import-Media\"><a href=\"#Import-Media\" class=\"headerlink\" title=\"Import Media\"></a>Import Media</h3><p>重头戏来了，之所以选择一个CMS，最重要的就是我们很多时候有上传图片的需求，但是无论是Git手动提交还是第三方工具上传，都费时费力，还需要手工粘贴图片的绝对地址。</p>\n<p>而有了CMS，这一切都简化了。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting3.png\" title=\"配置媒体文件\"></p>\n<p>如图所示，可以支持四种图片管理方式，最普通的Git提交，第三方支持了Cloudinary和Amazon S3以及Netlify Large Media。</p>\n<blockquote>\n<p>Cloudinary可以免费试用，它是一个积分制的服务，如果你的博客流量较小，那么它的免费量其实足以；</p>\n<p>Amazon S3这里特别提一下，目前有很多VPS厂家会提供Object Storage，他们会提供类似S3的管理方式，但是咨询了Forestry.io的技术支持后，明确表示了 <strong>目前支持的S3仅有Amazon，即你暂时无法通过配置其他域名来实现其他S3的配置</strong> 。</p>\n</blockquote>\n<p>如果配置顺利，在“可视化编辑器”内，你就可以点击这里实现上传直接插入文档中：</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting4.png\" title=\"添加图片\"></p>\n<p>点击open后，会跳转到你的媒体库，上传即自动插入到文章中。</p>\n<h2 id=\"配置预览\"><a href=\"#配置预览\" class=\"headerlink\" title=\"配置预览\"></a>配置预览</h2><p>Forestry.io支持在发布前进行预览，需要配置预览的相关命令，环境以Node.js为主，也可以进行自定义，本章内容建议详细参阅官方文档的 <a href=\"https://forestry.io/docs/previews/instant-previews/\">配置页面</a></p>\n<h2 id=\"设置文章模板\"><a href=\"#设置文章模板\" class=\"headerlink\" title=\"设置文章模板\"></a>设置文章模板</h2><p>这一章也是非常重要的，我们在前面的Section里可以设置默认模板，这就是为了方便统一类别下的文章格式一致(Front matter)，点击左侧的Front matter进入配置界面。</p>\n<p>点击添加模板后，可以全新创建，也可以从已有的文章自动分析。</p>\n<blockquote>\n<p>我自己使用时发现，文本编辑的识别率较好，如果是类似标签选择的则会识别错误，建议先导入，然后添加一篇新文章进行测试。</p>\n</blockquote>\n<p>一般对于Markdown的博客写作，我们选择左侧的“Fields and big content area”。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/setting5.png\"></p>\n<p>Forestry.io提供了一些Field选项，对于博客写作，它们可以与你的Front matter一一对应，通过交互实现配置Front matter，进而与你的博客主题（如Banner图，文章简介等等）比较好的对应，具体使用可以自己体验一下。</p>\n"},{"date":"2020-03-02T07:09:04.000Z","title":"前端部分面试题解（不定期更新）","excerpt":"日常总得刷点算法题，对于一些面试题，还是开篇文章记录下更有价值。","thumbnail":"","_content":"### 已解决\n\n* Q: 用JS实现一个函数，能使输入特定的字符串转化为特定结构化数据。\n\n  字符串仅由小写字母和`[,]`构成，且字符串不包含多余的空格\n\n  示例一：`'abc'` -> `{value:'abc'}`\n\n  示例二：`'[abc[bcd[def]]]'`-> `{value:'abc',children:{value:'bcd',children:{value:'def'}}}`\n\n  A:\n\n  ```javascript\n  // 类比AST，将输入转换为一系列操作\n  function normalize(str) {\n    let parent = {}\n    // 所有括回均不需要，直接移除\n    parent.children = _normalize(str.replace(/\\]/g, ''))\n    return parent.children\n  }\n  \n  function _normalize(str) {\n    // [abc[bcd[def]]] => {value: \"abc\", children: {value: \"bcd\", children: {value: \"def\"}}}\n    // 不具有树形结构直接返回\n    let obj = {}\n    if(str.charAt(0) !== '[') {\n      obj.value = str\n      return obj\n    }\n    // '['开始, 找到之后的连续字符串\n    let arr = str.split('[')\n    let _val = arr[1]\n    // 截取剩下的部分再进行递归\n    let rest = ''\n    for(let i = 2; i < arr.length; i++) {\n      rest = rest + '[' +arr[i]\n    }\n    if (rest === '') {\n      return {value: _val}\n    }\n    return {value: _val, children: _normalize(rest)}\n  }\n  \n  normalize('[abc[bcd[def]]]')\n  // normalize('def')\n  ```\n  \n* Q: 模仿lodash内调用curry函数，实现一个myCurry？\n\n  A:\n\n  > 墙裂推荐这篇[译文](https://www.jianshu.com/p/822c4bfeb8a9)，将柯里化的思考过程逐步展现出来\n  \n  > 本题解法来自《JavaScript轻量级函数式编程》\n\n  ```javascript\n  // lodash: _.curry(func, [arity=func.length])\n  // 实现两点：1. 参数复用——可固定参数，2. 延迟计算——返回最终函数触发计算\n  // 原型实现：\n  function curry(fn, arity = fn.length) {\n    return (function nextCurried(prevArgs) {\n      return function curried(nextArg) {\n        var args = prevArgs.concat([nextArg])\n        if(args.length >= arity) {\n          return fn(...args)\n        } else {\n          return nextCurried(args)\n        }\n      }\n    })([])\n  }\n  // 注意：偏函数partial(add, 3)和柯里化curry(add)(3)的区别\n  ```\n  \n* Q: 在不使用slice，replace等原生函数的情况下，实现一个indexOf方法（本题来自“司徒正美”的[博客](https://www.cnblogs.com/rubylouvre/archive/2011/08/19/2144894.html)）？\n\n  A:\n  ```javascript\n  function getSubStrArr(str, length) {\n    var subStrArr = []\n    if(!length || length === 0) return subStrArr;\n    for (var i = 0; i < str.length - length + 1; i++) {\n      if(length > 1) {\n        var tmp = [];\n        for(var j = 0; j < length; j++) {\n          tmp.push(str.charAt(i + j));\n        }\n        subStrArr.push(tmp.join(''));\n      } else {\n        subStrArr.push(str.charAt(i));\n      }\n    }\n    return subStrArr;\n  }\n\n  function myIndexOf(str, target) {\n    if(target === '' || target === undefined) return flag;\n    var flag = -1\n    var subStrArr = getSubStrArr(str, target.length);\n    for(var i = 0; i < subStrArr.length; i++) {\n      if(subStrArr[i] === target) {\n        flag = i\n      }\n    }\n    return flag\n  }\n  console.log(myIndexOf('abcdefgh', 'cde'))\n  ```\n  \n* Q: 简单手写实现bind\n\n  A: 见 [实现bind](https://blog.sparking.app/post?id=fe%252Fspeaking-javascript-%25E9%2598%2585%25E8%25AF%25BB%25E7%25AC%2594%25E8%25AE%25B0-%25E4%25B8%2589)\n  \n* Q: 如何获取两个时间（格式如: 2001-01-30）中间相差的年月日（提供三个精度）\n\n  A:\n  ```javascript\n  // 这道题投机的方式是通过字符串与年月日格式的硬匹配完成，但是如果要求多种精度，则需要很繁琐，建议使用Date\n  function parseDate(str) {\n    let strArr = str.split('-')\n    if(strArr.length !== 3 || parseInt(strArr[0]) < 1970 || parseInt(strArr[1]) > 11 || parseInt(strArr[2]) > 31 ) { // 简单处理，兼容如果当月没有此日期\n      throw new Error('日期格式非法')\n    }\n    let date = new Date(strArr[0], strArr[1]-1, strArr[2])\n    return date;\n  }\n\n  // 深拷贝日期对象\n  function dateToString(_date, unit) {\n    var _d = new Date(_date.valueOf());\n    var _dStr = ''\n    if(unit > 0) _dStr += _d.getFullYear();\n    if(unit > 1) _dStr += ('-' + (parseInt(_d.getMonth()) + 1 >= 10 ? (parseInt(_d.getMonth()) + 1).toString() : '0' + (parseInt(_d.getMonth()) + 1).toString()));\n    if(unit > 2) _dStr += ('-' + (parseInt(_d.getDate()) >= 10 ? parseInt(_d.getDate()).toString() : '0' + parseInt(_d.getDate()).toString()));\n    return _dStr;\n  }\n\n  // unit指精度, 从1-3分别指年月日，函数返回一个数组，包含中间所有的相差的日子\n  function minorDates(start, end, unit) {\n    var _u = unit || 3;\n    var _start = parseDate(start)\n    var _end = parseDate(end)\n    var _minors = []\n    var _minorDate = _end - _start\n    var step = 24 * 60 * 60 * 1000; // default 一天\n    if(_minorDate <= 0) {\n      return _minors\n    } else {\n      for(var i = 0; i < _minorDate / step; i++) {\n        var _d = dateToString(new Date(_start.getTime() + i * step), unit)\n        if(_minors.indexOf(_d) === -1) _minors.push(_d);\n      }\n    }\n    return _minors\n  }\n\n  console.log(minorDates('2019-02-25', '2020-02-25', 3))\n  ```\n\n### 来自前端面试周报的题\n\n> 本篇主要记录 Github airuikun/[**Weekly-FE-Interview **](https://github.com/airuikun/Weekly-FE-Interview) 仓库内的优秀面试题我自己的解法，会持续更新，但是不会每题都解一遍，建议可以访问源仓库。\n\n* Q: 简单手写实现Promise\n\n  A:\n\n  ```javascript\n  // 实现主要三个功能，thenable，resolve，reject，catch，finally\n  ```\n* Q: 简单手写实现Async/Await\n\n  A:\n\n  ```javascript\n  \n  ```\n\n### [掘金](https://juejin.im/) 日常浏览的题目\n\n* Q: Promise题\n\n  **限制异步操作的并发个数并尽可能快的完成全部**\n\n  有8个图片资源的url，已经存储在数组urls中。\n\n  urls类似于`['https://image1.png', 'https://image2.png', ....]`\n\n  而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。\n  但有一个要求，任何时刻同时下载的链接数量不可以超过3个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。\n\n  > 作者：LinDaiDai_霖呆呆\n  >\n  > 链接：https://juejin.im/post/5e58c618e51d4526ed66b5cf\n  >\n  > 来源：掘金\n\n  A:\n\n  ```javascript\n  // 最优解法可以往瀑布流靠拢，有一个三个任务race的池，当一个完成时加入一个未开始的开始。\n  ```\n\n### 大厂面试题\n\n_本节内容来自网络_","source":"_posts/other/题解-每周10道前端面试题.md","raw":"---\ncategories: Other\ntags:\n- JavaScript\ndate: 2020-03-02T15:09:04.000+00:00\ntitle: 前端部分面试题解（不定期更新）\nexcerpt: 日常总得刷点算法题，对于一些面试题，还是开篇文章记录下更有价值。\nthumbnail: ''\n\n---\n### 已解决\n\n* Q: 用JS实现一个函数，能使输入特定的字符串转化为特定结构化数据。\n\n  字符串仅由小写字母和`[,]`构成，且字符串不包含多余的空格\n\n  示例一：`'abc'` -> `{value:'abc'}`\n\n  示例二：`'[abc[bcd[def]]]'`-> `{value:'abc',children:{value:'bcd',children:{value:'def'}}}`\n\n  A:\n\n  ```javascript\n  // 类比AST，将输入转换为一系列操作\n  function normalize(str) {\n    let parent = {}\n    // 所有括回均不需要，直接移除\n    parent.children = _normalize(str.replace(/\\]/g, ''))\n    return parent.children\n  }\n  \n  function _normalize(str) {\n    // [abc[bcd[def]]] => {value: \"abc\", children: {value: \"bcd\", children: {value: \"def\"}}}\n    // 不具有树形结构直接返回\n    let obj = {}\n    if(str.charAt(0) !== '[') {\n      obj.value = str\n      return obj\n    }\n    // '['开始, 找到之后的连续字符串\n    let arr = str.split('[')\n    let _val = arr[1]\n    // 截取剩下的部分再进行递归\n    let rest = ''\n    for(let i = 2; i < arr.length; i++) {\n      rest = rest + '[' +arr[i]\n    }\n    if (rest === '') {\n      return {value: _val}\n    }\n    return {value: _val, children: _normalize(rest)}\n  }\n  \n  normalize('[abc[bcd[def]]]')\n  // normalize('def')\n  ```\n  \n* Q: 模仿lodash内调用curry函数，实现一个myCurry？\n\n  A:\n\n  > 墙裂推荐这篇[译文](https://www.jianshu.com/p/822c4bfeb8a9)，将柯里化的思考过程逐步展现出来\n  \n  > 本题解法来自《JavaScript轻量级函数式编程》\n\n  ```javascript\n  // lodash: _.curry(func, [arity=func.length])\n  // 实现两点：1. 参数复用——可固定参数，2. 延迟计算——返回最终函数触发计算\n  // 原型实现：\n  function curry(fn, arity = fn.length) {\n    return (function nextCurried(prevArgs) {\n      return function curried(nextArg) {\n        var args = prevArgs.concat([nextArg])\n        if(args.length >= arity) {\n          return fn(...args)\n        } else {\n          return nextCurried(args)\n        }\n      }\n    })([])\n  }\n  // 注意：偏函数partial(add, 3)和柯里化curry(add)(3)的区别\n  ```\n  \n* Q: 在不使用slice，replace等原生函数的情况下，实现一个indexOf方法（本题来自“司徒正美”的[博客](https://www.cnblogs.com/rubylouvre/archive/2011/08/19/2144894.html)）？\n\n  A:\n  ```javascript\n  function getSubStrArr(str, length) {\n    var subStrArr = []\n    if(!length || length === 0) return subStrArr;\n    for (var i = 0; i < str.length - length + 1; i++) {\n      if(length > 1) {\n        var tmp = [];\n        for(var j = 0; j < length; j++) {\n          tmp.push(str.charAt(i + j));\n        }\n        subStrArr.push(tmp.join(''));\n      } else {\n        subStrArr.push(str.charAt(i));\n      }\n    }\n    return subStrArr;\n  }\n\n  function myIndexOf(str, target) {\n    if(target === '' || target === undefined) return flag;\n    var flag = -1\n    var subStrArr = getSubStrArr(str, target.length);\n    for(var i = 0; i < subStrArr.length; i++) {\n      if(subStrArr[i] === target) {\n        flag = i\n      }\n    }\n    return flag\n  }\n  console.log(myIndexOf('abcdefgh', 'cde'))\n  ```\n  \n* Q: 简单手写实现bind\n\n  A: 见 [实现bind](https://blog.sparking.app/post?id=fe%252Fspeaking-javascript-%25E9%2598%2585%25E8%25AF%25BB%25E7%25AC%2594%25E8%25AE%25B0-%25E4%25B8%2589)\n  \n* Q: 如何获取两个时间（格式如: 2001-01-30）中间相差的年月日（提供三个精度）\n\n  A:\n  ```javascript\n  // 这道题投机的方式是通过字符串与年月日格式的硬匹配完成，但是如果要求多种精度，则需要很繁琐，建议使用Date\n  function parseDate(str) {\n    let strArr = str.split('-')\n    if(strArr.length !== 3 || parseInt(strArr[0]) < 1970 || parseInt(strArr[1]) > 11 || parseInt(strArr[2]) > 31 ) { // 简单处理，兼容如果当月没有此日期\n      throw new Error('日期格式非法')\n    }\n    let date = new Date(strArr[0], strArr[1]-1, strArr[2])\n    return date;\n  }\n\n  // 深拷贝日期对象\n  function dateToString(_date, unit) {\n    var _d = new Date(_date.valueOf());\n    var _dStr = ''\n    if(unit > 0) _dStr += _d.getFullYear();\n    if(unit > 1) _dStr += ('-' + (parseInt(_d.getMonth()) + 1 >= 10 ? (parseInt(_d.getMonth()) + 1).toString() : '0' + (parseInt(_d.getMonth()) + 1).toString()));\n    if(unit > 2) _dStr += ('-' + (parseInt(_d.getDate()) >= 10 ? parseInt(_d.getDate()).toString() : '0' + parseInt(_d.getDate()).toString()));\n    return _dStr;\n  }\n\n  // unit指精度, 从1-3分别指年月日，函数返回一个数组，包含中间所有的相差的日子\n  function minorDates(start, end, unit) {\n    var _u = unit || 3;\n    var _start = parseDate(start)\n    var _end = parseDate(end)\n    var _minors = []\n    var _minorDate = _end - _start\n    var step = 24 * 60 * 60 * 1000; // default 一天\n    if(_minorDate <= 0) {\n      return _minors\n    } else {\n      for(var i = 0; i < _minorDate / step; i++) {\n        var _d = dateToString(new Date(_start.getTime() + i * step), unit)\n        if(_minors.indexOf(_d) === -1) _minors.push(_d);\n      }\n    }\n    return _minors\n  }\n\n  console.log(minorDates('2019-02-25', '2020-02-25', 3))\n  ```\n\n### 来自前端面试周报的题\n\n> 本篇主要记录 Github airuikun/[**Weekly-FE-Interview **](https://github.com/airuikun/Weekly-FE-Interview) 仓库内的优秀面试题我自己的解法，会持续更新，但是不会每题都解一遍，建议可以访问源仓库。\n\n* Q: 简单手写实现Promise\n\n  A:\n\n  ```javascript\n  // 实现主要三个功能，thenable，resolve，reject，catch，finally\n  ```\n* Q: 简单手写实现Async/Await\n\n  A:\n\n  ```javascript\n  \n  ```\n\n### [掘金](https://juejin.im/) 日常浏览的题目\n\n* Q: Promise题\n\n  **限制异步操作的并发个数并尽可能快的完成全部**\n\n  有8个图片资源的url，已经存储在数组urls中。\n\n  urls类似于`['https://image1.png', 'https://image2.png', ....]`\n\n  而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。\n  但有一个要求，任何时刻同时下载的链接数量不可以超过3个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。\n\n  > 作者：LinDaiDai_霖呆呆\n  >\n  > 链接：https://juejin.im/post/5e58c618e51d4526ed66b5cf\n  >\n  > 来源：掘金\n\n  A:\n\n  ```javascript\n  // 最优解法可以往瀑布流靠拢，有一个三个任务race的池，当一个完成时加入一个未开始的开始。\n  ```\n\n### 大厂面试题\n\n_本节内容来自网络_","slug":"other/题解-每周10道前端面试题","published":1,"updated":"2020-08-02T12:34:30.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckdev5icb005dj1wt2p0pf3wg","content":"<h3 id=\"已解决\"><a href=\"#已解决\" class=\"headerlink\" title=\"已解决\"></a>已解决</h3><ul>\n<li><p>Q: 用JS实现一个函数，能使输入特定的字符串转化为特定结构化数据。</p>\n<p>字符串仅由小写字母和<code>[,]</code>构成，且字符串不包含多余的空格</p>\n<p>示例一：<code>&#39;abc&#39;</code> -&gt; <code>{value:&#39;abc&#39;}</code></p>\n<p>示例二：<code>&#39;[abc[bcd[def]]]&#39;</code>-&gt; <code>{value:&#39;abc&#39;,children:{value:&#39;bcd&#39;,children:{value:&#39;def&#39;}}}</code></p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类比AST，将输入转换为一系列操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> parent = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 所有括回均不需要，直接移除</span></span><br><span class=\"line\">  parent.children = _normalize(str.replace(<span class=\"regexp\">/\\]/g</span>, <span class=\"string\">''</span>))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent.children</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_normalize</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// [abc[bcd[def]]] =&gt; &#123;value: \"abc\", children: &#123;value: \"bcd\", children: &#123;value: \"def\"&#125;&#125;&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 不具有树形结构直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(str.charAt(<span class=\"number\">0</span>) !== <span class=\"string\">'['</span>) &#123;</span><br><span class=\"line\">    obj.value = str</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// '['开始, 找到之后的连续字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = str.split(<span class=\"string\">'['</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _val = arr[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"comment\">// 截取剩下的部分再进行递归</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> rest = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    rest = rest + <span class=\"string\">'['</span> +arr[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rest === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: _val&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: _val, <span class=\"attr\">children</span>: _normalize(rest)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">normalize(<span class=\"string\">'[abc[bcd[def]]]'</span>)</span><br><span class=\"line\"><span class=\"comment\">// normalize('def')</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Q: 模仿lodash内调用curry函数，实现一个myCurry？</p>\n<p>A:</p>\n<blockquote>\n<p>墙裂推荐这篇<a href=\"https://www.jianshu.com/p/822c4bfeb8a9\">译文</a>，将柯里化的思考过程逐步展现出来</p>\n</blockquote>\n<blockquote>\n<p>本题解法来自《JavaScript轻量级函数式编程》</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lodash: _.curry(func, [arity=func.length])</span></span><br><span class=\"line\"><span class=\"comment\">// 实现两点：1. 参数复用——可固定参数，2. 延迟计算——返回最终函数触发计算</span></span><br><span class=\"line\"><span class=\"comment\">// 原型实现：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, arity = fn.length</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nextCurried</span>(<span class=\"params\">prevArgs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curried</span>(<span class=\"params\">nextArg</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> args = prevArgs.concat([nextArg])</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(args.length &gt;= arity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(...args)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextCurried(args)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)([])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：偏函数partial(add, 3)和柯里化curry(add)(3)的区别</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Q: 在不使用slice，replace等原生函数的情况下，实现一个indexOf方法（本题来自“司徒正美”的<a href=\"https://www.cnblogs.com/rubylouvre/archive/2011/08/19/2144894.html\">博客</a>）？</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSubStrArr</span>(<span class=\"params\">str, length</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> subStrArr = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!length || length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> subStrArr;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; str.length - length + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> tmp = [];</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        tmp.push(str.charAt(i + j));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      subStrArr.push(tmp.join(<span class=\"string\">''</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      subStrArr.push(str.charAt(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subStrArr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myIndexOf</span>(<span class=\"params\">str, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(target === <span class=\"string\">''</span> || target === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flag = <span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> subStrArr = getSubStrArr(str, target.length);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; subStrArr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(subStrArr[i] === target) &#123;</span><br><span class=\"line\">      flag = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myIndexOf(<span class=\"string\">'abcdefgh'</span>, <span class=\"string\">'cde'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Q: 简单手写实现bind</p>\n<p>A: 见 <a href=\"https://blog.sparking.app/post?id=fe%252Fspeaking-javascript-%25E9%2598%2585%25E8%25AF%25BB%25E7%25AC%2594%25E8%25AE%25B0-%25E4%25B8%2589\">实现bind</a></p>\n</li>\n<li><p>Q: 如何获取两个时间（格式如: 2001-01-30）中间相差的年月日（提供三个精度）</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这道题投机的方式是通过字符串与年月日格式的硬匹配完成，但是如果要求多种精度，则需要很繁琐，建议使用Date</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseDate</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> strArr = str.split(<span class=\"string\">'-'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(strArr.length !== <span class=\"number\">3</span> || <span class=\"built_in\">parseInt</span>(strArr[<span class=\"number\">0</span>]) &lt; <span class=\"number\">1970</span> || <span class=\"built_in\">parseInt</span>(strArr[<span class=\"number\">1</span>]) &gt; <span class=\"number\">11</span> || <span class=\"built_in\">parseInt</span>(strArr[<span class=\"number\">2</span>]) &gt; <span class=\"number\">31</span> ) &#123; <span class=\"comment\">// 简单处理，兼容如果当月没有此日期</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'日期格式非法'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(strArr[<span class=\"number\">0</span>], strArr[<span class=\"number\">1</span>]<span class=\"number\">-1</span>, strArr[<span class=\"number\">2</span>])</span><br><span class=\"line\">  <span class=\"keyword\">return</span> date;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深拷贝日期对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dateToString</span>(<span class=\"params\">_date, unit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(_date.valueOf());</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _dStr = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(unit &gt; <span class=\"number\">0</span>) _dStr += _d.getFullYear();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(unit &gt; <span class=\"number\">1</span>) _dStr += (<span class=\"string\">'-'</span> + (<span class=\"built_in\">parseInt</span>(_d.getMonth()) + <span class=\"number\">1</span> &gt;= <span class=\"number\">10</span> ? (<span class=\"built_in\">parseInt</span>(_d.getMonth()) + <span class=\"number\">1</span>).toString() : <span class=\"string\">'0'</span> + (<span class=\"built_in\">parseInt</span>(_d.getMonth()) + <span class=\"number\">1</span>).toString()));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(unit &gt; <span class=\"number\">2</span>) _dStr += (<span class=\"string\">'-'</span> + (<span class=\"built_in\">parseInt</span>(_d.getDate()) &gt;= <span class=\"number\">10</span> ? <span class=\"built_in\">parseInt</span>(_d.getDate()).toString() : <span class=\"string\">'0'</span> + <span class=\"built_in\">parseInt</span>(_d.getDate()).toString()));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _dStr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// unit指精度, 从1-3分别指年月日，函数返回一个数组，包含中间所有的相差的日子</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minorDates</span>(<span class=\"params\">start, end, unit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _u = unit || <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _start = parseDate(start)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _end = parseDate(end)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _minors = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _minorDate = _end - _start</span><br><span class=\"line\">  <span class=\"keyword\">var</span> step = <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>; <span class=\"comment\">// default 一天</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(_minorDate &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _minors</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; _minorDate / step; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> _d = dateToString(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(_start.getTime() + i * step), unit)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(_minors.indexOf(_d) === <span class=\"number\">-1</span>) _minors.push(_d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _minors</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(minorDates(<span class=\"string\">'2019-02-25'</span>, <span class=\"string\">'2020-02-25'</span>, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"来自前端面试周报的题\"><a href=\"#来自前端面试周报的题\" class=\"headerlink\" title=\"来自前端面试周报的题\"></a>来自前端面试周报的题</h3><blockquote>\n<p>本篇主要记录 Github airuikun/<a href=\"https://github.com/airuikun/Weekly-FE-Interview\">**Weekly-FE-Interview **</a> 仓库内的优秀面试题我自己的解法，会持续更新，但是不会每题都解一遍，建议可以访问源仓库。</p>\n</blockquote>\n<ul>\n<li><p>Q: 简单手写实现Promise</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现主要三个功能，thenable，resolve，reject，catch，finally</span></span><br></pre></td></tr></table></figure></li>\n<li><p>Q: 简单手写实现Async/Await</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"掘金-日常浏览的题目\"><a href=\"#掘金-日常浏览的题目\" class=\"headerlink\" title=\"掘金 日常浏览的题目\"></a><a href=\"https://juejin.im/\">掘金</a> 日常浏览的题目</h3><ul>\n<li><p>Q: Promise题</p>\n<p><strong>限制异步操作的并发个数并尽可能快的完成全部</strong></p>\n<p>有8个图片资源的url，已经存储在数组urls中。</p>\n<p>urls类似于<code>[&#39;https://image1.png&#39;, &#39;https://image2.png&#39;, ....]</code></p>\n<p>而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。<br>但有一个要求，任何时刻同时下载的链接数量不可以超过3个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>\n<blockquote>\n<p>作者：LinDaiDai_霖呆呆</p>\n<p>链接：<a href=\"https://juejin.im/post/5e58c618e51d4526ed66b5cf\">https://juejin.im/post/5e58c618e51d4526ed66b5cf</a></p>\n<p>来源：掘金</p>\n</blockquote>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最优解法可以往瀑布流靠拢，有一个三个任务race的池，当一个完成时加入一个未开始的开始。</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"大厂面试题\"><a href=\"#大厂面试题\" class=\"headerlink\" title=\"大厂面试题\"></a>大厂面试题</h3><p><em>本节内容来自网络</em></p>\n","site":{"data":{}},"more":"<h3 id=\"已解决\"><a href=\"#已解决\" class=\"headerlink\" title=\"已解决\"></a>已解决</h3><ul>\n<li><p>Q: 用JS实现一个函数，能使输入特定的字符串转化为特定结构化数据。</p>\n<p>字符串仅由小写字母和<code>[,]</code>构成，且字符串不包含多余的空格</p>\n<p>示例一：<code>&#39;abc&#39;</code> -&gt; <code>{value:&#39;abc&#39;}</code></p>\n<p>示例二：<code>&#39;[abc[bcd[def]]]&#39;</code>-&gt; <code>{value:&#39;abc&#39;,children:{value:&#39;bcd&#39;,children:{value:&#39;def&#39;}}}</code></p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 类比AST，将输入转换为一系列操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> parent = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 所有括回均不需要，直接移除</span></span><br><span class=\"line\">  parent.children = _normalize(str.replace(<span class=\"regexp\">/\\]/g</span>, <span class=\"string\">''</span>))</span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent.children</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_normalize</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// [abc[bcd[def]]] =&gt; &#123;value: \"abc\", children: &#123;value: \"bcd\", children: &#123;value: \"def\"&#125;&#125;&#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// 不具有树形结构直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(str.charAt(<span class=\"number\">0</span>) !== <span class=\"string\">'['</span>) &#123;</span><br><span class=\"line\">    obj.value = str</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// '['开始, 找到之后的连续字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> arr = str.split(<span class=\"string\">'['</span>)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _val = arr[<span class=\"number\">1</span>]</span><br><span class=\"line\">  <span class=\"comment\">// 截取剩下的部分再进行递归</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> rest = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    rest = rest + <span class=\"string\">'['</span> +arr[i]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (rest === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: _val&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;<span class=\"attr\">value</span>: _val, <span class=\"attr\">children</span>: _normalize(rest)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">normalize(<span class=\"string\">'[abc[bcd[def]]]'</span>)</span><br><span class=\"line\"><span class=\"comment\">// normalize('def')</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Q: 模仿lodash内调用curry函数，实现一个myCurry？</p>\n<p>A:</p>\n<blockquote>\n<p>墙裂推荐这篇<a href=\"https://www.jianshu.com/p/822c4bfeb8a9\">译文</a>，将柯里化的思考过程逐步展现出来</p>\n</blockquote>\n<blockquote>\n<p>本题解法来自《JavaScript轻量级函数式编程》</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lodash: _.curry(func, [arity=func.length])</span></span><br><span class=\"line\"><span class=\"comment\">// 实现两点：1. 参数复用——可固定参数，2. 延迟计算——返回最终函数触发计算</span></span><br><span class=\"line\"><span class=\"comment\">// 原型实现：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, arity = fn.length</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nextCurried</span>(<span class=\"params\">prevArgs</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curried</span>(<span class=\"params\">nextArg</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> args = prevArgs.concat([nextArg])</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(args.length &gt;= arity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(...args)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextCurried(args)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)([])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：偏函数partial(add, 3)和柯里化curry(add)(3)的区别</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Q: 在不使用slice，replace等原生函数的情况下，实现一个indexOf方法（本题来自“司徒正美”的<a href=\"https://www.cnblogs.com/rubylouvre/archive/2011/08/19/2144894.html\">博客</a>）？</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSubStrArr</span>(<span class=\"params\">str, length</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> subStrArr = []</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!length || length === <span class=\"number\">0</span>) <span class=\"keyword\">return</span> subStrArr;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; str.length - length + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> tmp = [];</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">        tmp.push(str.charAt(i + j));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      subStrArr.push(tmp.join(<span class=\"string\">''</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      subStrArr.push(str.charAt(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subStrArr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myIndexOf</span>(<span class=\"params\">str, target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(target === <span class=\"string\">''</span> || target === <span class=\"literal\">undefined</span>) <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> flag = <span class=\"number\">-1</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> subStrArr = getSubStrArr(str, target.length);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; subStrArr.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(subStrArr[i] === target) &#123;</span><br><span class=\"line\">      flag = i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myIndexOf(<span class=\"string\">'abcdefgh'</span>, <span class=\"string\">'cde'</span>))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Q: 简单手写实现bind</p>\n<p>A: 见 <a href=\"https://blog.sparking.app/post?id=fe%252Fspeaking-javascript-%25E9%2598%2585%25E8%25AF%25BB%25E7%25AC%2594%25E8%25AE%25B0-%25E4%25B8%2589\">实现bind</a></p>\n</li>\n<li><p>Q: 如何获取两个时间（格式如: 2001-01-30）中间相差的年月日（提供三个精度）</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这道题投机的方式是通过字符串与年月日格式的硬匹配完成，但是如果要求多种精度，则需要很繁琐，建议使用Date</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseDate</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> strArr = str.split(<span class=\"string\">'-'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(strArr.length !== <span class=\"number\">3</span> || <span class=\"built_in\">parseInt</span>(strArr[<span class=\"number\">0</span>]) &lt; <span class=\"number\">1970</span> || <span class=\"built_in\">parseInt</span>(strArr[<span class=\"number\">1</span>]) &gt; <span class=\"number\">11</span> || <span class=\"built_in\">parseInt</span>(strArr[<span class=\"number\">2</span>]) &gt; <span class=\"number\">31</span> ) &#123; <span class=\"comment\">// 简单处理，兼容如果当月没有此日期</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'日期格式非法'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(strArr[<span class=\"number\">0</span>], strArr[<span class=\"number\">1</span>]<span class=\"number\">-1</span>, strArr[<span class=\"number\">2</span>])</span><br><span class=\"line\">  <span class=\"keyword\">return</span> date;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深拷贝日期对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dateToString</span>(<span class=\"params\">_date, unit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(_date.valueOf());</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _dStr = <span class=\"string\">''</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(unit &gt; <span class=\"number\">0</span>) _dStr += _d.getFullYear();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(unit &gt; <span class=\"number\">1</span>) _dStr += (<span class=\"string\">'-'</span> + (<span class=\"built_in\">parseInt</span>(_d.getMonth()) + <span class=\"number\">1</span> &gt;= <span class=\"number\">10</span> ? (<span class=\"built_in\">parseInt</span>(_d.getMonth()) + <span class=\"number\">1</span>).toString() : <span class=\"string\">'0'</span> + (<span class=\"built_in\">parseInt</span>(_d.getMonth()) + <span class=\"number\">1</span>).toString()));</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(unit &gt; <span class=\"number\">2</span>) _dStr += (<span class=\"string\">'-'</span> + (<span class=\"built_in\">parseInt</span>(_d.getDate()) &gt;= <span class=\"number\">10</span> ? <span class=\"built_in\">parseInt</span>(_d.getDate()).toString() : <span class=\"string\">'0'</span> + <span class=\"built_in\">parseInt</span>(_d.getDate()).toString()));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _dStr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// unit指精度, 从1-3分别指年月日，函数返回一个数组，包含中间所有的相差的日子</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">minorDates</span>(<span class=\"params\">start, end, unit</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _u = unit || <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _start = parseDate(start)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _end = parseDate(end)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _minors = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _minorDate = _end - _start</span><br><span class=\"line\">  <span class=\"keyword\">var</span> step = <span class=\"number\">24</span> * <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>; <span class=\"comment\">// default 一天</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(_minorDate &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _minors</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; _minorDate / step; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> _d = dateToString(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(_start.getTime() + i * step), unit)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(_minors.indexOf(_d) === <span class=\"number\">-1</span>) _minors.push(_d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _minors</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(minorDates(<span class=\"string\">'2019-02-25'</span>, <span class=\"string\">'2020-02-25'</span>, <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"来自前端面试周报的题\"><a href=\"#来自前端面试周报的题\" class=\"headerlink\" title=\"来自前端面试周报的题\"></a>来自前端面试周报的题</h3><blockquote>\n<p>本篇主要记录 Github airuikun/<a href=\"https://github.com/airuikun/Weekly-FE-Interview\">**Weekly-FE-Interview **</a> 仓库内的优秀面试题我自己的解法，会持续更新，但是不会每题都解一遍，建议可以访问源仓库。</p>\n</blockquote>\n<ul>\n<li><p>Q: 简单手写实现Promise</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现主要三个功能，thenable，resolve，reject，catch，finally</span></span><br></pre></td></tr></table></figure></li>\n<li><p>Q: 简单手写实现Async/Await</p>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"掘金-日常浏览的题目\"><a href=\"#掘金-日常浏览的题目\" class=\"headerlink\" title=\"掘金 日常浏览的题目\"></a><a href=\"https://juejin.im/\">掘金</a> 日常浏览的题目</h3><ul>\n<li><p>Q: Promise题</p>\n<p><strong>限制异步操作的并发个数并尽可能快的完成全部</strong></p>\n<p>有8个图片资源的url，已经存储在数组urls中。</p>\n<p>urls类似于<code>[&#39;https://image1.png&#39;, &#39;https://image2.png&#39;, ....]</code></p>\n<p>而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。<br>但有一个要求，任何时刻同时下载的链接数量不可以超过3个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>\n<blockquote>\n<p>作者：LinDaiDai_霖呆呆</p>\n<p>链接：<a href=\"https://juejin.im/post/5e58c618e51d4526ed66b5cf\">https://juejin.im/post/5e58c618e51d4526ed66b5cf</a></p>\n<p>来源：掘金</p>\n</blockquote>\n<p>A:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最优解法可以往瀑布流靠拢，有一个三个任务race的池，当一个完成时加入一个未开始的开始。</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"大厂面试题\"><a href=\"#大厂面试题\" class=\"headerlink\" title=\"大厂面试题\"></a>大厂面试题</h3><p><em>本节内容来自网络</em></p>\n"},{"date":"2020-08-21T18:49:36.000Z","title":"解决切换用户提示的sed报错","excerpt":"使用WSL时，考虑到已有的环境已经配置好了，使用import复制了一个容器运行在WSL1下，遇到了sed报错，这里是一个解决思路","thumbnail":"","_content":"## 现象\n\n```bash\nsed: -e expression #1, char 24: unknown command: `.'\n```\n\n切换用户时（此用户是原来WSL2的默认账户），shell报以上错误。\n\n考虑到是切换用户才导致的，因此怀疑`.zshrc (or .bashrc)`内有命令错误\n\n## 移除未使用的命令\n\n使用debug模式，尝试读取并执行.zshrc\n\n> 如果不能确定当前.zshrc配置，请清理后再执行source！\n\n```bash\nsource ~/.zshrc -x\n```\n\n果然，发现了新的错误：\n\n```bash\ncompinit:501: no such file or directory: /usr/share/zsh/vendor-completions/_docker\n```\n\n这是由于复制时WSL2和WSL1在处理docker的方案上不同，导致自动补全的链接出现问题，移除WSL1容器内的docker自动补全\n\n```bash\ncd /usr/share/zsh/vendor-completions\n# remove your deprecated auto-completions\n```\n\n再执行source，问题解决！","source":"_posts/other/sed.md","raw":"---\ncategories: Other\ndate: 2020-08-22T10:49:36+08:00\ntags:\n- Linux\ntitle: 解决切换用户提示的sed报错\nexcerpt: 使用WSL时，考虑到已有的环境已经配置好了，使用import复制了一个容器运行在WSL1下，遇到了sed报错，这里是一个解决思路\nthumbnail: ''\n\n---\n## 现象\n\n```bash\nsed: -e expression #1, char 24: unknown command: `.'\n```\n\n切换用户时（此用户是原来WSL2的默认账户），shell报以上错误。\n\n考虑到是切换用户才导致的，因此怀疑`.zshrc (or .bashrc)`内有命令错误\n\n## 移除未使用的命令\n\n使用debug模式，尝试读取并执行.zshrc\n\n> 如果不能确定当前.zshrc配置，请清理后再执行source！\n\n```bash\nsource ~/.zshrc -x\n```\n\n果然，发现了新的错误：\n\n```bash\ncompinit:501: no such file or directory: /usr/share/zsh/vendor-completions/_docker\n```\n\n这是由于复制时WSL2和WSL1在处理docker的方案上不同，导致自动补全的链接出现问题，移除WSL1容器内的docker自动补全\n\n```bash\ncd /usr/share/zsh/vendor-completions\n# remove your deprecated auto-completions\n```\n\n再执行source，问题解决！","slug":"other/sed","published":1,"updated":"2020-11-17T14:15:40.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhm46dvb0000b6wt22376obe","content":"<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed: -e expression <span class=\"comment\">#1, char 24: unknown command: `.&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>切换用户时（此用户是原来WSL2的默认账户），shell报以上错误。</p>\n<p>考虑到是切换用户才导致的，因此怀疑<code>.zshrc (or .bashrc)</code>内有命令错误</p>\n<h2 id=\"移除未使用的命令\"><a href=\"#移除未使用的命令\" class=\"headerlink\" title=\"移除未使用的命令\"></a>移除未使用的命令</h2><p>使用debug模式，尝试读取并执行.zshrc</p>\n<blockquote>\n<p>如果不能确定当前.zshrc配置，请清理后再执行source！</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc -x</span><br></pre></td></tr></table></figure>\n\n<p>果然，发现了新的错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compinit:501: no such file or directory: /usr/share/zsh/vendor-completions/_docker</span><br></pre></td></tr></table></figure>\n\n<p>这是由于复制时WSL2和WSL1在处理docker的方案上不同，导致自动补全的链接出现问题，移除WSL1容器内的docker自动补全</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/share/zsh/vendor-completions</span><br><span class=\"line\"><span class=\"comment\"># remove your deprecated auto-completions</span></span><br></pre></td></tr></table></figure>\n\n<p>再执行source，问题解决！</p>\n","site":{"data":{}},"more":"<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed: -e expression <span class=\"comment\">#1, char 24: unknown command: `.&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>切换用户时（此用户是原来WSL2的默认账户），shell报以上错误。</p>\n<p>考虑到是切换用户才导致的，因此怀疑<code>.zshrc (or .bashrc)</code>内有命令错误</p>\n<h2 id=\"移除未使用的命令\"><a href=\"#移除未使用的命令\" class=\"headerlink\" title=\"移除未使用的命令\"></a>移除未使用的命令</h2><p>使用debug模式，尝试读取并执行.zshrc</p>\n<blockquote>\n<p>如果不能确定当前.zshrc配置，请清理后再执行source！</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.zshrc -x</span><br></pre></td></tr></table></figure>\n\n<p>果然，发现了新的错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compinit:501: no such file or directory: /usr/share/zsh/vendor-completions/_docker</span><br></pre></td></tr></table></figure>\n\n<p>这是由于复制时WSL2和WSL1在处理docker的方案上不同，导致自动补全的链接出现问题，移除WSL1容器内的docker自动补全</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /usr/share/zsh/vendor-completions</span><br><span class=\"line\"><span class=\"comment\"># remove your deprecated auto-completions</span></span><br></pre></td></tr></table></figure>\n\n<p>再执行source，问题解决！</p>\n"},{"date":"2020-09-22T22:03:55.000Z","title":"跨域这个问题还得单独揪出来说一下","excerpt":"Access to XMLHttpRequest at 'a.site' from origin 'b.site' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: It does not have HTTP ok status.","thumbnail":"","_content":"> 跨域,一个说腻了的话题,今天遇到一个新的情况,单独拎出来说说;\n\n## 情景再现\n\nb.site有一个ajax请求a.site的某一个地址,post请求+自定义header(假设,header头为`X-Application-Token`),ok,妥妥的跨域,那么自然加上以下代码(以express.js为例):\n\n```javascript\napp.options('*', (req, res, next) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Headers\", \"X-Application-Token\")\n    // call the path service\n})\napp.post('/a-cors-request-path', (req, res) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Headers\", \"X-Application-Token\")\n    // call the path service\n})\n```\n\n反复确认了相关配置已经设置好,但浏览器仍报错:\n\n> Access to XMLHttpRequest at 'a.site' from origin 'b.site' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: It does not have HTTP ok status.\n\n## 排查\n\n1. 返回说\"not have HTTP ok status\"\n\n那么说明option请求没有返回200,打开postman发送请求尝试看看,成功返回...\n\n1. 自己启动一个Express Server,尝试复现\n\n已经能够确认,option不通过和状态码有关,那么为什么浏览器内非200,而postman发送option请求正常返回200 ?\n\n打印headers,一口老血...\n\n![cors-with-verify-header](https://cdn.sparkling.land/public/blog/images/cors-with-verify-header.png)\n\n## 结论\n\n除了常见的跨域问题,也要考虑实现时的业务逻辑,比如本情境下,错误的在option中也调用相关服务验证了`X-Application-Token`,而option请求在浏览器内是不会携带额外的header信息的,这才导致了浏览器内 _not HTTP ok status_,而postman正常的原因.\n\n## 额外\n\n后来利用老的Microsoft Edge浏览器(Edge legacy)调试,发现会清楚的返回400 Bad Request,所以如果option请求能够返回精确的HTTP code,也会更利于开发人员排查问题,后续修改后完美解决.","source":"_posts/fe/跨域这个问题还得单独揪出来说一下.md","raw":"---\ncategories: Frontend\ndate: 2020-09-23T14:03:55+08:00\ntags:\n- JavaScript\ntitle: 跨域这个问题还得单独揪出来说一下\nexcerpt: 'Access to XMLHttpRequest at ''a.site'' from origin ''b.site'' has been blocked\n  by CORS policy: Response to preflight request doesn''t pass access control check:\n  It does not have HTTP ok status.'\nthumbnail: ''\n\n---\n> 跨域,一个说腻了的话题,今天遇到一个新的情况,单独拎出来说说;\n\n## 情景再现\n\nb.site有一个ajax请求a.site的某一个地址,post请求+自定义header(假设,header头为`X-Application-Token`),ok,妥妥的跨域,那么自然加上以下代码(以express.js为例):\n\n```javascript\napp.options('*', (req, res, next) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Headers\", \"X-Application-Token\")\n    // call the path service\n})\napp.post('/a-cors-request-path', (req, res) => {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Headers\", \"X-Application-Token\")\n    // call the path service\n})\n```\n\n反复确认了相关配置已经设置好,但浏览器仍报错:\n\n> Access to XMLHttpRequest at 'a.site' from origin 'b.site' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: It does not have HTTP ok status.\n\n## 排查\n\n1. 返回说\"not have HTTP ok status\"\n\n那么说明option请求没有返回200,打开postman发送请求尝试看看,成功返回...\n\n1. 自己启动一个Express Server,尝试复现\n\n已经能够确认,option不通过和状态码有关,那么为什么浏览器内非200,而postman发送option请求正常返回200 ?\n\n打印headers,一口老血...\n\n![cors-with-verify-header](https://cdn.sparkling.land/public/blog/images/cors-with-verify-header.png)\n\n## 结论\n\n除了常见的跨域问题,也要考虑实现时的业务逻辑,比如本情境下,错误的在option中也调用相关服务验证了`X-Application-Token`,而option请求在浏览器内是不会携带额外的header信息的,这才导致了浏览器内 _not HTTP ok status_,而postman正常的原因.\n\n## 额外\n\n后来利用老的Microsoft Edge浏览器(Edge legacy)调试,发现会清楚的返回400 Bad Request,所以如果option请求能够返回精确的HTTP code,也会更利于开发人员排查问题,后续修改后完美解决.","slug":"fe/跨域这个问题还得单独揪出来说一下","published":1,"updated":"2020-11-17T14:15:40.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhm46dvj0002b6wt4gajdl6l","content":"<blockquote>\n<p>跨域,一个说腻了的话题,今天遇到一个新的情况,单独拎出来说说;</p>\n</blockquote>\n<h2 id=\"情景再现\"><a href=\"#情景再现\" class=\"headerlink\" title=\"情景再现\"></a>情景再现</h2><p>b.site有一个ajax请求a.site的某一个地址,post请求+自定义header(假设,header头为<code>X-Application-Token</code>),ok,妥妥的跨域,那么自然加上以下代码(以express.js为例):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.options(<span class=\"string\">&#x27;*&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, <span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;X-Application-Token&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// call the path service</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.post(<span class=\"string\">&#x27;/a-cors-request-path&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, <span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;X-Application-Token&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// call the path service</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>反复确认了相关配置已经设置好,但浏览器仍报错:</p>\n<blockquote>\n<p>Access to XMLHttpRequest at ‘a.site’ from origin ‘b.site’ has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: It does not have HTTP ok status.</p>\n</blockquote>\n<h2 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h2><ol>\n<li>返回说”not have HTTP ok status”</li>\n</ol>\n<p>那么说明option请求没有返回200,打开postman发送请求尝试看看,成功返回…</p>\n<ol>\n<li>自己启动一个Express Server,尝试复现</li>\n</ol>\n<p>已经能够确认,option不通过和状态码有关,那么为什么浏览器内非200,而postman发送option请求正常返回200 ?</p>\n<p>打印headers,一口老血…</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/cors-with-verify-header.png\" alt=\"cors-with-verify-header\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>除了常见的跨域问题,也要考虑实现时的业务逻辑,比如本情境下,错误的在option中也调用相关服务验证了<code>X-Application-Token</code>,而option请求在浏览器内是不会携带额外的header信息的,这才导致了浏览器内 <em>not HTTP ok status</em>,而postman正常的原因.</p>\n<h2 id=\"额外\"><a href=\"#额外\" class=\"headerlink\" title=\"额外\"></a>额外</h2><p>后来利用老的Microsoft Edge浏览器(Edge legacy)调试,发现会清楚的返回400 Bad Request,所以如果option请求能够返回精确的HTTP code,也会更利于开发人员排查问题,后续修改后完美解决.</p>\n","site":{"data":{}},"more":"<blockquote>\n<p>跨域,一个说腻了的话题,今天遇到一个新的情况,单独拎出来说说;</p>\n</blockquote>\n<h2 id=\"情景再现\"><a href=\"#情景再现\" class=\"headerlink\" title=\"情景再现\"></a>情景再现</h2><p>b.site有一个ajax请求a.site的某一个地址,post请求+自定义header(假设,header头为<code>X-Application-Token</code>),ok,妥妥的跨域,那么自然加上以下代码(以express.js为例):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.options(<span class=\"string\">&#x27;*&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, <span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;X-Application-Token&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// call the path service</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.post(<span class=\"string\">&#x27;/a-cors-request-path&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Origin&quot;</span>, <span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">    res.header(<span class=\"string\">&quot;Access-Control-Allow-Headers&quot;</span>, <span class=\"string\">&quot;X-Application-Token&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// call the path service</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>反复确认了相关配置已经设置好,但浏览器仍报错:</p>\n<blockquote>\n<p>Access to XMLHttpRequest at ‘a.site’ from origin ‘b.site’ has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: It does not have HTTP ok status.</p>\n</blockquote>\n<h2 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h2><ol>\n<li>返回说”not have HTTP ok status”</li>\n</ol>\n<p>那么说明option请求没有返回200,打开postman发送请求尝试看看,成功返回…</p>\n<ol>\n<li>自己启动一个Express Server,尝试复现</li>\n</ol>\n<p>已经能够确认,option不通过和状态码有关,那么为什么浏览器内非200,而postman发送option请求正常返回200 ?</p>\n<p>打印headers,一口老血…</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/cors-with-verify-header.png\" alt=\"cors-with-verify-header\"></p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>除了常见的跨域问题,也要考虑实现时的业务逻辑,比如本情境下,错误的在option中也调用相关服务验证了<code>X-Application-Token</code>,而option请求在浏览器内是不会携带额外的header信息的,这才导致了浏览器内 <em>not HTTP ok status</em>,而postman正常的原因.</p>\n<h2 id=\"额外\"><a href=\"#额外\" class=\"headerlink\" title=\"额外\"></a>额外</h2><p>后来利用老的Microsoft Edge浏览器(Edge legacy)调试,发现会清楚的返回400 Bad Request,所以如果option请求能够返回精确的HTTP code,也会更利于开发人员排查问题,后续修改后完美解决.</p>\n"},{"date":"2020-08-09T00:37:06.000Z","title":"配置MS Edge双版本并行","excerpt":"作为前端偶尔需要调试两个版本的Edge是否存在Bug，而且老Edge在一些方便的功能，比如PDF预览，新Edge还是不如的，因此本文主要介绍如何配置双版本共存。","thumbnail":"","_content":"## 如果你还没有被自动更新\n\n你可以选择Fast Cycle或者使用Beta版尝鲜新Edge，这样的Edge版本不需要进行额外的操作，即可与旧版本兼容并存。\n\n## 如果你已经通过Windows Update自动更新\n\n那么就需要通过注册表修改使其并存。\n\n首先找到注册表的这个位置：\n\n`HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft`\n\n在左侧的`Microsoft`项右键，选择“新建” > “项”，命名为EdgeUpdate。\n\n在右侧窗口，右键，新建DWORD（32位）值，命名为`Allowsxs`，双击修改值为1（保持16进制不变）。\n\n最终成果如图：![注册表最终修改](https://cdn.sparkling.land/public/blog/images/dual-edge-reg.png)\n\n## 如果操作完成后开始菜单仍找不到“Microsoft Edge 旧版”\n\n在“设置” > “应用和功能”找到新版Edge，点击修改，（如果有卸载可以尝试卸载），再重新安装即可双版本共存。\n\n![双版本共存](https://cdn.sparkling.land/public/blog/images/dual-edge-final.png)","source":"_posts/other/ms-edge.md","raw":"---\ncategories: Other\ndate: 2020-08-09T16:37:06+08:00\ntags:\n- Edge\ntitle: 配置MS Edge双版本并行\nexcerpt: 作为前端偶尔需要调试两个版本的Edge是否存在Bug，而且老Edge在一些方便的功能，比如PDF预览，新Edge还是不如的，因此本文主要介绍如何配置双版本共存。\nthumbnail: ''\n\n---\n## 如果你还没有被自动更新\n\n你可以选择Fast Cycle或者使用Beta版尝鲜新Edge，这样的Edge版本不需要进行额外的操作，即可与旧版本兼容并存。\n\n## 如果你已经通过Windows Update自动更新\n\n那么就需要通过注册表修改使其并存。\n\n首先找到注册表的这个位置：\n\n`HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft`\n\n在左侧的`Microsoft`项右键，选择“新建” > “项”，命名为EdgeUpdate。\n\n在右侧窗口，右键，新建DWORD（32位）值，命名为`Allowsxs`，双击修改值为1（保持16进制不变）。\n\n最终成果如图：![注册表最终修改](https://cdn.sparkling.land/public/blog/images/dual-edge-reg.png)\n\n## 如果操作完成后开始菜单仍找不到“Microsoft Edge 旧版”\n\n在“设置” > “应用和功能”找到新版Edge，点击修改，（如果有卸载可以尝试卸载），再重新安装即可双版本共存。\n\n![双版本共存](https://cdn.sparkling.land/public/blog/images/dual-edge-final.png)","slug":"other/ms-edge","published":1,"updated":"2020-11-17T14:15:40.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhm46dvm0005b6wt848udwy0","content":"<h2 id=\"如果你还没有被自动更新\"><a href=\"#如果你还没有被自动更新\" class=\"headerlink\" title=\"如果你还没有被自动更新\"></a>如果你还没有被自动更新</h2><p>你可以选择Fast Cycle或者使用Beta版尝鲜新Edge，这样的Edge版本不需要进行额外的操作，即可与旧版本兼容并存。</p>\n<h2 id=\"如果你已经通过Windows-Update自动更新\"><a href=\"#如果你已经通过Windows-Update自动更新\" class=\"headerlink\" title=\"如果你已经通过Windows Update自动更新\"></a>如果你已经通过Windows Update自动更新</h2><p>那么就需要通过注册表修改使其并存。</p>\n<p>首先找到注册表的这个位置：</p>\n<p><code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft</code></p>\n<p>在左侧的<code>Microsoft</code>项右键，选择“新建” &gt; “项”，命名为EdgeUpdate。</p>\n<p>在右侧窗口，右键，新建DWORD（32位）值，命名为<code>Allowsxs</code>，双击修改值为1（保持16进制不变）。</p>\n<p>最终成果如图：<img src=\"https://cdn.sparkling.land/public/blog/images/dual-edge-reg.png\" alt=\"注册表最终修改\"></p>\n<h2 id=\"如果操作完成后开始菜单仍找不到“Microsoft-Edge-旧版”\"><a href=\"#如果操作完成后开始菜单仍找不到“Microsoft-Edge-旧版”\" class=\"headerlink\" title=\"如果操作完成后开始菜单仍找不到“Microsoft Edge 旧版”\"></a>如果操作完成后开始菜单仍找不到“Microsoft Edge 旧版”</h2><p>在“设置” &gt; “应用和功能”找到新版Edge，点击修改，（如果有卸载可以尝试卸载），再重新安装即可双版本共存。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/dual-edge-final.png\" alt=\"双版本共存\"></p>\n","site":{"data":{}},"more":"<h2 id=\"如果你还没有被自动更新\"><a href=\"#如果你还没有被自动更新\" class=\"headerlink\" title=\"如果你还没有被自动更新\"></a>如果你还没有被自动更新</h2><p>你可以选择Fast Cycle或者使用Beta版尝鲜新Edge，这样的Edge版本不需要进行额外的操作，即可与旧版本兼容并存。</p>\n<h2 id=\"如果你已经通过Windows-Update自动更新\"><a href=\"#如果你已经通过Windows-Update自动更新\" class=\"headerlink\" title=\"如果你已经通过Windows Update自动更新\"></a>如果你已经通过Windows Update自动更新</h2><p>那么就需要通过注册表修改使其并存。</p>\n<p>首先找到注册表的这个位置：</p>\n<p><code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft</code></p>\n<p>在左侧的<code>Microsoft</code>项右键，选择“新建” &gt; “项”，命名为EdgeUpdate。</p>\n<p>在右侧窗口，右键，新建DWORD（32位）值，命名为<code>Allowsxs</code>，双击修改值为1（保持16进制不变）。</p>\n<p>最终成果如图：<img src=\"https://cdn.sparkling.land/public/blog/images/dual-edge-reg.png\" alt=\"注册表最终修改\"></p>\n<h2 id=\"如果操作完成后开始菜单仍找不到“Microsoft-Edge-旧版”\"><a href=\"#如果操作完成后开始菜单仍找不到“Microsoft-Edge-旧版”\" class=\"headerlink\" title=\"如果操作完成后开始菜单仍找不到“Microsoft Edge 旧版”\"></a>如果操作完成后开始菜单仍找不到“Microsoft Edge 旧版”</h2><p>在“设置” &gt; “应用和功能”找到新版Edge，点击修改，（如果有卸载可以尝试卸载），再重新安装即可双版本共存。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/dual-edge-final.png\" alt=\"双版本共存\"></p>\n"},{"date":"2020-08-09T21:33:08.000Z","title":"有关于UWP应用联网的问题","excerpt":"最近在使用Microsoft Todo时，经常遇到无法同步的问题，也将一些微软的域名添加到了PAC，但仍然没有效果，于是想到了翻阅代理的issues。","thumbnail":"","_content":"## 依然先说结论\n\nUWP应用是一类特殊的应用，Windows会限制其在使用代理时使用127.0.0.1的回环地址，因此需要使用第三方工具开启回环代理或者修改注册表，考虑到修改注册表危险性较高且不便于操作，这里转载来自[Qv2ray](https://qv2ray.net/getting-started/step4.html#%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86)的解决方案。\n\n## EnableLoopback\n\n这是一个来自Fiddler的项目，用来调试UWP应用，也可以为我们简单的开启本地代理。\n\n> Qv2ray给出的下载地址：[链接](https://qv2ray.net/EnableLoopback.zip)\n> 上传到本站的地址：[链接](https://cdn.sparkling.land/public/blog/images/EnableLoopback.exe)\n\n打开后在左侧的应用名称找到Microsoft Todo（或者其他的UWP应用名），勾选并点击\"Save Changes\"，即可开启127.0.0.1的本地代理权限。\n\n![](https://cdn.sparkling.land/public/blog/images/enable-uwp-proxy.png)","source":"_posts/other/uwp.md","raw":"---\ncategories: Other\ndate: 2020-08-10T13:33:08+08:00\ntags:\n- UWP\ntitle: 有关于UWP应用联网的问题\nexcerpt: 最近在使用Microsoft Todo时，经常遇到无法同步的问题，也将一些微软的域名添加到了PAC，但仍然没有效果，于是想到了翻阅代理的issues。\nthumbnail: ''\n\n---\n## 依然先说结论\n\nUWP应用是一类特殊的应用，Windows会限制其在使用代理时使用127.0.0.1的回环地址，因此需要使用第三方工具开启回环代理或者修改注册表，考虑到修改注册表危险性较高且不便于操作，这里转载来自[Qv2ray](https://qv2ray.net/getting-started/step4.html#%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86)的解决方案。\n\n## EnableLoopback\n\n这是一个来自Fiddler的项目，用来调试UWP应用，也可以为我们简单的开启本地代理。\n\n> Qv2ray给出的下载地址：[链接](https://qv2ray.net/EnableLoopback.zip)\n> 上传到本站的地址：[链接](https://cdn.sparkling.land/public/blog/images/EnableLoopback.exe)\n\n打开后在左侧的应用名称找到Microsoft Todo（或者其他的UWP应用名），勾选并点击\"Save Changes\"，即可开启127.0.0.1的本地代理权限。\n\n![](https://cdn.sparkling.land/public/blog/images/enable-uwp-proxy.png)","slug":"other/uwp","published":1,"updated":"2020-11-17T14:15:40.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckhm46dvn0008b6wt3lrw0ypk","content":"<h2 id=\"依然先说结论\"><a href=\"#依然先说结论\" class=\"headerlink\" title=\"依然先说结论\"></a>依然先说结论</h2><p>UWP应用是一类特殊的应用，Windows会限制其在使用代理时使用127.0.0.1的回环地址，因此需要使用第三方工具开启回环代理或者修改注册表，考虑到修改注册表危险性较高且不便于操作，这里转载来自<a href=\"https://qv2ray.net/getting-started/step4.html#%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86\">Qv2ray</a>的解决方案。</p>\n<h2 id=\"EnableLoopback\"><a href=\"#EnableLoopback\" class=\"headerlink\" title=\"EnableLoopback\"></a>EnableLoopback</h2><p>这是一个来自Fiddler的项目，用来调试UWP应用，也可以为我们简单的开启本地代理。</p>\n<blockquote>\n<p>Qv2ray给出的下载地址：<a href=\"https://qv2ray.net/EnableLoopback.zip\">链接</a><br>上传到本站的地址：<a href=\"https://cdn.sparkling.land/public/blog/images/EnableLoopback.exe\">链接</a></p>\n</blockquote>\n<p>打开后在左侧的应用名称找到Microsoft Todo（或者其他的UWP应用名），勾选并点击”Save Changes”，即可开启127.0.0.1的本地代理权限。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/enable-uwp-proxy.png\"></p>\n","site":{"data":{}},"more":"<h2 id=\"依然先说结论\"><a href=\"#依然先说结论\" class=\"headerlink\" title=\"依然先说结论\"></a>依然先说结论</h2><p>UWP应用是一类特殊的应用，Windows会限制其在使用代理时使用127.0.0.1的回环地址，因此需要使用第三方工具开启回环代理或者修改注册表，考虑到修改注册表危险性较高且不便于操作，这里转载来自<a href=\"https://qv2ray.net/getting-started/step4.html#%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86\">Qv2ray</a>的解决方案。</p>\n<h2 id=\"EnableLoopback\"><a href=\"#EnableLoopback\" class=\"headerlink\" title=\"EnableLoopback\"></a>EnableLoopback</h2><p>这是一个来自Fiddler的项目，用来调试UWP应用，也可以为我们简单的开启本地代理。</p>\n<blockquote>\n<p>Qv2ray给出的下载地址：<a href=\"https://qv2ray.net/EnableLoopback.zip\">链接</a><br>上传到本站的地址：<a href=\"https://cdn.sparkling.land/public/blog/images/EnableLoopback.exe\">链接</a></p>\n</blockquote>\n<p>打开后在左侧的应用名称找到Microsoft Todo（或者其他的UWP应用名），勾选并点击”Save Changes”，即可开启127.0.0.1的本地代理权限。</p>\n<p><img src=\"https://cdn.sparkling.land/public/blog/images/enable-uwp-proxy.png\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckdev5ia60006j1wt7zpwcsrj","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iad000cj1wtdzwz60lt"},{"post_id":"ckdev5i9z0001j1wt1e7i0z10","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iaf000gj1wt1kv782au"},{"post_id":"ckdev5ia70007j1wt4xqvhqbw","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iaf000jj1wt2i820mag"},{"post_id":"ckdev5iab000aj1wt5nyi8axe","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iah000nj1wt90ead1h4"},{"post_id":"ckdev5ia20002j1wtbfroc186","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iai000qj1wtgnbb5j8d"},{"post_id":"ckdev5iac000bj1wt8det7fic","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iai000tj1wthonj3gqy"},{"post_id":"ckdev5iae000fj1wtdgwb019b","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iak000wj1wtaczaci5a"},{"post_id":"ckdev5ia50005j1wt2bgl4ezl","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ial000zj1wtatai78tk"},{"post_id":"ckdev5iaf000ij1wt5n1wh1hr","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ial0012j1wt92t0bjvm"},{"post_id":"ckdev5iag000mj1wt5dvzhkd1","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iam0014j1wt3b26bvgj"},{"post_id":"ckdev5iah000pj1wt3k2n04j0","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ian0018j1wt1bs2d5v4"},{"post_id":"ckdev5iai000sj1wth0hxhc9t","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iap001bj1wt6okj7uxf"},{"post_id":"ckdev5iaj000vj1wth4n56w1e","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iar001fj1wt7y4g0vnq"},{"post_id":"ckdev5iak000yj1wth5ya71ar","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iar001hj1wtaq1564wp"},{"post_id":"ckdev5ial0011j1wt6aws70y1","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ias001lj1wthsxj71ll"},{"post_id":"ckdev5iam0013j1wtb1780le9","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iat001nj1wtd9oia7ac"},{"post_id":"ckdev5ian0017j1wtcpic30xg","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iav001rj1wte8lb11jj"},{"post_id":"ckdev5iao001aj1wtd6zugto5","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iav001uj1wt3s7y73tw"},{"post_id":"ckdev5iaq001ej1wt0bcmgy3d","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iaw001yj1wtadyqfxw3"},{"post_id":"ckdev5iar001gj1wt66dwan10","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iay0021j1wtgnx8a48d"},{"post_id":"ckdev5ias001kj1wt9h368ncw","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iaz0024j1wt8ttsc2yj"},{"post_id":"ckdev5iat001mj1wtbtgibcqz","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib00027j1wtb6fg3q9v"},{"post_id":"ckdev5iau001qj1wt8gok0aql","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib2002bj1wt4a7mbzc5"},{"post_id":"ckdev5iav001tj1wtgt4h7g28","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib3002ej1wtg374f16e"},{"post_id":"ckdev5iaw001xj1wtanu15md3","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib4002hj1wtcwy83c2l"},{"post_id":"ckdev5iay0020j1wt0bmo3za4","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib5002kj1wtcj4o0osv"},{"post_id":"ckdev5iaz0023j1wt85i3gsi4","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib6002nj1wtamix5kb0"},{"post_id":"ckdev5iaz0026j1wt26533unv","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib6002qj1wt5u7oc24r"},{"post_id":"ckdev5ib1002aj1wt4gv34vl0","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib7002uj1wt0l2h7b2k"},{"post_id":"ckdev5ib2002dj1wtet0f3ae0","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib8002yj1wt1ep42h5z"},{"post_id":"ckdev5ib3002gj1wt9erh2v3k","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ib90032j1wt8bna7auo"},{"post_id":"ckdev5ib4002jj1wt566u738s","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5iba0035j1wtcbohbydi"},{"post_id":"ckdev5ib5002mj1wt746sgyqt","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ibb0039j1wtgmtd9lnp"},{"post_id":"ckdev5ib7002tj1wt9fs16ny3","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ibc003cj1wtbwjk48os"},{"post_id":"ckdev5ib8002xj1wt8jmf1cro","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ibd003gj1wt5us6751m"},{"post_id":"ckdev5ib6002pj1wt04le11oc","category_id":"ckdev5ib8002vj1wt2rurfxtv","_id":"ckdev5ibf003jj1wt1aqke6nj"},{"post_id":"ckdev5iba0034j1wt9x7j1rxm","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ibg003mj1wt3uy010jc"},{"post_id":"ckdev5ibc003bj1wt8j359qwi","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibh003pj1wteljy2yn7"},{"post_id":"ckdev5ib90031j1wt6u6zazzf","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibh003rj1wtgkmn1v0d"},{"post_id":"ckdev5ibd003ej1wtgq7w74t2","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibi003vj1wtewr37604"},{"post_id":"ckdev5ibe003ij1wt3hcv6de1","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibj003wj1wtdt8z66gl"},{"post_id":"ckdev5ibb0038j1wtbug73v9u","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibj003zj1wt8u1nh04r"},{"post_id":"ckdev5ibf003lj1wtbxjyejqs","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibj0041j1wtat7w7xcs"},{"post_id":"ckdev5ibg003oj1wtg77g4wd2","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibk0043j1wt9gfhexoo"},{"post_id":"ckdev5ibh003qj1wt4q0ta2kb","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5ibk0045j1wtaq6teabg"},{"post_id":"ckdev5ibi003uj1wt5ufw4c84","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckdev5ibk0047j1wt90l5abqm"},{"post_id":"ckdev5ica005cj1wtcfyj6gjr","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5icc005gj1wt8hfz2q5h"},{"post_id":"ckdev5icb005dj1wt2p0pf3wg","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckdev5icc005hj1wtebij2ppx"},{"post_id":"ckhm46dvb0000b6wt22376obe","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckhm46dvn0006b6wte2o07d2l"},{"post_id":"ckhm46dvj0002b6wt4gajdl6l","category_id":"ckdev5ia30003j1wt4qhy8937","_id":"ckhm46dvo0009b6wtck1fdnzy"},{"post_id":"ckhm46dvm0005b6wt848udwy0","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckhm46dvp000bb6wt8ldy0h6n"},{"post_id":"ckhm46dvn0008b6wt3lrw0ypk","category_id":"ckdev5iba0036j1wt88u62045","_id":"ckhm46dvp000cb6wtgsz27tgw"}],"PostTag":[{"post_id":"ckdev5i9z0001j1wt1e7i0z10","tag_id":"ckdev5ia50004j1wt7aokayez","_id":"ckdev5iaf000hj1wte89r6ze8"},{"post_id":"ckdev5i9z0001j1wt1e7i0z10","tag_id":"ckdev5ia80009j1wt2d2hav8w","_id":"ckdev5iag000kj1wtd1pkb7y4"},{"post_id":"ckdev5ia20002j1wtbfroc186","tag_id":"ckdev5iad000ej1wtaveve9cn","_id":"ckdev5iah000oj1wt54u89a11"},{"post_id":"ckdev5ia60006j1wt7zpwcsrj","tag_id":"ckdev5iad000ej1wtaveve9cn","_id":"ckdev5ial0010j1wt2aol9cuj"},{"post_id":"ckdev5ial0011j1wt6aws70y1","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ian0016j1wtg40v1zie"},{"post_id":"ckdev5ia70007j1wt4xqvhqbw","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5iao0019j1wt7qoi3t9z"},{"post_id":"ckdev5iab000aj1wt5nyi8axe","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5iaq001dj1wtcmxk1kxb"},{"post_id":"ckdev5iac000bj1wt8det7fic","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ias001jj1wt4gg3huiz"},{"post_id":"ckdev5ias001kj1wt9h368ncw","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5iau001pj1wt8yuq16av"},{"post_id":"ckdev5iae000fj1wtdgwb019b","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5iav001sj1wt8xgbdyyh"},{"post_id":"ckdev5iau001qj1wt8gok0aql","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5iaw001wj1wtdfgcd9uq"},{"post_id":"ckdev5iaf000ij1wt5n1wh1hr","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5iax001zj1wtb4nu35at"},{"post_id":"ckdev5iag000mj1wt5dvzhkd1","tag_id":"ckdev5iav001vj1wtau222x58","_id":"ckdev5iaz0025j1wthnvk1qhx"},{"post_id":"ckdev5iay0020j1wt0bmo3za4","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ib00028j1wtfq7g2cjg"},{"post_id":"ckdev5iah000pj1wt3k2n04j0","tag_id":"ckdev5iay0022j1wt8zzpfrd2","_id":"ckdev5ib2002cj1wt5hzqfvt8"},{"post_id":"ckdev5iai000sj1wth0hxhc9t","tag_id":"ckdev5iav001vj1wtau222x58","_id":"ckdev5ib4002ij1wt7tmy292m"},{"post_id":"ckdev5iaj000vj1wth4n56w1e","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ib6002oj1wt5riwa7el"},{"post_id":"ckdev5ib5002mj1wt746sgyqt","tag_id":"ckdev5iad000ej1wtaveve9cn","_id":"ckdev5ib7002sj1wt1swo19rc"},{"post_id":"ckdev5iak000yj1wth5ya71ar","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ib8002wj1wtgky0didx"},{"post_id":"ckdev5ib7002tj1wt9fs16ny3","tag_id":"ckdev5ia80009j1wt2d2hav8w","_id":"ckdev5ib8002zj1wtervlbmhv"},{"post_id":"ckdev5iam0013j1wtb1780le9","tag_id":"ckdev5ib7002rj1wtgoz9dnzp","_id":"ckdev5iba0033j1wt71ap249t"},{"post_id":"ckdev5ian0017j1wtcpic30xg","tag_id":"ckdev5ib7002rj1wtgoz9dnzp","_id":"ckdev5ibc003aj1wt5efuhvqf"},{"post_id":"ckdev5iao001aj1wtd6zugto5","tag_id":"ckdev5ib7002rj1wtgoz9dnzp","_id":"ckdev5ibe003hj1wt69hf57t8"},{"post_id":"ckdev5iaq001ej1wt0bcmgy3d","tag_id":"ckdev5ib7002rj1wtgoz9dnzp","_id":"ckdev5ibg003nj1wtcci492w9"},{"post_id":"ckdev5iar001gj1wt66dwan10","tag_id":"ckdev5ibf003kj1wt15bthvct","_id":"ckdev5ibi003tj1wtgzf3ef0m"},{"post_id":"ckdev5ibi003uj1wt5ufw4c84","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ibj003yj1wt45qmgxt9"},{"post_id":"ckdev5iat001mj1wtbtgibcqz","tag_id":"ckdev5ib7002rj1wtgoz9dnzp","_id":"ckdev5ibj0040j1wt3nwb1iip"},{"post_id":"ckdev5iav001tj1wtgt4h7g28","tag_id":"ckdev5ibj003xj1wt2c7p3mn7","_id":"ckdev5ibk0044j1wthogc6c63"},{"post_id":"ckdev5iaw001xj1wtanu15md3","tag_id":"ckdev5ibj0042j1wtgrk602po","_id":"ckdev5ibk0048j1wt1glpamea"},{"post_id":"ckdev5iaz0023j1wt85i3gsi4","tag_id":"ckdev5ibj0042j1wtgrk602po","_id":"ckdev5ibl004aj1wt0n134nbv"},{"post_id":"ckdev5iaz0026j1wt26533unv","tag_id":"ckdev5ibj003xj1wt2c7p3mn7","_id":"ckdev5ibm004cj1wt5lwa88ux"},{"post_id":"ckdev5iaz0026j1wt26533unv","tag_id":"ckdev5iad000ej1wtaveve9cn","_id":"ckdev5ibm004dj1wtbn0vf79n"},{"post_id":"ckdev5ib1002aj1wt4gv34vl0","tag_id":"ckdev5ibj003xj1wt2c7p3mn7","_id":"ckdev5ibm004fj1wt75mzhco9"},{"post_id":"ckdev5ib1002aj1wt4gv34vl0","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5ibm004gj1wtff7q70qi"},{"post_id":"ckdev5ib2002dj1wtet0f3ae0","tag_id":"ckdev5ibj003xj1wt2c7p3mn7","_id":"ckdev5ibn004jj1wt1m02eycc"},{"post_id":"ckdev5ib2002dj1wtet0f3ae0","tag_id":"ckdev5ib7002rj1wtgoz9dnzp","_id":"ckdev5ibn004kj1wt3c6c1f9u"},{"post_id":"ckdev5ib3002gj1wt9erh2v3k","tag_id":"ckdev5ibf003kj1wt15bthvct","_id":"ckdev5ibo004mj1wtcv2ubuu6"},{"post_id":"ckdev5ib4002jj1wt566u738s","tag_id":"ckdev5ibn004lj1wt2mjw7p43","_id":"ckdev5ibo004oj1wt1tg554ub"},{"post_id":"ckdev5ib6002pj1wt04le11oc","tag_id":"ckdev5ibo004nj1wtczmh3qr1","_id":"ckdev5ibp004qj1wt2oebbaco"},{"post_id":"ckdev5ib8002xj1wt8jmf1cro","tag_id":"ckdev5ibj003xj1wt2c7p3mn7","_id":"ckdev5ibp004sj1wtfdlmgir5"},{"post_id":"ckdev5ib90031j1wt6u6zazzf","tag_id":"ckdev5ibp004rj1wt01pq7tdg","_id":"ckdev5ibq004uj1wt1v4ff4sl"},{"post_id":"ckdev5iba0034j1wt9x7j1rxm","tag_id":"ckdev5ibj003xj1wt2c7p3mn7","_id":"ckdev5ibq004wj1wt1osze2xi"},{"post_id":"ckdev5ibc003bj1wt8j359qwi","tag_id":"ckdev5ibq004xj1wtbmiv07d6","_id":"ckdev5ibr0050j1wtbvii7lyg"},{"post_id":"ckdev5ibd003ej1wtgq7w74t2","tag_id":"ckdev5ibp004rj1wt01pq7tdg","_id":"ckdev5ibr0052j1wt8d1n0ym2"},{"post_id":"ckdev5ibe003ij1wt3hcv6de1","tag_id":"ckdev5ibr0051j1wt2z36bjea","_id":"ckdev5ibs0055j1wt3eo3hdf8"},{"post_id":"ckdev5ibf003lj1wtbxjyejqs","tag_id":"ckdev5ibs0054j1wtcv9ighcw","_id":"ckdev5ibu0058j1wt0spi1lxe"},{"post_id":"ckdev5ibg003oj1wtg77g4wd2","tag_id":"ckdev5ibs0057j1wt9es6axpx","_id":"ckdev5ibv005aj1wtdloth50r"},{"post_id":"ckdev5ibh003qj1wt4q0ta2kb","tag_id":"ckdev5ibr0051j1wt2z36bjea","_id":"ckdev5ibv005bj1wt3m06ff2m"},{"post_id":"ckdev5ica005cj1wtcfyj6gjr","tag_id":"ckdev5ibs0054j1wtcv9ighcw","_id":"ckdev5icb005ej1wt6yedclak"},{"post_id":"ckdev5icb005dj1wt2p0pf3wg","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckdev5icc005fj1wtdkc74zcw"},{"post_id":"ckhm46dvb0000b6wt22376obe","tag_id":"ckdev5ibp004rj1wt01pq7tdg","_id":"ckhm46dvl0003b6wt7ymhfwid"},{"post_id":"ckhm46dvj0002b6wt4gajdl6l","tag_id":"ckdev5iak000xj1wteryweb3a","_id":"ckhm46dvm0004b6wt6h4i7r2i"},{"post_id":"ckdev5ibb0038j1wtbug73v9u","tag_id":"ckhm46dvc0001b6wt4cbm1v58","_id":"ckhm46dvn0007b6wtbzy4cckb"},{"post_id":"ckhm46dvm0005b6wt848udwy0","tag_id":"ckhm46dvo000ab6wtespu2exm","_id":"ckhm46dvp000eb6wtcqxeez0j"},{"post_id":"ckhm46dvn0008b6wt3lrw0ypk","tag_id":"ckhm46dvp000db6wth56ud24d","_id":"ckhm46dvp000fb6wtfsh39bqn"}],"Tag":[{"name":"PWA","_id":"ckdev5ia50004j1wt7aokayez"},{"name":"Safari","_id":"ckdev5ia80009j1wt2d2hav8w"},{"name":"HTTP","_id":"ckdev5iad000ej1wtaveve9cn"},{"name":"Javascript","_id":"ckdev5iag000lj1wtaicz6ffk"},{"name":"JavaScript","_id":"ckdev5iak000xj1wteryweb3a"},{"name":"HTML","_id":"ckdev5iav001vj1wtau222x58"},{"name":"React.js","_id":"ckdev5iay0022j1wt8zzpfrd2"},{"name":"Vue.js","_id":"ckdev5ib7002rj1wtgoz9dnzp"},{"name":"NPM","_id":"ckdev5ibf003kj1wt15bthvct"},{"name":"前端","_id":"ckdev5ibj003xj1wt2c7p3mn7"},{"name":"CSS","_id":"ckdev5ibj0042j1wtgrk602po"},{"name":"Node.js","_id":"ckdev5ibn004lj1wt2mjw7p43"},{"name":"工作","_id":"ckdev5ibo004nj1wtczmh3qr1"},{"name":"Linux","_id":"ckdev5ibp004rj1wt01pq7tdg"},{"name":"云服务","_id":"ckdev5ibq004vj1wt0f3m3vsd"},{"name":"CheatSheet","_id":"ckdev5ibq004xj1wtbmiv07d6"},{"name":"记录","_id":"ckdev5ibr0051j1wt2z36bjea"},{"name":"路由器","_id":"ckdev5ibs0053j1wtfcfx29q1"},{"name":"工具","_id":"ckdev5ibs0054j1wtcv9ighcw"},{"name":"WSL","_id":"ckdev5ibs0057j1wt9es6axpx"},{"name":"概念","_id":"ckhm46dvc0001b6wt4cbm1v58"},{"name":"Edge","_id":"ckhm46dvo000ab6wtespu2exm"},{"name":"UWP","_id":"ckhm46dvp000db6wth56ud24d"}]}}