{"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"Async&#x2F;await和Promise的一些区别","text":"先说说PromisePromise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。 一个 Promise有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。（与rejected统称为settled状态） rejected: 意味着操作失败。 Javascript中的promise代表一种 已经发生 的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”箭头方法”: f = () =&gt;表达式 创建惰性求值的表达式，使用 f() 求值。 Promise常用的方法有： all: 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。 race: 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 reject: 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法. resolve: 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。 注意：Promise直接执行的是宏任务，只有.then和.catch是微任务! 再说Async/awaitasync function 用来定义一个 返回 AsyncFunction 对象 的异步函数。异步函数是指通过事件循环异步执行的函数，它会 通过一个隐式的 Promise 返回其结果 (如果不是通过await返回，那么返回的是一个Promise，返回值为resolve的值）。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。 异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。 记住，await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。 注意，当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式Promise) async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await更像结合了generators和 promises。 使用async时要注意，如果同时操作多个异步方法，要注意调用的写法： 123456789101112131415161718192021222324252627282930var sequentialStart = async function() { console.log('==SEQUENTIAL START=='); // 1. Execution gets here almost instantly const slow = await resolveAfter2Seconds(); console.log(slow); // 2. this runs 2 seconds after 1. const fast = await resolveAfter1Second(); console.log(fast); // 3. this runs 3 seconds after 1.}var concurrentStart = async function() { console.log('==CONCURRENT START with await=='); const slow = resolveAfter2Seconds(); // starts timer immediately const fast = resolveAfter1Second(); // starts timer immediately // 1. Execution gets here almost instantly console.log(await slow); // 2. this runs 2 seconds after 1. console.log(await fast); // 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved}var parallel = async function() { console.log('==PARALLEL with await Promise.all=='); // Start 2 \"jobs\" in parallel and wait for both of them to complete await Promise.all([ (async()=&gt;console.log(await resolveAfter2Seconds()))(), (async()=&gt;console.log(await resolveAfter1Second()))() ]);} 那么async/await相比于Promise的区别（优势）？ 代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担 Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅 错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余 调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。","link":"/2019/08/19/fe/async-await%E5%92%8Cpromise%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"},{"title":"CSS 相关知识点总结","text":"BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box 参与（在下面有解释）， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 满足下列条件之一就可触发BFC根元素，即 HTML元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption 未完待续从Ghost迁移出来的源文件丢失了所有MD标记……坑","link":"/2019/08/11/fe/css-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"HTML 相关知识点总结","text":"HTML 语义化语义化即“用正确的标签做正确的事“，通过使用正确的标签使页面内容结构化，便于浏览器解析和搜索引擎爬取，目前的现代浏览器对不同的标签有预置的样式，能够在没有样式的情况下展示正确的结构。 HTML5 文件类型声明（&lt;!DOCTYPE&gt;）仅有一型：。 新的解析顺序：不再基于SGML。 新的元素：section, video, progress, nav, meter, time, aside, canvas, command, datalist, details, embed, figcaption, figure, footer, header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary, wbr。 input元素的新类型：date, email, url等等。 新的属性：ping（用于a与area）, charset（用于meta）, async（用于script）。 全域属性：id, tabindex, repeat。 新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。 移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike, tt。 新应用程序接口（API）除了原先的DOM接口，HTML5增加了更多样化的API: HTML Geolocation HTML Drag and Drop HTML Local Storage HTML Application Cache HTML Web Workers HTML SSE HTML Canvas/WebGL HTML Audio/Video","link":"/2019/08/11/fe/html-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"HTTP状态码","text":"2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理204 No content，表示请求成功，但响应报文不含实体的主体部分206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL302 found，临时性重定向，表示资源临时被分配了新的 URL303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况307 temporary redirect，临时重定向，和302含义相同 4XX 客户端错误 400 bad request，请求报文存在语法错误401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息403 forbidden，表示对请求资源的访问被服务器拒绝404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 作者：yck链接：https://juejin.im/post/5872309261ff4b005c4580d4来源：掘金","link":"/2019/08/19/fe/http%E7%8A%B6%E6%80%81%E7%A0%81/"},{"title":"HTTP的缓存机制","text":"缓存用来做什么？缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。 缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。 虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。 HTTP中的缓存控制HTTP/1.1定义的 Cache-Control 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。 禁止缓存: Cache-Control: no-store 强制确认缓存: Cache-Control: no-cache 私有缓存和公共缓存: Cache-Control: private/public 缓存过期机制: Cache-Control: max-age=31536000 缓存验证确认: Cache-Control: must-revalidate","link":"/2019/08/19/fe/http%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"iOS Safari何时才能更好的支持PWA？","text":"写在前面最近由于疫情的原因，找工作是越来越难了，自己的工作时间也很尴尬，三年不足，一年有余，反思自己，觉得应该在现在的时间多学些东西，同时督促自己提高效率，就想到了“番茄工作法”，想找一个App来配合使用，看到了一个叫”FocusList”的工具，很简洁，支持macOS + iOS，但是价格让我望而却步，简单的功能也需要近15元，还不包括macOS，而且作者上一次版本更新还是在一年前，现在的macOS三天一小更新，五天一大更新，付费最担心的莫过于后面的系统支持不好。正好最近想练下React Hooks，决定自己仿照App实现一个番茄计时，加入PWA和Web提醒功能，噩梦就这么来了。 MDN的官方写法在MDN的通过通知推送让 PWA 可重用“”一文中，给出了规范的写法，这里提到Notification的requestPermission是一个Promise对象，因此，可以用如下写法提示用户打开推送许可： 12345Notification.requestPermission().then(function(result) { if(result === 'granted') { randomNotification(); }}); OK，这种写法很简洁，也非常容易在业务里实现，部署到HTTPS的域名下试试效果，Chrome（macOS）下完美。 再用Safari（macOS）打开，错误，emmm，看到报错：undefined is not an object (evaluating 'Notification.requestPermission().then')，了解，应该是Safari需要兼容，也许是实现不同，通过查阅文档果然，Safari是通过Callback实现的，也就是说，这段代码应该改为： 123456789101112131415try { Notification.requestPermission() .then(() =&gt; doSomething())} catch (error) { // Safari doesn't return a promise for requestPermissions and it // throws a TypeError. It takes a callback as the first argument // instead. if (error instanceof TypeError) { Notification.requestPermission(() =&gt; { doSomething(); }); } else { throw error; }} 通过这种改造，ok，macOS上的Safari能够正常请求允许并发送通知了，很不错。 iOS与macOS —— 区别对待本以为到这里已经结束了，但万万没想到的是，iOS对PWA的支持是 有限的 , 在iOS上，压根就没有Notification这个对象，也就是说，如果想兼容iOS设备，就要先做一个判断： 12345678910111213141516if(typeof Notification === 'undefined') return; // Without Notification, code below will throw error.try { Notification.requestPermission() .then(() =&gt; doSomething())} catch (error) { // Safari doesn't return a promise for requestPermissions and it // throws a TypeError. It takes a callback as the first argument // instead. if (error instanceof TypeError) { Notification.requestPermission(() =&gt; { doSomething(); }); } else { throw error; }} 踩过坑，就要知道iOS究竟实现了PWA的哪些部分，查阅资料，总结下来 至今仍未支持的功能 有： 创建应用程序加载屏幕 使用推送通知 添加离线支持（iOS会在指定时间清除AppCache，因此，离线支持不是永久可用的。） 创建一个初始的应用程序UI来实现即时加载 通过浏览器引导对话框，提示安装到主屏幕 所以，到这里我终于明白为什么iOS市场会有一些功能很简单但是需要付费的软件了，生态闭环，封闭了一些功能，使得开发者 不得不 采用不同的方式来实现。 这也是PWA迄今为止仍无法大范围普及的原因，功能缺失，是不能作为App的 替代 来完成使用的。 而小程序，能够通过宿主平台的能力（推送、缓存、以及账户共享等等），完成PWA很早就期望的一些能力，因此，小程序是目前相对“Lite”的应用形式。 另外一种推送方式是FCM，即Firebase Cloud Messaging，它需要一个完全唯一的用户设备ASN，但是通过Web的方式，我们不能够获得这种ASN，因此这一条路也是不通的。 Apple，何时才能做出改变？谷歌相关问题，就能够发现很多相关的提问。距离iOS开始支持standalone模式的PWA已经过去了一年多的时间（从iOS12.2发布算起，发布的时间是2019年3月25日），其实我想对于Apple而言，技术不是问题，核心问题是PWA可能会给AppStore带来或多或少的影响，这从根本影响了Apple支持PWA的愿望。","link":"/2020/04/14/fe/ios-safari%E4%BD%95%E6%97%B6%E6%89%8D%E8%83%BD%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%94%AF%E6%8C%81pwa/"},{"title":"Javascript 基础知识点总结","text":"五种基础类型（ES5后6种） number string boolean undefined null Symbol 对象（Object）。其中对象类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date）。 类型判断 typeof 返回值 instanceof 操作符 Object.prototype.toString获取 [[class]](准确) 关于函数函数声明 function foo(){}函数表达式 var foo = function () {} 区别 函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值 函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式1234567891011var getName//变量被提升，此时为undefinedgetName()//oaoafly 函数被提升 这里受函数声明的影响，虽然函数声明在最后可以被提升到最前面了var getName = function() { console.log('wscat')}//函数表达式此时才开始覆盖函数声明的定义getName()//wscatfunction getName() { console.log('oaoafly')}getName()//wscat 这里就执行了函数表达式的值 函数优化如果我们的代码中返回多个闭包的情况，如果没有手动设置null的话，内存不会被自动释放。 立即执行函数 &amp; 匿名函数在一个表达式后面加上括号()，该表达式会立即执行, 但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。 闭包首先了解一个JavaScript变量的作用域,无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，在函数外部自然无法读取函数内的局部变量。但是通过闭包，可以在函数外面访问到内部的变量！比如: 123456function f1(){ var n=999; function f2(){ alert(n); // 999 }} 事件监听这两种方式确定了事件执行的前后顺序，只不过后来W3C对DOM2的事件模型给出了一个规范[http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/]：首先进入事件捕获阶段-&gt;达到元素后-&gt;进入事件冒泡阶段。 原型继承在Javascript中，每个函数都有一个原型属性prototype指向函数自身的原型，而由这个函数创建的对象也有一个__proto__属性指向这个原型，而函数的原型是一个对象，所以这个对象也会有一个__proto__指向自己的原型，这样逐层深入直到Object对象的原型(null)，这样就形成了原型链。 This除了DOM的事件回调或者提供了执行上下文（后面会提到）的情况，函数正常被调用（不带new）时，里面的this指向的是全局作用域。还有个例外，就是使用了&quot;use strict&quot;;。此时this是undefined。当用调用函数时使用了new关键字，此刻this指代一个新的上下文，不再指向全局this。注意原型链底层函数中对this的操作会覆盖上层的值。解决方法就是传递的时候使用bind方法显示指明上下文，bind方法是所有函数或方法都具有的。同时也可以使用apply或call来调用该方法或函数，让它在一个新的上下文中执行。在DOM事件的处理函数中，this指代的是被绑定该事件的DOM元素。除非你通过bind人为改变了事件处理器的执行上下文。 对象我们说的通过引用进行对象比较是:两个对象的值是否相同取决于它们是否指向相同的底层对象。","link":"/2019/08/11/fe/javascript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"JavaScript的原型链与继承","text":"感谢JS原型链与继承别再被问倒了 - 路易斯@juejin JavaScript的继承继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的. 构造函数、原型和实例 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针. 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性. 所以我们有constructor1.prototype = instance2 如果试图引用constructor1构造的实例instance1的某个属性p1:1).首先会在instance1内部属性中找一遍;2).接着会在instance1.proto(constructor1.prototype)中找一遍,而constructor1.prototype 实际上是instance2, 也就是说在instance2中寻找该属性p1;3).如果instance2中还是没有,此时程序不会灰心,它会继续在instance2.proto(constructor2.prototype)中寻找…直至Object的原型对象","link":"/2019/08/21/fe/javascript%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"title":"JavaScript的模块机制","text":"目前，JavaScript生态下最常见的模块机制大致分为以下四种： AMD CMD CommonJS ES6 Module 下面逐个分析每个机制的特点。 CommonJS 环境：Node.js 全局方法：require(module) &amp; exports || module.exports exports 与 module.exports在Node.js环境中，exports, require, module都是node的全局对象，exports是module.exports的引用。 AMD(“Asynchronous Module Definition”) 环境：Browser 全局方法：require([module], callback) 这里需要注意，所有的浏览器环境的模块化机制，都要避免同步引入，因为不同于服务端可以直接进行磁盘读取，很快即可使用对应模块，浏览器端需要异步请求，否则会造成假死的状态。因此， 浏览器端的模块化机制都是异步加载的 。 AMD规范通过回调机制实现了异步加载，在加载完成后执行callback。 CMD(“Common Module Definition”) 环境：Browser(Sea.js) 全局方法：define() &amp; seajs.use() ES6 Modules 环境：Browser(目前工具通过工具已经支持Node.js) 全局方法：export &amp; import 与CommonJS最主要有两点区别 ES6模块输出的是值的引用，输出接口动态绑定，而 CommonJS 输出的是值的拷贝； ES6模块编译时执行，而 CommonJS 模块总是在运行时加载。 export的使用123export const firstName = \"Michael\";// const firstName = \"Michael\";// export { firstName }; // 不能直接export firstName是因为export需要导出一个“接口”而不能是一个值。 export default为模块指定默认输出，如果import接口时，可以用任意名称指向export default输出的方法","link":"/2020/03/17/fe/javascript%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6/"},{"title":"JavaScript面向对象编程(ES6版本)","text":"写在最前面，为什么已经入行一年半才写这样一篇文章呢？其实并不是自己平时开发没有使用，但是很多时候自己的代码会有些“四不像”，各种风格糅杂在一起，因此写这么一篇文章，从编程范式的角度规范自己的代码。 面向对象的特性面向对象就要提到以下的“名词”，那么JavaScript应该如何实现这些呢？ 类与对象 封装性 继承 多态 抽象性 类与对象 基于原型的编程不是面向对象编程中体现的风格，且行为重用（在基于类的语言中也称为继承）是通过装饰它作为原型的现有对象的过程实现的。这种模式也被称为弱类化，原型化，或基于实例的编程。 而在JavaScript中，实现的方式就是通过函数内置的Prototype属性完成这种 原型继承 。 对象JavaScript内的对象，其实就是Object，那么Object有两种方法可以用来创建： 12var Person = {}; // 字面量var Person = new Object(); // 使用new运算符 那么他们有什么区别呢？首先要说的就是new，new做了哪些呢？这里引用MDN的解释： 创建一个空的简单JavaScript对象（即{}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤1新创建的对象作为this的上下文 ； 如果该函数没有返回对象，则返回this。 不难发现，new的第一步其实和字面量方式完全一致，所以，new运算符的链接与设定this其实是最核心的不同点。 我们一般不常用new Object()，而直接用字面量方式的原因，其实是因为他们的prototype都指向了null。 正是因为这样，我们在日常的使用中，如果希望通过OOP实现逻辑，应该通过new的方式来进行，因为他可以继承我们期望的对象。 代码风格JavaScript有很多的引用类型数据，因此在面向对象时，要注意分离自有的部分与暴露的方法。 12345678function Person (name){ this.name = name;}Person.prototype.sayIntro = function() { return 'Hello, my name is ' + name + '.'}var person1 = new Person('peter'); // Person是一个构造器。person1.sayIntro(); // 为什么可以调用prototype上的方法呢？参见“原型链” Object.create() Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 Object.create()是ES2015规范内的新方法，同时在ES5.1进行了加强，它可以polyfill使得我们可以在生产中尽可能使用来让我们的代码更为清晰。 其内部核心的实现其实在JS高程有对应的代码： 123456// 在自己的实现里要注意当前环境是否支持create，以及目标是否可以作为create的对象。Object.create = function (proto, propertiesObject) { function F() {} F.prototype = proto; return new F();}; 那么如果使用Object.create应该如何实现继承呢？下面是MDN的一个例子： 123456789101112131415161718192021// Shape - 父类(superclass)function Shape() { this.x = 0; this.y = 0;}// 父类的方法Shape.prototype.move = function(x, y) { this.x += x; this.y += y; console.info('Shape moved.');};// Rectangle - 子类(subclass)function Rectangle() { Shape.call(this); // call super constructor.}// 子类续承父类Rectangle.prototype = Object.create(Shape.prototype); // create的目标是父类的prototype，注意，JS的继承是原型继承。Rectangle.prototype.constructor = Rectangle; // 修复constructor指向 上面是一个单继承的例子，如果我们希望做多继承，其实只需要修改Rectangle.prototype，让其的赋值为其多继承的对象的prototype的合并(Object.assign)。需要注意需要在子类内部显式绑定this。 类ES6最大的变化就是对Class的支持，虽然JS只能通过原型继承，但是Class的出现使得JS的OOP“看起来更像那么回事了”。 为什么说看起来呢？目前还没有实现私有与公有特性，它只是原来构造模式的一个语法糖，但是，它也有它的不同之处。 Class内部只是原型的实现，在实际使用时还是需要通过new运算符执行构造函数； 类声明不能被提升； 类声明中的代码自动运行在严格模式下； 类中的所有方法都是不可枚举的 ； 每个类都有一个[[construct]]的方法，constructor方法默认返回实例对象（即this）； 派生类1class HelloWorld extends React.Component {} 上面这种写法在React的开发中非常常见，extends是一个派生类， 在派生类中，如果使用了构造方法，就必须使用super() ，在构造函数中访问this之前要调用super()， 负责初始化this 。 123456789101112class Shape { constructor(x, y) { this.x = x; this.y = y; }}class Rectangle extends Shape { constructor() { super(); // 这里的super可以作为函数，也可以作为特殊的对象（无法直接输出，但是可以设置属性）。 }} 继承见上面对“类与对象”内继承的实现，核心在于prototype 原型继承模式 。 抽象 抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。 JavaScript Function 类继承自Object类（这是典型的具体化） 。Function.prototype的属性是一个Object实例（这是典型的组合）。 多态其实多态并没有太多好说的，核心在于“原型链”：如果你在子类声明了同名的属性和方法，那么就不会在原型链上向上查找。","link":"/2020/03/15/fe/javascript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-es6%E7%89%88%E6%9C%AC/"},{"title":"JS中的异步链式调用","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657let EatMan = function () { this.task = [] // 声明一个task数组，模拟事件循环队列； this.taskNum = [] let fn = () =&gt; { this.next(); } this.task.push(fn); setTimeout(() =&gt; { this.next(); }, 0) return this;}EatMan.prototype.eat = function (str) { // 为了task任务队列一致性，将eat也转换为setTimeout异步 const _this = this var fn = () =&gt; { setTimeout(() =&gt; { console.log(str) _this.next() }, 0) } this.task.push(fn) this.taskNum.push(str) return this // 返回this使得可以链式操作}EatMan.prototype.sleep = function (ms) { // setTimeout的任务，需要在完成时再调用next继续执行 const _this = this var fn = () =&gt; { setTimeout(() =&gt; { console.log('this is normal sleep.') _this.next() }, ms * 1000) } this.task.push(fn) this.taskNum.push('sleep') return this}EatMan.prototype.firstSleep = function (ms) { // 与sleep类似，注意需要在队首加入 const _this = this var fn = () =&gt; { setTimeout(() =&gt; { console.log('this is first sleep.') _this.next() }, ms * 1000) } this.task.unshift(fn) this.taskNum.unshift('firstSleep') return this}EatMan.prototype.next = function () { // 通过next指针完成出队列操作，使之拥有顺序 let fn = this.task.shift() fn &amp;&amp; fn()}let eatMan = new EatMan()eatMan.eat('apple').eat('orange').sleep(3).eat('banana').firstSleep(3)console.log(eatMan.taskNum)","link":"/2020/02/16/fe/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"},{"title":"meta标签的使用","text":"平时使用时最常见的用法： 1&lt;meta charset=\"UTF-8\"&gt; 但是通过meta我们可以实现很多特别的功能。 meta是什么 The tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable. 换句话来说，就是页面里对用户不可见，但是可供浏览器解析的页面信息。 meta的类型http-equiv这一类使用格式为&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt; content-Type可以设置html的字符集和格式，但是被&lt;meta charset=&quot;utf-8&quot;&gt;取代 X-UA-Compatible设置浏览器渲染模式，一般采取最新的： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; cache-control设置浏览器缓存，一般设置为&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;可设置为以下属性： no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。 no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施） public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果 private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应） maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 no-siteapp: 禁止百度默认的移动端转码。 expires设置网页过期时间，超时需要重新从服务器获取。 1&lt;meta http-equiv=\"expires\" content=\"Sunday 26 October 2016 01:00 GMT\" /&gt; refresh网页将在设定的时间内，自动刷新并调向设定的网址。 1&lt;meta http-equiv=\"refresh\" content=\"2;URL=https://blog.sparkinglemon.me\"&gt; 设置为2s后自动转向到网址 Set-Cookie配置页面cookie namename属性的配置格式 1&lt;meta name=\"参数\" content=\"具体的描述\"&gt; keywords设置页面关键词，SEO收录常用 description页面描述，SEO常用 viewport移动端 设置视口。后续会在移动端适配详细补充。 robots告知爬虫具体需要爬取的页面，默认是all ，可以设置none，noindex（非本页），nofollow（通过本页索引其他页） author页面作者，不常用 generator页面制作于 copyright页面版权信息 revisit-after设置爬虫重访时间 部分内容参考了 Lxxyx-“HTML meta标签总结与属性使用介绍”","link":"/2019/08/16/fe/meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Node.js环境log颜色表","text":"Refer from: https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color 12console.log('\\x1b[36m%s\\x1b[0m', 'I am cyan') //cyanconsole.log('\\x1b[33m%s\\x1b[0m', stringToMakeYellow) //yellow 通过配置 log，达到实现不同颜色的目的，下面是一些常用的颜色 12345678910111213141516171819202122232425Reset = '\\x1b[0m'Bright = '\\x1b[1m'Dim = '\\x1b[2m'Underscore = '\\x1b[4m'Blink = '\\x1b[5m'Reverse = '\\x1b[7m'Hidden = '\\x1b[8m'FgBlack = '\\x1b[30m'FgRed = '\\x1b[31m'FgGreen = '\\x1b[32m'FgYellow = '\\x1b[33m'FgBlue = '\\x1b[34m'FgMagenta = '\\x1b[35m'FgCyan = '\\x1b[36m'FgWhite = '\\x1b[37m'BgBlack = '\\x1b[40m'BgRed = '\\x1b[41m'BgGreen = '\\x1b[42m'BgYellow = '\\x1b[43m'BgBlue = '\\x1b[44m'BgMagenta = '\\x1b[45m'BgCyan = '\\x1b[46m'BgWhite = '\\x1b[47m' addons: 在可以引用其他库的环境中，也可以使用inquirer，能够完成大部分情况比如： 错误回显 “提问”模式 输入格式化 回答校验 管理多重选项 用法详见npm","link":"/2019/08/11/fe/node-js%E7%8E%AF%E5%A2%83log%E9%A2%9C%E8%89%B2%E8%A1%A8/"},{"title":"OSI七层模型&amp;TCP&#x2F;IP四层模型","text":"OSI七层模型OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。 物理层（Physical Layer）：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。 数据链路层（Datalink Layer）：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。 网络层（Network Layer）：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议） 传输层（Transport Layer）：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。 会话层（Session Layer）：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 表示层（Presentation Layer）：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 应用层（Application Layer）： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 TCP/IP四层模型TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。 TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为： 应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。 传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。 网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。 网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。","link":"/2019/08/19/fe/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-tcp-ip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B/"},{"title":"React 组件中 state 和生命周期","text":"React的生命周期图谱v16.3和v16.4+版本的生命周期有着比较大的区别，感谢大神制作了一个React生命周期图谱 这里截图说明： constructor如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。 在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。 通常，在 React 中，构造函数仅用于以下两种情况：- 通过给 this.state 赋值对象来初始化内部 state。- 为事件处理函数绑定实例在 constructor() 函数中不要调用 setState() 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 this.state 赋值初始 state static getDerivedStateFromProps(props, state) getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 &lt;Transition&gt; 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。 请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。 shouldComponentUpdate 根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。 此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。 getSnapshotBeforeUpdate getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。 应返回 snapshot 的值（或 null）。 componentDidMount componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。 这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅 你可以在 componentDidMount() 里可以直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理 componentDidUpdate componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。 当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。 你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意 它必须被包裹在一个条件语件里 ，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。 componentWillUnmount componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。 componentWillUnmount() 中不应调用 setState()，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。","link":"/2019/08/18/fe/react-%E7%BB%84%E4%BB%B6%E4%B8%AD-state-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"script标签有几种写法","text":"script 标签有哪些属性 async defer integrity src type text crossorigin 区别如下 如图可知，async不影响页面解析过程，但是加载完成执行过程会终止parsing；而defer是在过程中加载，等到页面解析完成后才执行。 要注意，async无法确定顺序，比较适合不依赖dom结构的，而defer则是顺序执行 其他的方式 动态创建script标签 1234var script = document.createElement('script');script.type = \"text/javascript\";script.src = \"file1.js\";document.getElementByTagName(\"head\")[0].appendChild(script); 动态创建的script无论在何时执行创建，其源js均会在最后执行","link":"/2019/08/16/fe/script%E6%A0%87%E7%AD%BE%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/"},{"title":"&quot;Speaking JavaScript&quot;阅读笔记（一）","text":"写在前面由于疫情的原因，这次离职比以往多了许多准备和复习的时间，也能沉下心好好复习一下基础知识点，本篇是我自己在阅读“Speaking JavaScript”时做出的摘录与笔记，在整理的过程中会加入一些自己想到的代码示例，并综合《JavaScript高级程序设计（第3版）》整理，如果有一些错误欢迎在下方的Disqus评论区指正，感谢！ 为什么没有用最新的第四版高程呢？因为2019.10.16才正式有英文版，而且作者和第三版不是同一位……等到出了正式中文版再做一次补充吧 0. JavaScript背景知识0.1. JavaScript与ECMAScript的关系ECMAScript是JavaScript的官方命名，因为Java已经是一个商标。JavaScript指编程语言，ECMAScript是语言规范的名字。 0.2. ECMAScript历程 1th Edition (1997-01) 2th Edition (1998-08) 3th Edition (1999-12, 4th Edition has been abandoned at 2008-07) 5th Edition (2009-12) 6th Edition - ECMAScript 2015 7th Edition - ECMAScript 2016 8th Edition - ECMAScript 2017 9th Edition - ECMAScript 2018 10th Edition - ECMAScript 2019 ES.Next 1. JavaScript的一些特性1.1 语法类别：语句和表达式12var foo; // 语句, do something3 * 7 // 表达式, 产生“值” 常见的一种情形是：三目表达式 与 if-else块。 1.2 分号：建议使用分号用于结束语句，缺少的分号会通过分号自动插入机制(ASI)完成，什么是ASI呢？ ASI的目标是使分号对于行结束来说是可选的，也有说法是帮助解析器来确定语句的结束。 __但是，在以下的情况下也会认定为语句结束: __ 行结束符后（如换行符）跟着一个非法token； 遇到一个结束的花括号； 文件已达结尾； 12if(a&lt;0) a = 0console.log(a) // 0后跟console属于非法token 123456function foo(a, b) { return // return意味着会自动插入一个分号，下文不再执行 { a + b }} 1.3 变量名一个合法的变量名规则：第一个字符可以是任意的Unicode字符、美元符号($)、或者下划线( _ )，后面还可以是任意的Unicode数字。 ECMAScript中的一切都区分大小写。 但是保留字不能作为变量名，除保留字外以下变量也不建议： Infinity NaN undefined 1.4 值原始值： true、false 数字（均为浮点） 字符串 “空值”: undefined, null 除以上外，其他的值都是对象，特殊的，通过“装箱”我们可以得到非原始值的“字符串”、“布尔”、“数字”。 当复制引用类型的值的时候，会复制一份值的副本到新变量分配的空间中，然而，这个值的副本实际上是一个指针，指向存储在堆中的一个对象。 1.4.1 如何对值分类 typeof typeof主要用于原始值，除typeof null === 'object'外，其他都有正确的输出。 typeof null是一个不能修正的bug，因为这会破坏现有的代码。直到目前的标准也不能修改 instanceof instanceof主要用于对象，用来判断 value是否是一个通过Constr构造器创建的对象。 1.5 布尔值1.5.1 假值以下值会被解释为假值： undefined, null false -0 , NaN (经过测试，目前浏览器对+0，-0均判断为false) ‘’ 1.5.2 二元操作符JavaScript的二元逻辑运算符是 短路 的，也就是说我们可以利用这个特点优化代码，尽量将大概率发生的优先判断。 ‘&amp;&amp;’，’||’符号返回的是第一个运算数的 假（真）值 或者第二个运算数，也就是说其实际返回的是执行后的值。 1.6 数字JavaScript中的所有的数字都是浮点数。 1.7 字符串1.8 语句 多条件情况下，switch的运行效率要高于if-else； break可以跳离循环，continue会开始一个新的循环迭代，可以用来优化循环内的执行过程； 1.9 函数1.9.1 函数声明的提升特性注意与变量声明之间的区别，函数声明 的实体会被移动到所在作用域的开始处 。 而变量声明会变成如下的代码： 123var a; // undefinedconsole.log(a); // undefineda = 3; // 3 但是要注意函数声明与函数表达式不同，后者只符合变量声明的提升规则。 1234567console.log(a); // undefinedconsole.log(b); // Uncaught ReferenceError: b is not defined. stopped.var a = function b() { return 3;} console.log(a);console.log(b); 1.9.2 特殊变量arguments所有参数变量——arguments看起来像一个数组，但是却不具备数组的方法。(Array-like) 如果想将arguments转换为数组，代码如下： 1Array.prototype.slice.call(arrayLikeObject); 1.10 变量作用域一个变量的作用域总是完整的函数。 1.10.1 提升所有变量声明都会被提升，声明 会被移动到函数的开始处，而赋值仍然会在原来的位置。通常来说，优先提升var a;，然后再提升function a，然后再赋值。 1.10.2 闭包 闭包是指有权访问另一个函数作用域中的变量的函数。 —— JS高程(第3版),后文简称高程 一般外层函数内部存在一些变量，然后以返回一个函数的形式完成闭包，最常见的模式即“IIFE” 1.10.3 IIFE1234// 关于为什么这种写法可以完成IIFE，后续会补充在此。(function () { var foo = 'test'}()); 这里要注意闭包有时会存在并 保持 与外界变量的联系，如下： 123for(var i=0;i&lt;5;i++) { result.push(function () { return i; }) // result[1]()执行后仍然是i = 5赋值的时候} 与对象等有关的点单独总结一章详细说明","link":"/2020/02/27/fe/speaking-javascript-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80/"},{"title":"&quot;Speaking JavaScript&quot;阅读笔记（三）","text":"本章开始写函数与对象，内容相对较多单起一章专门记录 10. 函数JavaScript中的函数一共有三种形式： 非方法的函数（“普通函数”）； 构造器； 方法； 因此我们创建函数一共有三种： 通过函数表达式； 通过函数声明； 通过Function()构造器（不推荐）； 所有的函数都是对象、Function构造器的实例。 具名函数表达式只能在函数表达式的内部被访问。 在函数的内部，有两个特殊的对象，arguments和this。 this引用的值是函数数据以执行的环境对象——或者也可以说是this值。由于在调用函数之前，this的值并不确定，因此this可能会在代码执行过程中引用不同的对象。 ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。 10.1. 控制函数调用，call(), apply()和bind()bind()方法非原生，本节末尾会给出使用apply实现bind。 使用： 123func.apply(thisValue, argArray)func.call(thisValue, arg1, ..., argN)func.bind(thisValue, arg1, ..., argN) // 创建一个新函数，会调用func，再绑定this到新的thisValue 一个非常有趣的陷阱： 1['1', '2', '3'].map(parseInt) // [1, NaN, NaN] 这是因为parseInt只接受一个参数，map的期望函数签名function(element, index, array)，而parseInt的签名则是parseInt(string, radix?), 这会导致radix也被传入。 10.1.1 实现bind本节的实现来自JS高程 apply 12345function bind(fn, context) { return function () { return fn.apply(context, arguments); }} apply的柯里化版本 12345678function bind(fn, context) { var args = Array.prototype.slice.call(arguments, 2); return function () { var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(context, finalArgs); }} 11. 变量：作用域、环境和闭包 全局执行环境是最外围的一个执行环境，每个函数都有自己的执行环境，eval也会创建一个独立的执行环境。 11.1. 作用域JavaScript的变量是函数级作用域的，只有函数可以产生新的作用域。 JavaScript会提前所有的变量声明，它会把所有的声明移到直接作用域的最前面。 11.2. IIFE 它是立即执行的； 它必须是一个表达式； 连续的两个IIFE之间需要分号，不然会导致解析错误。 IIFE也可以前缀运算符，比如!, void都是可以的，避免了分号的问题。 123var File = function () { // open IIFE // do something...}(); // close IIFE 11.3. 全局对象全局对象是有原型的。 11.4. 环境无论一个函数被调用多少次，它总要访问它自己（最新）的本地变量和外部作用域的变量。当多次调用自己的时候，每次调用都会创建一个新的环境。 通过闭包可以使得函数可以维持其创建时所在的作用域。但如果创建时受到了当前作用域变量的影响，会存在环境公用的影响。 11.5. 垃圾收集两种垃圾收集机制，标记清除，引用计数，两种都有使用，标记清除更为常用，引用计数一般用于COM对象。 11.6. 闭包 闭包 是指有权访问另一个函数作用域中的变量的函数。 创建闭包的常见方式，就是在一个函数内部创建另一个函数。 闭包只能取得包含函数中任何变量的最后一个值。 11.7. 闭包中的this在闭包中使用this对象会导致一些问题，因为this对象是在运行时基于函数的执行环境绑定的。 如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。 12. 对象与继承JavaScript中的面向对象编程（OOP）分为以下几层： 第一层，单一对象的面向对象； 第二层，对象间的原型链； 第三层，作为实例工厂的构造函数，类似于其他语言的类； 第四层，子类，通过继承已有的构造函数，创建新的构造函数。 12.1. 第一层，单一对象的面向对象12.1.1 属性属性分为三种： 属性 访问器 内置属性（规范将内置属性的键置于方括号中，例如[[Prototype]]） delete只影响一个对象的直接“自有”的，非继承的属性，delete成功则返回true，如果是自有属性但不能删除则返回false。 12.1.2 对象字面量123456var jane = { name: 'jane', describe: function () { return 'Person named ' + this.name; }} 12.2. 第二层，对象间的关系——原型链123456789var proto = { describe: function () { return 'name: ' + this.name; }};var obj = { [[Prototype]]: proto, // 实际不可访问 name: 'obj'} 对象obj从proto继承了describe属性。 当通过obj访问属性时，JS首先从本对象中查找，接着是它的原型，以及它原型的原型。 在ES5后，我们可以通过Object.create(proto, propDescObj?)完成使用给定prototype创建新对象。 检测时，可以使用： 1Object.prototype.isPrototypeOf(obj); // 会检索整个链上 12.2.1 特殊属性proto某些JavaScript引擎有特殊属性可以获取和设置对象的原型：__proto__。这样可以直接访问[[Prototype]]。其在ES6内将会作为标准。 方法区分： Object.getOwnPropertyNames(obj) 返回obj的所有 自有 的属性键。 Object.keys(obj) 返回obj的所有 可枚举 的属性键。 12.3 访问器12345678var obj = { get foo() { // 取值调用，getter return 'getter'; }, set foo(value) { // 赋值调用，setter console.log('setter: '+value); }} 12.4 属性特性和属性描述符 Value Writable Get Set Enumerable Configurable 12.5 复制对象复制要保证： 拷贝必须具有与原对象相同的原型； 拷贝必须具有与原对象相同的属性和特性； 123456789101112131415function copyObject(orig) { // copy prototype var copy = Object.create(Object.getPrototypeOf(orig)); // copy all properties copyOwnPropertiesFrom(copy, orig); return copy;}function copyOwnPropertiesFrom(target, source) { Object.getOwnPropertyNames(source).forEach(function (propKey) { var desc = Object.getOwnProperyDescriptor(source, propKey); Object.defineProperty(target, propKey, desc); // 使用获取的属性描述符创建target的自有属性 }); return target;} 12.6 第三层，作为实例工厂的构造函数，类似于其他语言的类Speaking JavaScript内推荐的构造函数写法： 123456function Person(name) { this.name = name;}Person.prototype.describe = function () { return 'Person named ' + this.name;}; 经典面试内容：Q：new操作符都做了什么？A： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 引用类型与基本包装类型（“装箱”）的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。 Speaking JavaScript内对这个过程的描述： 首先设置行为：创建一个新对象，其原型为Person.prototype;然后设置数据：Person接受对象作为隐式参数this，并添加实例属性。 代码模拟如下: 12345678function newOperator(Constr,args) { var thisValue = Object.create(Constr.prototype); var result = Constr.apply(thisValue, args); if(typeof result === 'object' &amp;&amp; result !== null) { return result; } return thisValue;} 每个函数包含一个实例原型对象，它的constructor属性指回函数。 12.7 泛型方法：借用原型方法1Wine.prototyte.incAge.call(john, 3) // 类似于这样的模式 对于泛型方法，最常用的是处理一些“Array like”的元素，借用数组方法进行处理。 通过 Array.isArray 也可以作为数组的判断，能够区分Array-like。","link":"/2020/03/01/fe/speaking-javascript-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%89/"},{"title":"&quot;Speaking JavaScript&quot;阅读笔记（二）","text":"2. JavaScript相关的一些事2.1. JavaScript的性质 它是动态的； 它是动态类型； （即便引入TypeScript协助开发也只能协助推导类型。） 它是函数式和面向对象的； 3. JavaScript语言深入3.1 语句凡是在JavaScript期望语句的地方都可以写表达式，不能在需要表达式的地方使用语句。 如果使用二义表达式（语法类型是二义的），为了避免二义性，在解析过程中，JavaScript不能使用对象字面和函数表达式作为语句，即不能以下面的内容开头： ‘{}’； function关键词； (所以IIFE模式需要将匿名函数放在一个括号内，如果不使用这个括号， JS会认为这是一个函数声明，而函数声明是不可以匿名的，而函数定义又不能立即执行。) 3.2 数字刷题曾经遇到过一个这样的问题： 123456// 以下那种写法能够正确输出？1.toString() // 唯一一种不能正常输出的。1..toString()1 .toString()(1).toString()1.0.toString() 之所以存在这种问题，是因为JS内所有数字都是以浮点数存储的，这里紧跟的’.’会被认为是小数点。 4. 值 在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”，动态是指“运行时”。 4.1 强制转换JavaScript内置的转换机制只支持布尔值、数字、字符串和对象。 怪异的两个转换： Number(null) === 0 Number(undefined); // NaN 两个约定的转换方式： 乘法运算符会强制转换为数字； 加法运算中如果一个是字符串，运算符会将另一个运算数转换为字符串。 引擎内自带一个转换算法，ToPrimitive()，根据情景的不同偏好，先后完成： 如果输入的是原始值，返回； 如果输入是对象，偏好为数值，调用valueOf（偏好为字符串时优先调用toString)； 否则，调用toString（valueOf）； 否则，抛出一个TypeError。 4.2 nullnull表示 没有对象 。 null是原型链最顶端的元素。 1Object.getPrototypeOf(Object.prototype) // null 4.3 原始值的包装对象（装箱）布尔值，数字和字符串这三种原始值都有响应的构造函数。它们的实例包含原始值。原始值可以从包装器借调方法。 5. 运算符JavaScript中无法重载或自定义运算符，包括等号。 NaN与本身不相等（宽松 &amp; 严格）。 5.1 比较在比较包装实例和原始值的时候，原始值和包装的原始值是宽松相等的，（但两个相同的原始值它们的包装实例不相等） 6. 数字Number()在转换时一般优于parseFloat(), 原因： 对非字符串使用parseFloat效率较低，因为在解析之前它会将参数强制转换为字符串； parseFloat()会将空字符串解析成NaN； parseFloat()会一直解析到最后一个合法的字符，这意味着最后可能得到的不是想要的结果，比如parseFloat(123.45#) 7. 字符字符串是由JavaScript字符组成的不可变序列，其中每个字符是一个16位的UTF-16编码单元。（一个Unicode字符相当于一个或两个JavaScript字符） 优化：新版本JavaScript引擎通过加号+优化字符串拼接并在内部使用相似的方法（array.push()）。 8. 数组不要用for-in来遍历数组，因为for-in只会遍历索引，而不是数组元素，其次还会遍历所有的（非索引）属性值。 注意，for-in遍历对象所有的可枚举属性，其中包括了继承来的属性，因此需要判断是否为自身的： 12345for(var key in person) { if(Object.prototype.hasOwnProperty.call(person, key) { // 为了避免person自身有hasOwnProperty方法 console.log(key) }} 9. 错误处理对于异常捕获有两个原则：如果一处出错的含义不能被描述，那么就抛错；找到一个可以捕获错误的位置，捕获异常。 Error是通用的异常构造器，所有其他的异常构造器都是它的子构造器，因此我们可以自定义错误构造器。","link":"/2020/02/29/fe/speaking-javascript-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%8C/"},{"title":"&quot;Speaking JavaScript&quot;阅读笔记（附加篇）","text":"本篇开始将一部分浏览器与Node.js环境相关的知识点补充进来 超时与间歇调用 JavaScript是单线程语言（后期加入额外线程Worker） 需要注意的是，使用定时器对于队列而言，不是在指定时间立即执行，而是 在指定时间被加入到队列中 ，如果队列内没有其他任务，则表现为“立即执行” 如果在浏览器端，需要效果比较好的定时执行，可以通过rAF实现。 DocumentFragment使用DocumentFragment优化DOM操作。 浏览器的重绘与重排详见另一篇文章 事件现在使用MVVM框架多了，减少了直接操作事件，但是还是有必要列出复习的。 1. 事件流三个阶段： 事件捕获 处于目标 事件冒泡 2. DOM2级事件处理程序 addEventListener(eventName, fn, needCapture?) removeEventListener remove操作需要注意，fn不能是一个匿名函数，这时remove才有效。 3. 事件对象event对象通常包括以下： bubbles cancelable currentTarget defaultPrevented(DOM Level-3) detail eventPhase(处于流的阶段，1-捕获，2-处于目标，3-冒泡) preventDefault() (取消默认行为，注意区分) stopImmediatePropagation() (DOM Level-3) stopPropagation() (取消事件的进一步捕获或冒泡) target trusted type view 4. 事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 面试题： Q：用原生JS实现jQuery的on和off效果？ A: 5. 事件模拟可以用 document.createEvent 模拟一些鼠标或者键盘事件，但是需要实机测试，例如Chrome对模拟的点击事件就有比较严格的限制。 6. 拖放事件HTML5 新增的事件，可以用来作为一些特殊的交互，比如拖放上传等。 7. JSON注意，以下都是 合法的 JSON： 简单值 对象 数组 JSON.stringify(value[, replacer [, space]]) 可以通过传入第二个参数进行JSON过滤，第二个参数支持数组或者函数。第三个参数不常用，一般用于控制缩进。 XHR(XMLHttpRequest)状态值： 0，未初始化； 1，启动（已经调用open但是未send）； 2，发送； 3，接收； 4，完成。 1. FormData表单提交，可以上传文件。 2. Progress事件用于监测进度，可以用HTML5实现上传进度。 3. 跨域CORS 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 不会引发CORS的简单请求： 需要进行预检（Preflight）的请求： 携带身份凭证（Cookie）： 高级技巧：节流与防抖节流：节约流量——无论触发多少次，指定间隔内只能触发一次；防抖：防止抖动——中间触发N次都以最后一次开始计算时间，待指定间隔后触发。 数据存储1. CookieCookie数量限制不一，在20-50之间，尺寸一般在4096B 2. StoragelocalStorage一般会设置每个来源5MB，部分浏览器只有2.5MB； SessionStorage同样一般为5MB，部分浏览器为2.5MB； 3. IndexedDB &amp; WebSQL浏览器支持情况不定，需要根据具体需求使用。","link":"/2020/03/02/fe/speaking-javascript-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%99%84%E5%8A%A0%E7%AF%87/"},{"title":"Task, Job 与 EventLoop","text":"在解释事件循环前……1234567891011function foo(b) { var a = 10; return a + b + 11;}function bar(x) { var y = 3; return foo(x * y);}console.log(bar(7)); // 返回 42 这段代码存在这样的过程： console.log调用bar -&gt; 创建了第一个帧 bar调用foo -&gt; 创建了第二个帧，并被压倒第一个帧上 foo完成并返回 -&gt; 最上层帧弹出栈 bar完成并返回 -&gt; 出栈，栈空 javascript在什么时候会用到队列呢？一个 JavaScript 运行时包含了一个 待处理的消息队列 。每一个消息都关联着一个用以处理这个消息的函数。 在事件循环期间的某个时刻，运行时从 最先进入队列的消息开始处理队列中的消息 。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。 函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。 回到正题根据 HTML Standard. 这里的宏任务（旧称macrotask）现统称为task，其定义为： a task is a struct which has:- StepsA series of steps specifying the work to be done by the task.- A sourceOne of the task sources, used to group and serialize related tasks.- A documentA Document associated with the task, or null for tasks that are not in a window event loop.- A script evaluation environment settings object setA set of environment settings objects used for tracking script evaluation during the task.A task is runnable if its document is either null or fully active. 翻译过来就是一个具有指定步骤、具有一个源、上下文或者null（此时使用window event loop）、一系列追踪脚本运行的对象的结构。 而微任务依然是microtask，其定义为： A microtask is a colloquial way of referring to a task that was created via the queue a microtask algorithm. 译：微任务是指通过队列微任务算法创建的任务的口语方式。 举个例子这里感谢Jiasm的例子微任务、宏任务与Event-Loop,对于一段JS代码而言，在JS的执行阶段是要逐步执行的，那么执行到一些需要等时的方法时，我就不可能去等待这些方法到来，等到你到来的时候我们再排队；那么对于一个方法（macrotask）而言，其内部可能存在多个额外的“业务”： 1234567891011setTimeout(_ =&gt; console.log(4))new Promise(resolve =&gt; { resolve() console.log(1)}).then(_ =&gt; { console.log(3)})console.log(2)// finally log 1,2,3,4 这里需要注意，setTimeout是宏任务，而Promise.then是一个标准的微任务，在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。 Promise A+规范里特别标注，这里Promise要取决于平台和引擎自身：This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called. 目前比较流行的实现标准里，宏任务有： Browser Node.js I/O Yes Yes setTimeout/setInterval Yes Yes setImmediate No Yes requestAnimationFrame Yes No 常见的微任务有：process.nextTick,MutationObserver,Promise.then/catch/finally 回到EventLoop-事件循环有一个非常好的动画来解释为什么是这样的执行顺序 Who’s right?","link":"/2019/08/20/fe/task-job-%E4%B8%8E-eventloop/"},{"title":"&quot;Vue 3.0 Beta&quot;B站直播内容速记","text":"直播内容 直播使用的PPTGoogle文档地址, 需要科学上网 3.0 Beta特性介绍 性能表现 “摇树”支持 Composition API Fragment, Teleport, Suspense 更好的TypeScript支持 自定义Render 何时才能使用Vue 3.0（生态进度） 性能表现重写V-dom实现 本节内容结合 vue-next-template-explorer.netlify.app 食用更佳。 2.0版本的的v-dom实现参考了snabbdom，加入了一部分Vue相关的特性属性如Static标记等。3.0大幅度修改了其实现，并对标记等进行了优化。 Compiler-informed fast paths（个人理解：更快的编译/render路径） 本节内容结合 vue-next-template-explorer.netlify.app 食用更佳。 这一部分主要体现在最终的render函数上，利用上述工具，我们发现静态节点标记以及属性（绑定）被归为不同的部分，其中静态节点甚至可以通过开启提升来进行复用，未绑定的属性与进行了绑定的也可以直接标记出来，减少了对比与diff压力，从而得到更快的速度。 更高效的组件初始化更新性能提高1.3～2倍 参考（下同）：based on benchmarks that simulates typical scenarios, may vary based on actual application. 2～3倍更快的SSR（服务端渲染）SSR下，可以将静态节点作为Buffer的一部分直接推入最终的请求返回中，从而获得更快的速度。 “摇树”Tree-shaking 本节内容结合 vue-next-template-explorer.netlify.app 食用更佳。 大部分可选特性目前可被“摇树”在“next-template-explorer”中，如果你使用了例如v-on或者v-model等选项，可以在右侧清楚的发现对应选项通过摇树的方式单独打包进入最终的代码，相比于2.x版本需要包含完整runtime而言是非常大的优化。 最基本的HelloWorld示例打包大小约为13.5kb 如果选择只包含Composition API支持的模式，打包体积可以减小至11.75kb。 包含所有Runtime的打包体积约为22.5kbFragment, Teleport, SuspenseFragment碎片的概念有些类似于React的Fragment概念，Vue 3版本支持更多的使用方式，比如可以只有字符串，或者利用数组构成一段Fragment。 Teleport(有译为：占位传递组件）Teleport与React的Portals概念类似。 Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。 尤大在直播中提到，为何没有直接使用Portal来命名还有另外一个原因：Chrome的iframe“替代方案”——Portal Teleport功能可以用来将部分组件代码传递到DOM树的其他位置，可以在很多场景下使用，比如窗口resize等，简单说明： 12345678&lt;!-- In some nested Vue component --&gt;&lt;NestedComponent&gt; &lt;v-fragment target=\"#popup-target\"&gt; &lt;PopUp /&gt; &lt;/v-fragment&gt;&lt;/NestedComponent&gt;&lt;!-- before closing body tag --&gt;&lt;div id=\"popup-target\"&gt;&lt;/div&gt; Suspense同样的，其对应了React的Suspense概念，要注意的是，当前Suspense特性在React中同样也是试验性功能，暂时不适合投入生产环境 。 React社区中有一些第三方库对其进行了实现，比如zeit.co推出的swr库，主要是用于作为等待与实现异步，Suspense部分会进行等待，直到异步任务完成继续，非常适合用来实现loading态。 何时才能使用Vue 3.0（生态进度） 建议随时参考官方的Vue-next仓库，了解生态各部分的开发进展。 目前Vue 3.0已经进入了Beta版本，预计年中会推出可以投入生产的版本。 Vue Router：已知会 有部分API改动 ，目前alpha阶段； Vuex：目前已知没有API改动，同样处于alpha阶段； Vetur：其作者预计在五月份会进行跟进开发工作； Nuxt：目前已经实现了demo版本，正在跟进中； vue-cli：目前实验性支持； 需要注意的是，Vue 3.0 beta目前不支持IE11，在未来会推出针对IE11的专用build，如果需要兼容则需要开启对应的开关，会在最终打包时加入部分的fallback策略。 2.x版本的未来2.x版本会在3.0稳定后推出一个Minor版本，之后会进入为期18个月的LTS，LTS过后只进行安全修复不会做版本更新。这个版本会包括部分2.x版本可兼容的3.0新特性。","link":"/2020/04/21/fe/vue-3-0-beta-b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%86%85%E5%AE%B9%E9%80%9F%E8%AE%B0/"},{"title":"Vue(v2.6.10)的选项 &#x2F; 生命周期钩子","text":"Vue更新版生命周期截止v2.6.10版本，Vue相关的选项/生命周期共有11个： beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestroy destroyed errorCaptured 生命周期顺序：初始化生命周期和方法 -&gt; beforeCreate -&gt; 初始化依赖注入和响应式 -&gt; created -&gt; 模板解析编译 -&gt; beforeMount -&gt; 创建element节点 -&gt; mounted -&gt; 如果数据被更新 -&gt; updated -&gt; 触发重新渲染和patch (-&gt; 如果数据继续更新 -&gt; beforeUpdate -&gt; 调用destroy方法 -&gt; beforeDestroy -&gt; 销毁子节点&amp;watcher&amp;事件监听 -&gt; destroyed activatedkeep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。 deactivatedkeep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。 errorCaptured 2.5.0+ 新增 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 这里提一下keep-alive, 这是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在&lt;keep-alive&gt; 内被切换，它的 activated 和deactivated 这两个生命周期钩子函数将会被对应执行。","link":"/2019/08/18/fe/vue-v2-6-10-%E7%9A%84%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"},{"title":"Vue中的 computed 和 watch的区别","text":"computed我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。 我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 watchVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。 计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter； watch有两个选项，deep和immediate 两者的区别computed: 适用于重新计算比较费时不用重复数据计算的环境。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。如果一个数据依赖于其他数据，那么把这个数据设计为computed watch: 如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化","link":"/2019/08/21/fe/vue%E4%B8%AD%E7%9A%84-computed-%E5%92%8C-watch%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Vue使用自定义指令完成节流和防抖","text":"为什么要通过指令实现？参考lodash/_，和underscore库，节流和防抖均是通过高阶函数的形式实现的，这种方式需要手动绑定this，对于 Vue 的单组件文件来说，在methods外层使用会导致this的指向不清，直接指向window的情况，举例： 12345678910methods: { doSomethings () { console.log('log') }},mounted () { document.querySelector('.test').addEventListener('click', function() { _.throttle(this.doSomethings, 200) }) // 无法正常触发，此写法报错非函数，箭头函数则完全没有触发内部函数} 12345methods: { doSomethings: _.throttle(function() { console.log('log') // 可以正常节流，这里this的指向是该组件 })} 虽然第二种方法正确实现了节流，但是这种写法不方便进行组合合并，如果触发的函数有不同的情况，在内部的函数需要多层嵌套或者传参，举例： 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;app&quot;&gt; olas &lt;span @click=&quot;test(1)&quot;&gt;1111&lt;/span&gt; &lt;span @click=&quot;test(2)&quot;&gt;2222&lt;/span&gt; &lt;span @click=&quot;test(3)&quot;&gt;3333&lt;/span&gt; &lt;span @click=&quot;test(4)&quot;&gt;4444&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;methods: { test: function(i) { console.log(i) }, doSomething:_.throttle(function(i) { this.test(i) }, 2000) }, mounted () { }&lt;/script&gt; 这种情况下无法实现参数值的传递，需要借助 data，并不是比较好的选择，因此采用自定义指令的方式 这种实现有什么不足？最大的一点不足就是 SSR 需要通过判断window或者提供一个服务端专用版本来避免获取 dom，但是需要节流/防抖的一般都是在客户端的用户交互事件，往往不需要提供服务端版本，因此我这里采用window判断的方式，只在客户端挂载监听事件 通过自定义指令，代理 v-on 直接挂载的方式，需要传入较多的参数 防抖实现参数： func: methods 内的函数名; args: 向该方法传递的参数，形式为数组; opt : 防抖选项，包含 seconds 和 immediate 123456789101112131415161718192021222324252627282930Vue.directive('debounce', { inserted: function(el, binding) { const event = binding.arg const funcArgs = binding.value.args || [] const options = binding.value.opt || {} const wait = options.seconds || 300 if (typeof window !== 'undefined') { let timer = null el.addEventListener(event, e =&gt; { if (timer) { clearTimeout(timer) } if (options.immediate) { let callNow = !timer if (callNow) { binding.value.func.apply(this, funcArgs) } timer = setTimeout(() =&gt; { timer = null }, wait) } else { timer = setTimeout(() =&gt; { timer = null binding.value.func.apply(this, funcArgs) }, wait) } }) } }}) 节流实现参数： func: methods 内的函数名; args: 向该方法传递的参数，形式为数组; opt : 防抖选项，包含 seconds 和 leading(未实现),trailing(未实现) 1234567891011121314151617181920212223Vue.directive('throttle', { inserted: function(el, binding) { const event = binding.arg const funcArgs = binding.value.args || [] const options = binding.value.opt || {} const wait = options.seconds || 300 if (typeof window !== 'undefined') { let previous = 0 el.addEventListener(event, e =&gt; { if (!previous) { previous = new Date() binding.value.func.apply(this, funcArgs) } else { let now = new Date() if (now - previous &gt; wait) { previous = now binding.value.func.apply(this, funcArgs) } } }) } }})","link":"/2019/08/11/fe/vue%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%AE%8C%E6%88%90%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"},{"title":"Yarn内那些冷门的命令","text":"Yarn与Package yarn remove [package] 执行remove会同时移除package.json与yarn.lock。 Yarn安装 yarn install --force Yarn支持缓存依赖，如果曾经安装过相同的包，则会从缓存读取，并且能够离线安装，如果认为之前缓存的版本有问题，则需要使用--force来强制跳过缓存安装。也可以运行yarn cache clean移除所有本地缓存（可以指定包名单独清理）。 yarn install --ignore-scripts Yarn和NPM在运行安装时，如果项目有相关的钩子，则会在相应的事件运行钩子，如果想避免执行钩子，则可以通过忽略scripts避免钩子执行。 yarn global add Yarn的全局安装需要注意的是，在一些环境下yarn config set prefix &lt;filepath&gt;来设置全局安装位置，或者在如同yarn global add create-react-app --prefix /usr/local配置全局安装位置。 这个问题常见于Linux环境，如果我们执行yarn config get prefix得到的是undefined或者其他无法访问的目录，我们是不能够通过yarn global安装全局可执行的命令的，这时我们需要设置yarn config set prefix ~/.yarn然后在我们的~/.bashrc(或者~/.zshrc)文件内添加一行: 1export PATH=\"$PATH:`yarn global bin`\" Yarn CLI 相关 yarn list --depth=0 博主曾经遇到过一次本地环境阿里云SDK执行正常，但同事的执行故障，经过检查发现阿里云的SDK最近有更新，检查可以通过list命令，也可以指定具体的包。 yarn upgrade-interactive [--latest] 升级，升级包是一个核心需求，加入–latest可以忽视大版本直接获取对应包的最新版，如果是跨版本更新，则会同时修改package.json。 yarn version --new-version &lt;version&gt; 我们在更新项目时经常需要同时更新package.json的对应版本，如果需要结合CI流程则未免过于繁琐，可以对应执行yarn version来更新package.json。 你应该保留yarn.lock文件并提交到版本控制yarn.lock文件内部包括了所有相关的依赖和版本信息，以及对应的包地址，为了能够保证在所有开发者以及开发环境（如CI等）的运行一致，建议保留并提交版本控制。 有关于切换源 原始默认的源：https://registry.yarnpkg.com 我们可以通过yarn config set registry https://registry.npm.taobao.org/来设置源为淘宝源，但是偶尔会出现一些安装问题，这里备份一下原始地址以供参考。","link":"/2020/01/05/fe/yarn%E5%86%85%E9%82%A3%E4%BA%9B%E5%86%B7%E9%97%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"},{"title":"从DOM与虚拟DOM了解Vue和React是如何响应数据变化的","text":"先说浏览器的渲染模式这里引用一段掘金作者“我是你的超级英雄”在深入剖析：Vue核心之虚拟DOM 一文中的描述： 所有的浏览器渲染引擎工作流程大致分为5步：创建DOM 树 —&gt; 创建 Style Rules -&gt; 构建 Render 树 —&gt; 布局 Layout -—&gt; 绘制 Painting。第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。 DOM树是整个页面的骨架，承载着内容和结构的任务，而当下的Web开发会有大量与DOM树交互的需要，因此，虚拟DOM和diff算法应运而生，先在虚拟DOM上更新，再diff后应用局部的更新，减少了直接操作DOM树带来的重绘与重排问题，有关diff算法会在下一篇文章中做分析。 Patch是何时执行的？当vnode和oldVnode都存在、oldVnode不是真实节点，并且vnode和oldVnode是同一节点时，才会调用patchVnode进行patch。 Patch/Update有哪些情况？这里我们只说明后续响应的情况： 如果节点不同，则根据 旧节点 参考使用 nextSibling 创建新节点并移除旧节点，其中Vue.js需要更新其中占位符节点（实际DOM节点）； 如果节点相同，则更新vnode的属性并更新到实际节点，旧节点本质上仍然不变； 如果节点存在子元素且子元素发生改变，则通过 updateChildren 更新子节点，这里可能会用到我们的key属性，进行快速比对diff。","link":"/2020/01/07/fe/%E4%BB%8Edom%E4%B8%8E%E8%99%9A%E6%8B%9Fdom%E4%BA%86%E8%A7%A3vue%E5%92%8Creact%E6%98%AF%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E7%9A%84/"},{"title":"从零到一实现一个JS版深克隆","text":"深克隆是用来做什么的？JavaScript内，所有的Object都是引用类型，它们对应的变量只保存了一个指向实际内存的指针，如果我们只是将目标对象赋值给新对象，那么我们实际复制的还是指针，如果我们修改了原始内存内保存的对象，就会导致所有相关的变量都会被改变。因此，深克隆的目的就是为了生成一个全新的对象，并存储在独立的内存位置内。 先实现一个简单的复制假设我们有以下一段已有的代码： 12345678910111213141516171819202122// 测试循环应用var _objType = { name: \"This is another object.\"};// _objType.objectType = _objType;// 复制的原始对象var origin = { stringType : \"This is string.\", numberType : 123, booleanType : false, objectType : _objType, functionType : function() { return document.navigator.userAgent; }, inheritType: inheritObj}var clonedObj = cloneDeep(origin);origin.numberType = 456; // 修改原始对象的属性console.log(clonedObj); 那么我们的基础复制方法baseClone应该如下： 123456789101112function cloneDeep(target) { return baseClone(target);}function baseClone(target) { var newObj = {}; for (var key in target) { // 循环一个指定的变量来循环一个对象所有可枚举的属性 newObj[key] = target[key]; } return newObj;} 我们注释了一个循环引用的情况下，对应的属性得到了复制，并且在修改原始对象时，新对象没有被修改。 递归实现简单深复制通过判断每次读取的key是否是对象，我们可以得到一个递归实现的简单深拷贝： 123456789101112function baseClone(target) { var newObj = {}; for (var key in target) { // 循环一个指定的变量来循环一个对象所有可枚举的属性 if(typeof target[key] === 'object' &amp;&amp; target[key] !== null) { newObj[key] = baseClone(target[key]); } else { newObj[key] = target[key]; } } return newObj;} 但是这里就会出现一个非常致命的bug， 我们的测试用例内有一个循环引用，如果只这样遍历会导致无限递归 ，我们需要进行处理。 保证只循环复制自身的属性修改我们的baseClone，检测对应的key是否是自身属性： 1234567891011121314function baseClone(target) { var newObj = {}; for (var key in target) { // 循环一个指定的变量来循环一个对象所有可枚举的属性 if(Object.prototype.hasOwnProperty.call(target, key)) { // 使用泛型方法，避免target内存在自定义的hasOwnProperty方法导致判断出现错误 if(typeof target[key] === 'object' &amp;&amp; target[key] !== null) { newObj[key] = baseClone(target[key]); } else { newObj[key] = target[key]; } } } return newObj;} 处理循环引用(Circular Structure) 循环引用是指，对象A中有一个指针指向对象B，B内又有一个指针指向对象A，导致两个指针都不能得到正确的释放。 我们使用一个数组去存储拷贝过的对象，避免循环引用导致递归进入死循环无法退出的问题： 12345678910111213141516171819function baseClone(target, stack) { var newObj = {}; if(!stack) stack = []; // 检测target是否已经存在于stack内 if(target.indexOf(stack) &gt; -1) { return target } else { stack.push(target) } for (var key in target) { // 循环一个指定的变量来循环一个对象所有可枚举的属性 if(typeof target[key] === 'object' &amp;&amp; target[key] !== null) { newObj[key] = baseClone(target[key], stack); } else { newObj[key] = target[key]; } } return newObj;} 如果涉及到继承我们修改上面的例子，给出一个简单的继承： 12345678910// 测试继承部分的情况function OriginParent(name) { this._stringType = name; this.numberType = 999;};var inheritObj = new OriginParent(\"origin string\");var clonedInherit = cloneDeep(inheritObj);inheritObj.numberType = 888;console.log(clonedInherit.constructor); 当我们打印复制的对象的构造函数时，我们发现它输出的是Object而非OriginParent，也就是说我们在复制的过程中，遗失了它本身的构造函数。 因此在循环时我们需要使用一个变量临时存储，并在之后修复它，改进的代码如下： 123456// 利用new操作符的特性完成修复function inheritClone(target) { var ctor = target.constructor; var newObj = new ctor; return newObj;} 这里处理的情况其实是函数，但实际上lodash库对于函数直接进行了返回，换而言之，他们使用同一个内存地址是符合我们对于深拷贝的定义的。 处理更多的类型数组首先通过展开运算符(...)是可以快速实现的，会对简单的一维数组（且内部均为基本类型的值）的数组进行拷贝，如果涉及到引用类型（包括多维数组），还需要进行递归处理直到目标是一个基础类型为止。 除了展开运算，我们也可以使用几个数组的原生方法返回全新的数组，比如Array.map或者Array.concat(); // 拼接为空时是指返回新的原来数组 修改上面的代码，使之支持数组： 12345678910111213141516171819function baseClone(target, stack) { var newObj = Array.isArray(target) : [] : {}; if(!stack) stack = []; // 检测target是否已经存在于stack内 if(target.indexOf(stack) &gt; -1) { return target } else { stack.push(target) } for (var key in target) { // 循环一个指定的变量来循环一个对象所有可枚举的属性 if(typeof target[key] === 'object' &amp;&amp; target[key] !== null) { newObj[key] = baseClone(target[key], stack); } else { newObj[key] = target[key]; } } return newObj;} 其他引用类型首先要进行判断，因为是引用类型，建议通过toString来进行判断，下面给出一个简单的对应： 123456789101112const mapTag = '[object Map]';const setTag = '[object Set]';const arrayTag = '[object Array]';const objectTag = '[object Object]';const boolTag = '[object Boolean]';const dateTag = '[object Date]';const errorTag = '[object Error]';const numberTag = '[object Number]';const regexpTag = '[object RegExp]';const stringTag = '[object String]';const symbolTag = '[object Symbol]'; 对于以上的类型，除了数组和对象，其他都不能再进行递归拷贝，因此可以对应使用构造器直接构造新的引用值来进行拷贝。 延展话题：Map与WeakMap这个话题之后会另起一篇单独讨论，他们在这一类复制的情况可以有较好的运用。","link":"/2020/03/19/fe/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAjs%E7%89%88%E6%B7%B1%E5%85%8B%E9%9A%86/"},{"title":"做前端笔试题前，需要复习的数组方法","text":"前端的笔试题，离不开妙用数组解决存储和顺序，本文复习一下数组的方法，加深印象，补充一些妙用。 方法概览 转换 toLocalString() toString() valueOf() 栈方法 pop() array.pop() // 返回pop的元素 push() array.push(item1, item2, ..., itemX) // 返回数组新长度 队列方法 push() array.push(item1, item2, ..., itemX) // 返回数组新长度 shift() array.shift() // 返回移除的元素 重排序 sort() array.sort(sortFunction) // 返回数组的引用，不产生新的副本 reverse() array.reverse() // 返回数组的引用，不产生新的副本 操作方法 concat() array1.concat(array2,array3,...,arrayX) // 返回新数组 slice() array.slice(start, end) // 返回新的数组 array.slice()返回数组的复制。 splice() array.splice(index,howmany,item1,.....,itemX) // 如果从 array 中删除了元素，则返回的是含有被删除的元素的数组。 位置方法 indexOf() array.indexOf(item,start) // 返回第一个出现的位置，如果未找到返回 -1 lastIndexOf() // 返回最后一个出现的位置，如果未找到返回 -1 迭代方法 every() array.every(function(currentValue,index,arr), context) // context为this的值，下同。返回布尔值，如果所有元素都通过检测返回 true，否则返回 false。 filter() array.filter(function(currentValue,index,arr), context) // 返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。 some() array.some(function(currentValue,index,arr) ,context) // 返回布尔值。如果数组中有元素满足条件返回 true，否则返回 false。 forEach() array.forEach(function(currentValue, index, arr), context) // 返回undefined！ map() array.map(function(currentValue,index,arr), context) // 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 归并方法 reduce() array.reduce(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果，例如求和。 reduceRight() array.reduceRight(function(total, currentValue, currentIndex, arr), initialValue) // 返回计算结果。 新方法 keys() array.keys() // [object Array Iterator] includes() arr.includes(searchElement, fromIndex?) // 返回布尔值。如果找到指定值返回 true，否则返回 false。 from() array.from(object, mapFunction, context) // 返回数组对象。用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。 findIndex() array.findIndex(function(currentValue, index, arr), context) // 返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1。 entires() array.entries() // 返回数组迭代对象。","link":"/2020/03/02/fe/%E5%81%9A%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98%E5%89%8D-%E9%9C%80%E8%A6%81%E5%A4%8D%E4%B9%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"title":"养成好习惯 - HTML语义化","text":"何为语义化？ 语义化的含义就是用正确的标签做正确的事情，html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。 做一个比较而言，Markdown导出的html结构就是符合大部分语义化的做法，即便在没有样式时，通过浏览器基础的样式和解析，整个页面仍保持构想的文档结构，能够维持较为清晰的页面结构，对我而言，就需要注意标签的使用。 语义化常使用的标签meta信息 titletitle标签指定了文档对外的标题，建议一般显示为 窗口标题 / 历史记录 / 搜索结果标题 / … langlang指定了内容的语言 metameta元素中，name决定了文档种类，content表示内容，标准情况下应包括application-name, author, description, generator, keywords 链接 linklink元素必须包括rel和href属性，用来描述文档本身与其他资源的关系 aa元素在存在href时为超链接，无href为链接占位符，可以添加rel属性使其兼容浏览器的阅读模式（如rel=”prev”显示为分页器） 区块 articlearticle标签可以用于独立的文档、页面等，可以单独发布、重用等内容 sectionsection一般是按主题将内容分组，通常会有标题，但本身并非语义化的div，它通常用于将内容体现在文档等提纲中 navnav是一个包含导航链接等自然节，它可以帮助UA快速获得导航内容，其内部不一定使用ul，也可使用自然文本 asideaside也是块级元素，它通常表示与周围内容关系不大密切等内容，可以用来做侧边栏等容器等 h1-h6标题元素日常常用，需要注意覆盖浏览器默认样式 header/footerheaderfooter元素与header类似，代表最近的父级区块内容的页脚，同样不影响文档提纲 内容分组 p段落是主题接近的若干句子组成等文本块，如果段落没有特指，考虑使用p ol/ul/li需要注意，列表有序和无序在默认表现下不同，ol内的li可以设置value代表该列表项的序号值 dl/dt/ddMDN对此元素的定义是：一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键-值对列表)。因此最好能够使用在能够体现键值对的情况 figure&amp;figcaptionfigure元素是比较独立的，被主要引用的图片、插图、照片代码等，一般会有一个标题，即figcaption div最常用也是最滥用的元素，其本身无语义，可以和类名、id、title等结合，但是是最后考虑的选择。尤其是涉及dom操作时，通过类名选择div需要遍历整个页面所有的div，性能上也会大量损耗 文本 em/strong一般表示侧重点的强调，会因嵌套层数改变强调级别，一般渲染为斜体 i可作为画外音等等杂项，建议与class、lang一同使用 small不止作为小字使用，可以作为注意或声明使用 cite作为引述的作品标题、文章论文等标题 mark不常用，但可以作为与用户当前的行为相关的内容，如高亮显示搜索关键词 嵌入内容 imgimg要注意src和alt的使用，其中： 有 src 且 alt 为空字符串，代表装饰用图 有 src 且 alt 为非空字符串，图为文档内容的一部分 有 src 且无 alt，图为内容一部分但无等价的文本内容可用","link":"/2019/08/11/fe/%E5%85%BB%E6%88%90%E5%A5%BD%E4%B9%A0%E6%83%AF-html%E8%AF%AD%E4%B9%89%E5%8C%96/"},{"title":"利用CSS写一个可高度自定义的多行文本自动省略Vue组件","text":"目前对于文本溢出是通过 12345678/* 单行 */text-overflow:ellipse;/* 多行 */overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 但这两种方法仅限于截断后在末尾添加省略号，如果有类似这样的需求，既不是纯色背景，又不能使用渐变的时候，就不容易计算末尾处如何控制溢出 这里引用大神hi的解决方法，仅使用css解决这个问题，本文使用 Vue + Stylus 完成这个方案 首先分析这个组件应该具备的扩展性，它应该可以定制最大行数、行高，也需要规定更多部分的宽度大小，同时应该提供内容以及更多的html片段插槽(不清楚的同学请猛戳左侧链接~)，这里我先定义它的props: 1234567891011121314151617export default { name : 'mutiLinesEllipsis', props: { lineHeight : { type : Number }, maxLines : { type : Number }, fontSize : { type : Number }, moreTextSize : { type : Number } }} 那么有了以上的几个属性，我们开始组织我们的html结构 盒子结构以及原理如图所示，这里利用了一个块元素检测左侧高度与整体高度，当文本超出时，整个内部高度被撑开，使得“更多”块有空间移动到左侧。 1234567891011&lt;div class=\"mutiple-line\" :style=\"{'max-height':lineHeight*maxLines + 'px' , 'line-height':lineHeight+'px'}\"&gt; &lt;div class=\"ellipsis-container\" :style=\"{'-webkit-line-clamp':maxLines , 'font-size':moreTextSize + 'px'}\"&gt; &lt;div class=\"ellipsis-content\" :style=\"{'font-size':fontSize + 'px'}\"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div class=\"ellipsis-ghost\"&gt; &lt;div class=\"ellipsis-placeholder\" :style=\"{'height' : lineHeight*maxLines + 'px'}\"&gt;&lt;/div&gt; &lt;div class=\"ellipsis-more\" :style=\"{'font-size':fontSize+'px', 'width':moreTextSize+'px', 'height':lineHeight+'px', 'margin-top':'-'+lineHeight+'px'}\"&gt; &lt;slot name=\"more-link\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536// 基本的多行容器样式.mutiple-line position: relative; overflow: hidden; width 100% .ellipsis-container position: relative; display: -webkit-box; -webkit-box-orient: vertical; color: transparent; .ellipsis-content color: #000; display: inline; vertical-align: top; .ellipsis-ghost position:absolute; z-index: 1; top: 0; left: 50%; width: 100%; height: 100%; color: #000; .ellipsis-ghost:before content: \"\"; display: block; float: right; width: 50%; height: 100%; .ellipsis-placeholder content: \"\"; display: block; float: right; width: 50%; .ellipsis-more position: relative; float: right; 利用Vue响应式的特点，如果这里需要做媒体查询等操作也是可以的，只需要改变传入参数即可，通用于任何Webkit内核浏览器(毕竟还是要依赖-webkit-line-clamp属性)","link":"/2019/08/11/fe/%E5%88%A9%E7%94%A8css%E5%86%99%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%AB%98%E5%BA%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E8%87%AA%E5%8A%A8%E7%9C%81%E7%95%A5vue%E7%BB%84%E4%BB%B6/"},{"title":"利用CSS给自己的博客增加灰度化效果","text":"思路利用filter特性，我们可以对根节点直接增加黑白滤镜，也可以通过通用的类名实现指定节点的滤镜（请注意，filter属性可能会影响部分DOM元素的渲染层，请参考BFC相关知识点。） 先看几种实现B站1html.gray{-webkit-filter:grayscale(.95)} 配合以下的JS代码实现在指定时间段内自动开启滤镜： 1var now=Date.now();15859296e5&lt;now&amp;&amp;now&lt;1586016e6&amp;&amp;(document.getElementsByTagName(\"html\")[0].className=\"gray\") (PS: 刚上线的时候看了一下，发现轮播没有修改为单个，后两个为空，一定要注意😂) 京东1234567891011121314151617.o2_ie8 .more2_international { filter: progid:dximagetransform.microsoft.alphaimageloader(src='//storage.360buyimg.com/mtd/home/more_international1575014601797.png', sizingMethod='scale'); background: none;}.mod_help_cover { background-image: none;}.dropdown:hover .cw-icon { border-bottom: 1px solid #e3e4e5;}html.o2_gray { -webkit-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);} 配合以下JS代码实现在指定时间内应用类名 12345678910111213var isDuringDate = function(beginDateStr, endDateStr) { var curDate = new Date() var beginDate = new Date(beginDateStr) var endDate = new Date(endDateStr) if (curDate &gt;= beginDate &amp;&amp; curDate &lt;= endDate) { return true } return false}$html = $('html')$html.toggleClass('o2_gray', isDuringDate('2020/04/04 00:00:00', '2020/04/04 23:59:59')) (PS: 京东的首页没有压缩源代码，很多部分是直出拼接在页面内的，也是一种便于操作的方案) 淘宝1html{-webkit-filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);} 总结综合以上几个例子，我们可以知道，通过filter: grayscale(100%);即可完成最简单的灰度化，但是，filter属性的可用性在Caniuse查询可知，不兼容全系列IE浏览器，即便我们使用-ms-filter，在部分版本IE仍无法使用，因此，如果需要兼容IE则可以通过IE浏览器自身实现的滤镜来作为替代。 Note As of Windows Internet Explorer 9 this feature was deprecated. As of Internet Explorer 10 this feature was removed and should no longer be used. 另外可以发现，京东还做了图片滤镜的兼容，在灰度滤镜效果异常时可以使用半透明图片作为滤镜，也是一种常见的方案。 延申阅读如何尽可能的兼容低版本IE 上面这篇文章介绍了一些兼容的技巧，但是对于一些效果需要实验验证DXImage系的滤镜与CSS3滤镜的效果是否一致。","link":"/2020/04/03/fe/%E5%88%A9%E7%94%A8css%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E7%81%B0%E5%BA%A6%E5%8C%96%E6%95%88%E6%9E%9C/"},{"title":"前端看HTTP","text":"HTTP是什么HTTP (超文本传输协议) 是用来在 Web 上传输文件的 基础协议 ，基于 TCP/IP通信协议 来传递数据，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们。目前HTTP说明文档的版本是HTTP/2。 HTTPS 是 HTTP 协议的安全版本，HTTPS 在 HTTP 上加入套接字 SSL（TLS 为 SSL 最新版）层 ，对网页进行加密传输。 HTTP 是 基于文本 (所有的通信都是以纯文本的形式进行) 以及 无状态的 (当前通信不会发现以前的通信状态) 。这个特点对在www上访问网页的人是很理想的。而且，HTTP也可以让网站更加的灵活多变，利用在AJAX上等。 HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 URL是一种特殊类型的 URI 。 HTTP是用于传输诸如HTML的超媒体文档的 应用层 协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的 客户端-服务端模型 ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用；也就是说，一个不会像UDP协议那样静默丢失消息的协议。RUDP作为UDP的可靠的升级版本，是一种合适的替代选择。 通过定义能够知道的特点 基于TCP/IP通信协议这部分的知识稍后开篇来讲 HTTP位于应用层这部分的知识稍后开篇来讲 遵循客户端-服务端模型C/S(客户端/服务器)模型，是常用的服务器模型，包括现在说的B/S(浏览器/客户端)模型，都是对C/S结构的一种变化或者改进的结构。 TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有服务器都是对等的。但由于资源被数据提供者所垄断，于是产生了C/S模型：所有客户端都通过服务器获取所需资源。 无状态这里需要区分一下两个概念： 无连接：每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接； 无状态：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系； 在后续的Web发展中需要带有一定的状态，则通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。 HTTP与HTTPS什么是HTTPSHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。 HTTPS加密机制HTTP中没有加密机制，可以通过 SSL（Secure Socket Layer 安全套接层） 或 TLS（Transport Layer Security 安全层传输协议） 的组合使用，加密HTTP的通信内容。 HTTPS是 HTTP Secure 或 HTTP over SSL。 SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但 目前主流的还是SSL3.0和TSL1.0 。 SSL工作在 OSI七层模型中的表示层 ，TCP/IP 四层模型的应用层 。 SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。 SSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。 SSL/TLS握手阶段分为五步(假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程)：以下引自 阮一峰的网络日志 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。 第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。 第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。 第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。 直白解释，在HTTPS使用时，客户端首先发起请求，服务端返回证书，客户端确认无误后，选择对应的公钥开始加密，服务端接收到数据后开始使用服务器的私钥解密。 HTTP HeaderHTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。 根据不同上下文，可将消息头分为： 一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。 请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。 响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。 实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。 常用的头部主要有： 应答头 说明 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它 Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。","link":"/2019/08/18/fe/%E5%89%8D%E7%AB%AF%E7%9C%8Bhttp/"},{"title":"在一个较大的对象数组里查询指定的对象","text":"较大的数组对于较大的数组处理首先考虑两个问题，第一个要使用原生的for循环，即： 123for(j = 0,len=arr.length; j &lt; len; j++) { } 缓存了数组长度后能够有效提高运行效率，同时原生的性能最好附：对于较大数组的遍历运行效率比较 第二个要注意的就是如果可以使用二分法，那么二分后会提高效率，举例说明一个Vue的表单中存在带筛选的Boolean值A，那么在数据加载好之后我们可以在mounted()周期中添加一个方法，将所有A===true的放入数组中，其他的放入另外一个实现二分 快速筛选对象可以使用ES6的filter方法，过滤掉不符合条件的元素，举例说明： 1234567891011121314151617181920const origin = [ { A: \"joasdjfoijas\", B: \"oasdjfojoadsjf\", }, { A: \"joasdjfoijaafdafasfs\", B: \"oasdjfojoadsjfdasfasdf\", }, { A: \"111\", B: \"Joe\", },]let result = origin.filter(function(value){ return value.A === \"111\"&amp;&amp;value.B === \"Joe\"})console.log(result) 通过Array的filter方法用回调的方式一次比较多个值是否匹配，避免多次遍历 利用filter和map组合可以大量过滤需要的元素并输出所需要的值，例如： 123456789101112131415161718192021var arr = [{ gender: 'man', name: 'john'}, { gender: 'woman', name: 'mark'}, { gender: 'man', name: 'jerry'}]// filter : 有条件的筛选，返回条件为true的数组// 筛选出性别为男性的名字集合var newArr = arr.filter(n =&gt; n.gender === 'man').map(item =&gt; { return { name: item.name }})console.log('男性名字集合', newArr) // =&gt; [{name: 'john'}, {name: 'jerry'}]// 作者：付出// 链接：https://juejin.im/post/5a5f3eaf518825733201a6a7 避免了老式的for+continue，也提高了代码的可读性","link":"/2019/08/11/fe/%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%BE%83%E5%A4%A7%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E9%87%8C%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AF%B9%E8%B1%A1/"},{"title":"对于前端熟悉又陌生的RIA","text":"RIA是什么？Wiki百科对RIA的定义是： 丰富互联网应用程序（英语：Rich Internet applications，简称RIA），又译为丰富性网络应用服务，是一种具有近似于传统桌面应用软件系统功能和特性的网络应用系统。RIA系统最大的特点是将大部分处理任务都从用户界面端移植到客户端，仅保留一些必要数据与服务器端进行信息交互。 其中比较重要的特性有两个，第一点它依赖于浏览器环境，第二点是运行在独立的沙箱内部。 RIA有哪些应用？我在Vista系统的年代，下载过“三国杀”的客户端，原来是在浏览器环境内的一个Flash，后来有了Flash AIR的客户端，可以“脱离”浏览器环境运行独立的三国杀游戏。 之所以说是“脱离”，其实只是不在浏览器内，本质还是需要调用Flash组件与功能。 当然，依托于客户端能力，避免了频繁的页面请求，能够对运行和本地化起到比较关键的作用，也能够复用在页面使用的Flash等技术，更有效的利用客户端能力。 RIA在2020年的新面貌前一阵看到了一所国外大学的测试平台仍在使用Flash作为录音插件，众所周知，2020年Flash已经正式被各大浏览器所废弃，用户在使用这种旧方式的时候就需要通过设置临时开启Flash功能来正常完成测试。 但是不是说Flash被废弃后，RIA就没有了存在的意义呢？ 我想并不是的，RIA更多的是一种思想，能够将前端技术扩展到更多的端，能够利用更多的客户端能力，是Flash等旧一代技术“退役”后不变的方向。 现在我们可以用Electron打包Web App，完成从浏览器端到客户端的过程；我们还可以借助部分浏览器支持的PWA特性，直接安装网页程序，或是通过Service Worker，增强本身的客户端能力。 除此之外，UWP以及Chrome插件环境也是前端技术在客户端的第二春，他们在实现上与浏览器非常类似，都能够实现更强的本地化需求。","link":"/2020/02/27/fe/%E5%AF%B9%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%86%9F%E6%82%89%E5%8F%88%E9%99%8C%E7%94%9F%E7%9A%84ria/"},{"title":"我们为什么需要使用Vuex做状态管理？","text":"Vuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 多个组件共享状态时当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 Vuex每个方法的区别 mutations就是存放如何更改状态 getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。 actions就是mutation的加强版，它可以通过commit mutations中的方法来改变状态，最重要的是它可以进行异步操作。 modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。","link":"/2019/08/21/fe/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8vuex%E5%81%9A%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"},{"title":"执行NPM命令报lifecycle的警告解决","text":"今天使用npm时，发现了一条如下的警告： npm WARN lifecycle The node binary used for scripts is /var/folders/g_/dslq6ff90pn_wyjv5g6578qm0000gn/T/yarn–1577473189287-0.1962072526914138/node but npm is using /usr/local/Cellar/node/13.5.0/bin/node itself. Use the `–scripts-prepend-node-path` option to include the path for the node binary npm was executed with. 这是因为yarn运行在独立的yarn环境下，解决此警告需要设置一条全局的config npm config set scripts-prepend-node-path true","link":"/2019/12/27/fe/%E6%89%A7%E8%A1%8Cnpm%E5%91%BD%E4%BB%A4%E6%8A%A5lifecycle%E7%9A%84%E8%AD%A6%E5%91%8A%E8%A7%A3%E5%86%B3/"},{"title":"浏览器的重绘（Repaint）与重排（Reflow）机制","text":"什么时候会触发重排？ 添加或删除可见的 DOM 元素 元素位置改变 元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变） 内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替 页面渲染器初始化 浏览器窗口尺寸改变 获取会导致渲染队列刷新的属性（详细介绍如下） 除此之外，一些获取DOM结构和布局的操作也会触发重排，比如： offsetTop , offsetLeft , offsetWidth , offsetHeight scrollTop , scrollLeft , scrollWidth , scrollHeight clientTop , clientLeft , clientWidth , clientHeight getComputedStyle() ( currentStyle in IE ) 为什么说重排比重绘更耗费性能当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。 重排会导致大量的计算，而重绘的区域已经计算好，相对而言开销小一些，但是要注意，两种情况都是需要一定开销的，一定要尽量减少； 我可以怎么做来避免呢？ 合并多次对样式属性的操作/使用class 批量修改DOM - 通过生成一个DOM片段后一次性插入文档（可以通过脱离文档流来减少开销） 缓存布局信息减少获取的操作 将需要多次重排的元素，position 属性设置为 absolute 或 fixed","link":"/2019/08/20/fe/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98-repaint-%E4%B8%8E%E9%87%8D%E6%8E%92-reflow-%E6%9C%BA%E5%88%B6/"},{"title":"移动端iOS特殊的点击事件","text":"起因目前需要做一个 SDK，挂载到全局完成一些标记的时间，因此需要借助document.body.addEventListener的方式，那么废话不多说，一把 suo 123document.body.addEventListener('click', function(e) { console.log('成功触发:' + e.target)}) 正当我觉得这一切没什么问题的时候，测试发现了 Bug | iOS 设备不能正常的触发啊 这种情况只能回头看代码了，这里有如下代码 1&lt;p data-xxx=\"test\"&gt;&lt;/p&gt; 通过上面的事件监听，我发现 iOS 设备压根没有成功的添加到这个节点，那么是什么问题呢？ Bug or Feature?经过一系列尝试我发现， 位于 body 的事件是无法在捕获/冒泡阶段在 iOS 设备触发事件 , 这就触及到知识盲区了，赶紧翻阅相关网站查找资料 Fix经过查阅，以下方法可以修复这个问题： onclick &lt;a href=&quot;javascript:void(0);&quot;&gt; cursor: pointer; body 或者对应元素 &lt;button&gt; click -&gt; touchstart 以上方案来讲，样式最清晰，改动最小，touchstart 方案也是比较容易实现的，但需要注意 touchend","link":"/2019/08/12/fe/%E7%A7%BB%E5%8A%A8%E7%AB%AFios%E7%89%B9%E6%AE%8A%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"},{"title":"Bye QYER","text":"在穷游一年的时间，最终还是选择了离开去寻找更大的环境，希望穷游的一切能够越来越好，希望同事们都能工作顺利！ Bye！","link":"/2019/08/17/life/bye-qyer/"},{"title":"CentOS服务器配置防火墙","text":"将端口添加到区域（永久 --permanent） 1firewall-cmd --zone=public --add-interface=eth0 reload防火墙 12firewall-cmd --reloadfirewall-cmd --complete-reload # 需要断开链接 查看指定区域所有打开的端口 1firewall-cmd --zone=public --list-ports 在指定区域打开端口 1firewall-cmd --zone=public --add-port=80/tcp # (永久生效再加上 --permanent, udp设置同理) 查看防火墙状态 12systemctl status firewalld# firewall-cmd --state 防火墙启动/禁用等 12345systemctl start firewalld # 启动防火墙systemctl stop firewalld # 禁用防火墙systemctl enable firewalld # 设置开机启动sytemctl disable firewalld # 停止并禁用开机启动firewall-cmd --reload # 重启防火墙","link":"/2019/08/25/other/centos%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99/"},{"title":"Git常用命令速览","text":"git基本概念 设置git信息 git config --global user.name &quot;[name]&quot;设置提交时的用户名 git config --global user.email &quot;[email]&quot;设置提交时的用户邮箱 git config --global color.ui auto设置命令行颜色 新建仓库 git init [project-name]代码文件夹初始化git git clone [url]克隆项目仓库（包含整个版本信息） 修改 git status列出所有即将被提交的新建和更改的文件 git diff显示所有未加入暂存区的差异 git add [file] git add -A: [&lt;path&gt;]表示把&lt;path&gt;中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。 git add -i: [&lt;path&gt;]查看&lt;path&gt;中被所有修改过或已删除文件但没有提交的文件，并通过其revert子命令可以查看&lt;path&gt;中所有untracted的文件，同时进入一个子命令系统。 git diff --staged显示暂存区文件与最新文件版本的差异 git reset [file]取消文件暂存，但保留其内容 git commit -m &quot;[descriptive message]&quot; -m指后面可以直接输入message，否则需要调用编辑器 -a命令后，与单独执行git add类似，但不会将新文件加入暂存区，因而不推荐使用 -v命令可以在提交时显示所有diff信息 分工协作 git branch默认无参数时，列出所有本地的当前仓库的分支 git branch [branch-name]在本地创建一个新的分支 git checkout [branch-name]切换到指定的分支并更新当前工作区 git merge [branch]将指定分支的代码历史拼合到当前分支 git branch -d [branch-name]删除指定的分支（慎用） 文件编辑 git rm [file]将文件从当前工作区删除，暂存删除操作 git rm --cached [file]将文件从版本控制中移除，但本地保留文件 git mv [file-original] [file-renamed]修改文件名称，准备提交 跟踪设置 .gitignore设置当前目录下版本控制自动忽略的文件，后缀或指定文件夹均可 git ls-files --other --ignored --exclude-standard列出当前项目下所有忽略的文件 碎片储存 git stash临时保存所有的已跟踪的修改，以下命令都可以通过传入@n删除指定的更改 git stash pop恢复最近一次暂存的修改，并从栈中移除 git stash list列出栈中所有已暂存的修改条目 git stash drop直接放弃最近一次暂存的更改 查看历史 git log列出当前分支的版本历史 git log --follow [file]列出指定的文件的版本历史，包括重命名 git diff [first-branch]...[second-branch]显示两个分支的内容差异 git show [commit]输出指定提交的metadata以及内容变化 撤销操作 git reset [commit]撤销指定[commit]后所有的提交，保留本地更改 git reset --hard [commit]删除所有的更改和历史，回退到指定的[commit] 同步更改 git fetch [bookmark]下载从[bookmark]所有的更改历史 git merge [bookmark]/[branch]组合[bookmark]分支到当前分支 git push [alias] [branch]上传所有本地分支的提交到git服务器 git pull下载书签历史以及非协作变化","link":"/2019/08/11/other/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E8%A7%88/"},{"title":"红米RM2100+AX200诡异跳ping问题","text":"开篇先说结论结论是：AX200在连接RM2100(Padavan)的5G 160Mhz无线信号时，出现跳ping（波动至250+）。 解决方案：设置RM2100的5G WiFi以20/40/80Mhz使用，目前跳ping得到缓解。 我的网络搭配红米 AC2100主路由，刷入C大的Padavan固件，不开启任何插件的情况下，打开5G的20/40/80/160Mhz自动协商 ； 主机由于一居室的距离问题，因而加装了一个无线网卡（COMFAST AX200），测速和日常直播没有感受到速度问题，偶尔出现无法打开页面的情况，考虑到AC2100的CPU比较差，关闭了SmartDNS等插件。 而后，平时页面打开出现无法打开情况减少，但跳ping情况依然明显，在游戏(Insurgancy第三方服务器)内ping会几分钟内突然飙升至250左右，网页同时也速度极慢。 更新固件，修改信道等等方案都尝试后，决定降级到20/40/80Mhz自动协商，跳ping状况基本解决，不更改AX200配置的情况下，稳定在80Mhz传输。 后续更新驱动希望后续能有稳定的AX200驱动能够支持ac模式下的160Mhz。不过目前来看各大第三方都不够稳定，个人使用C大的0604版还可以接受，地址上方自取。 目前来说，AC2100适合折腾人士，如果作为家里主路由的还不够稳定,刷入第三方后又不容易支持加速器等。 ……","link":"/2020/06/14/other/rm2100-ax200-ping/"},{"title":"SaaS, laaS, PaaS这些名词的快速理解","text":"SaaS (软件即服务：Software as a Service) 举个不是非常恰当的例子，我想吃汉堡，我去汉堡店直接点汉堡，这是提供了“产品”来使用。 比如“石墨文档”这一类的在线应用，使用了他人提供好的成品软件，底层硬件和运行环境都交由平台管理，这种模式可以称为SaaS。 PaaS (平台即服务：Platform as a service) 还是汉堡的例子，我觉得汉堡店的汉堡没那味儿，找了个可以DIY的店，这家店不提供成品的汉堡，但是会给我炉灶、炊具之类的，还有相关的材料，我可以自己做出自己需要的汉堡，这里提供了“平台”。 比如国外已经商业化的平台Heroku，这里并不需要用户去配置底层的硬件，只需要在容器内编写业务所需的代码即可。底层的操作系统、语言支持、硬件环境均由平台管理，这种可以称为PaaS。 laaS (基础设施即服务：Infrastructure as a Service) 我觉得DIY的也不够好吃，想了想决定组一片地自己种原料自己管理店铺，自己组装一条生产线专门生产自己喜欢的汉堡。这些资源可以产出各式各样的产品，但是我只是借助它的“基础设施”完成我的需要，这种可以称为laaS。 比如目前的云平台，国外的DigitalOcean等，提供实际的基础设施，用户可以将自己的服务部署在相应的机器上使其运行并得到我们需要的结果，这种可以称为laaS。 其他新兴的模式 桌面即服务（DaaS） 无服务器计算（Serverless or FaaS） 无服务器运算（英语：Serverless computing），又被称为功能即服务（Function-as-a-Service，缩写为 FaaS），是云计算的一种模型。以平台即服务（PaaS）为基础，无服务器运算提供一个微型的架构，终端客户不需要部署、配置或管理服务器服务，代码运行所需要的服务器服务皆由云端平台来提供。—— Wikipedia 安全即服务（Security as a service，SECaaS） 后端即服务（BaaS） 容器即服务 （Containers-as-a-Service）","link":"/2020/01/06/other/saas-laas-paas%E8%BF%99%E4%BA%9B%E5%90%8D%E8%AF%8D%E7%9A%84%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3/"},{"title":"Sentry——一站式错误监控平台部署记录","text":"Sentry是什么？ Sentry helps all software teams create the best software, faster. Sentry是一个SaaS服务，提供了多种语言、多种环境的错误收集提示等自动化处理功能。 它的优势主要有以下几点： 接入简单，node &amp; flutter都是在主入口几行搞定; 支持平台和语言极广，几乎涵盖了市面上常见的语言和框架，能够为整个开发团队提供错误收集能力; 支持扩展，能够快速扩展到Gitlab、Github、Trello、Slack等平台，国内也有非常好的支持，飞书等平台也有对应的助手或Bot能够方便的扩展到日常开发上; 支持私有部署（虽然有坑……），这一点是最为重要的，能够让小团队快速利用Docker和官方命令进行部署，极快地为开发赋能。 SaaS版本我也曾使用过，但是如果没有配置好或者网络环境一般，可能会付出比较高的成本（定时器未清除导致的报错会瞬间烧光你的免费额度……），因此强烈推荐私有部署，相关教程也比较丰富。 getsentry: Github 飞书官方的Sentry助手，文档，如果其他平台没有原生支持也可以使用Webhook等方式“曲线救国”。 简单说说私有部署其实按照官方的仓库指导，很容易能够部署，只需要一些docker的基础知识并且能够利用docker-compose工具就可以运行起来，但是有很多细节比如Nginx反代Sentry，以及邮箱配置等还是需要对其他相关的东西有一些了解。 配置官方推荐的配置为2400MB内存起步，但是可以通过修改install.sh，调整最低内存，可以完成安装，但是不保证运行效率，如果较大量的请求可能会导致内存100%。 1MIN_RAM=2400 # MB 一些运行设置以邮件配置举例，目前版本(onpremise, Sentry 10.1.0.dev09b99a3b)如果希望配置生效首先需要找到sentry目录下的config.yml文件（如果没有说明是全新安装，可以从config.example.yml复制一份进行修改），利用环境变量先配置对应的参数。 更新配置后，执行以下命令： 1234# docker-compose.yml 目录下docker-compose stopdocker-compose run --rm web upgradedocker-compose up -d 如果相关程序启动成功，则可以到系统管理界面查看是否应用配置，并发送测试邮件。 坑私有部署依赖于Sentry和它的很多镜像，以及一些第三方镜像。由于Sentry 10的自建版本仍在开发迭代中，强烈推荐使用docker的原始源进行安装，成功率较高，如果使用镜像，可能存在Bug导致无法安装，需要注意。 强烈建议将postgres数据和sentry-data挂载到机器目录上，可以较好的保存持久化的信息。 Sentry依赖的一堆容器，究竟做了什么？这里强烈推荐看官方开发博客了解每一个组件背后的由来。 Snubatianon/exim4symbolicatormemcache + redis ？","link":"/2020/05/07/other/sentry-%E4%B8%80%E7%AB%99%E5%BC%8F%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/"},{"title":"Webhook联动Cloudflare Worker实现博客","text":"","link":"/2020/07/22/other/webhook-cloudflare-worker/"},{"title":"利用Docker管理VPS——Nginx篇","text":"写在前面在我个人使用VPS时，一开始的思路时独立尽可能少的服务到独立的VPS内，这导致我有很多最低配的服务器，服务没用到的时候其实运行负载并不高，低配置又不能支持诸如Sentry等服务的启动，因此，采用Docker将同类型的服务进行合并是更好的策略，但随之而来的是需要对配置有合理的规划 为什么先写Nginx首先我们要清楚一点，Docker的部分权限是和系统平级的，比如 防火墙 (操作端口时会同时添加iptables)，这导致如果只做简单映射，就会把对应端口暴露在外网，需要限制哪些服务可以通过外网访问，哪些服务只暴露对应端口给Dashboard。 请在平时启动Docker容器时，不想暴露到外网必须指定port的时候加127.0.0.1。 如果端口只暴露而不需要映射到主机端口，请使用--expose代替-p。 默认配置最方便的方式其实就是从已经运行的默认nginx镜像复制一份配置文件出来 12dokcer cp YOUR_NGINX_ID:/etc/nginx/conf.d/default.conf ./dokcer cp YOUR_NGINX_ID:/etc/nginx/nginx.conf ./ 配置方案由于是同一机器上多个容器，因此只将Nginx暴露到外网，其他容器均由Nginx进行反向代理。 端口之间各种复杂的映射并不是最好的办法，选择有两种： Nginx安装在实际的机器内，反代各种Docker容器； Nginx以容器形式安装，通过网络或者link方式组成一体的网络； 我的机器为了统一管理，这里选择第一种。","link":"/2020/03/25/other/%E5%88%A9%E7%94%A8docker%E7%AE%A1%E7%90%86vps-nginx%E7%AF%87/"},{"title":"利用WSL在Windows下获得更好的开发体验","text":"为什么Windows不适合作为开发使用？对于我个人的前端开发体验而言，主要在这几个方面： 利用Node.js实现一些自动化功能，代码内经常混入一些Windows无法运行的bash命令； Windows下一般不只有开发环境，还会安装一些其他的软件、游戏等等，相互影响； 部分库没有做cross-env兼容，在Windows下执行会有意料之外的bug； Windows的目录结构在实际使用时会有意料之外的问题； 因此，WSL是在Windows下进行开发更好的选择。 截止本文编写时，我仍不建议使用WSL2的版本，会给开发带来一些不必要的困扰，稳定后再体验。 开启WSL有关于如何在Windows下开启WSL功能，很多文章在一年前都进行了说明。在当前版本号1909下，只需要注意以下几点： 可以正常使用Microsoft Store（也支持利用zip包安装，具体详见官方文档）； 开启“适用于Linux的Windows子系统”，设置路径在：控制面板\\程序\\程序和功能 -&gt; 左侧“启用或关闭Windows功能”，这一步骤需要进行重启使得更改生效； 安装安装比较简单，利用Microsoft Store搜索“Linux”，选择你喜欢的版本进行安装即可。 安装会默认安装至C盘，如果你的C盘容量非常“宝贵”，建议使用LxRunOffline工具进行迁移，这个工具还可以进行管理等等功能，有兴趣的可以研究一下。我们下载它的Release并在Windows下解压到合适的目录下，利用PowerShell环境运行exe即可执行相关命令。 等待下载完成后启动，需要等待一些时间，系统会自动对你选择的Linux发行版进行配置和初始化，输入你的用户名密码即可开始使用。 配置配置上正常先将系统自带的各种包更新升级sudo apt update &amp;&amp; sudo apt upgrade ProxyChains由于WSL使用的是父主机（即Windows系统）的网络环境，因此在WSL环境下，部分软件安装配置时，会存在无法访问的情况（例如Github Release的文件分发地址……），强烈建议先配置ProxyChains-NG，可以选择手工下载源码make安装，也可以利用包管理器（目前包管理器版本较低，为3.x版本，仓库目前已经到了4.x版本，如果有能力建议使用源码安装，我使用的Ubuntu-18.04版本需要安装make与gcc包），sudo apt install proxychains进行安装，这里不赘述。 安装好后在/etc目录下编辑（如果是源码安装，这里是创建）proxychains.conf文件，在文件内写入配置信息： 12345[ProxyList]# add proxy here ...# meanwile# defaults set to \"tor\"socks5 127.0.0.1 1080 在配置完成后，运行命令前带有proxychains即可通过代理，例如如下命令即可测试是否成功应用代理： 1proxychains curl myip.ipip.net 如果显示代理，即配置成功。 Node.js &amp; NPM这里其实没什么需要详细说明的，和我们在服务器环境配置Node.js同理。 在官网的角落可以找到一个相对隐蔽的Node源地址，配置后可以直接通过包管理器快捷安装Node，相比于二进制与源码安装更为简单，其仓库地址 这里我遇到了Bug，在配置WSL环境前，我没有移除Windows下的Node环境，在完成了上述安装步骤后，npm -v提示“Unable to correct problems, you have held broken packages.”，看到对应报错地址指向了/mnt/c下的node目录时，明白了npm命令是调用了Windows环境下的npm，因此，卸载Windows下的nvm(请通过“控制面板”内的软件功能进行卸载)与Node.js后，移除WSL内已安装的Node.js并重新安装，一切正常工作，完美。 Oh my Zsh前文提到过，curl和wget目前都可以通过proxychains进行代理，这里其实没有太大的困难，但是，考虑到可能的DNS污染相关，这里我把官方的curl地址修改为sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;并使用代理，安装成功。 如果提示SSL相关问题，wget下可以通过wget --no-check-certificate临时关闭SSL检查。 这里我还遇到了一个无法连接的问题，我在安装的时候提示我raw.githubusercontent.com指向了0.0.0.0，查找相关issue，执行以下命令查询是否有相关的软件控制网络或代理，检查发现我的“火绒”影响了，临时退出即可。 1powershell.exe \"Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct\" | grep displayName SSH配置WSL的git环境需要对应的SSH-key，按照正常的方法，可以生成，但是无法复制出来，WSL具有可以直接执行Windows环境exe程序的特性，因此可以通过cat ~/.ssh/id_rsa | clip.exe直接复制出来。 然而生成的key无法被Github识别，提示“key is invalid”，查阅得到这个结果，虽然并不是完全一致的问题，但是提供了思路，将SSH生成的命令修改，删除指定长度“4096”的设置（-b 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。） 1ssh-keygen -t rsa -C \"your_email@example.com\" 配置到Github，成功。 卸载与导出如果之后不再需要WSL环境，可以通过如下命令进行卸载： 1wslconfig /unregister &lt;wslconfig /list得到的对应名称&gt; 额外的，建议将对应的UWP程序同时右键卸载进行彻底移除。 如果希望备份迁移，可以使用前文提到过的LxRunOffline工具进行处理，可以参考项目的Readme进行操作。","link":"/2020/04/21/other/%E5%88%A9%E7%94%A8wsl%E5%9C%A8windows%E4%B8%8B%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/"},{"title":"我的博客更新日志","text":"更新日志v0.1.0 使用Serverless架构重构博客，技术栈目前为(Next.js + Now.sh + Tailwind CSS) 重新配置Disqus评论模块 重新设计整体样式，使用React组件重构整体 v0.0.1 通过Netlify + Foresty.io + Hexo完成自动部署，脱离纯git提交模式； 添加GA统计； 添加Disqus评论； 测试功能上传一张图片","link":"/2020/02/26/other/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"},{"title":"前端部分面试题解（不定期更新）","text":"已解决 Q: 用JS实现一个函数，能使输入特定的字符串转化为特定结构化数据。 字符串仅由小写字母和[,]构成，且字符串不包含多余的空格 示例一：'abc' -&gt; {value:'abc'} 示例二：'[abc[bcd[def]]]'-&gt; {value:'abc',children:{value:'bcd',children:{value:'def'}}} A: 1234567891011121314151617181920212223242526272829303132// 类比AST，将输入转换为一系列操作function normalize(str) { let parent = {} // 所有括回均不需要，直接移除 parent.children = _normalize(str.replace(/\\]/g, '')) return parent.children}function _normalize(str) { // [abc[bcd[def]]] =&gt; {value: \"abc\", children: {value: \"bcd\", children: {value: \"def\"}}} // 不具有树形结构直接返回 let obj = {} if(str.charAt(0) !== '[') { obj.value = str return obj } // '['开始, 找到之后的连续字符串 let arr = str.split('[') let _val = arr[1] // 截取剩下的部分再进行递归 let rest = '' for(let i = 2; i &lt; arr.length; i++) { rest = rest + '[' +arr[i] } if (rest === '') { return {value: _val} } return {value: _val, children: _normalize(rest)}}normalize('[abc[bcd[def]]]')// normalize('def') Q: 模仿lodash内调用curry函数，实现一个myCurry？ A: 墙裂推荐这篇译文，将柯里化的思考过程逐步展现出来 本题解法来自《JavaScript轻量级函数式编程》 12345678910111213141516// lodash: _.curry(func, [arity=func.length])// 实现两点：1. 参数复用——可固定参数，2. 延迟计算——返回最终函数触发计算// 原型实现：function curry(fn, arity = fn.length) { return (function nextCurried(prevArgs) { return function curried(nextArg) { var args = prevArgs.concat([nextArg]) if(args.length &gt;= arity) { return fn(...args) } else { return nextCurried(args) } } })([])}// 注意：偏函数partial(add, 3)和柯里化curry(add)(3)的区别 Q: 在不使用slice，replace等原生函数的情况下，实现一个indexOf方法（本题来自“司徒正美”的博客）？ A: 1234567891011121314151617181920212223242526272829function getSubStrArr(str, length) { var subStrArr = [] if(!length || length === 0) return subStrArr; for (var i = 0; i &lt; str.length - length + 1; i++) { if(length &gt; 1) { var tmp = []; for(var j = 0; j &lt; length; j++) { tmp.push(str.charAt(i + j)); } subStrArr.push(tmp.join('')); } else { subStrArr.push(str.charAt(i)); } } return subStrArr;}function myIndexOf(str, target) { if(target === '' || target === undefined) return flag; var flag = -1 var subStrArr = getSubStrArr(str, target.length); for(var i = 0; i &lt; subStrArr.length; i++) { if(subStrArr[i] === target) { flag = i } } return flag}console.log(myIndexOf('abcdefgh', 'cde')) Q: 简单手写实现bind A: 见 实现bind Q: 如何获取两个时间（格式如: 2001-01-30）中间相差的年月日（提供三个精度） A: 12345678910111213141516171819202122232425262728293031323334353637383940// 这道题投机的方式是通过字符串与年月日格式的硬匹配完成，但是如果要求多种精度，则需要很繁琐，建议使用Datefunction parseDate(str) { let strArr = str.split('-') if(strArr.length !== 3 || parseInt(strArr[0]) &lt; 1970 || parseInt(strArr[1]) &gt; 11 || parseInt(strArr[2]) &gt; 31 ) { // 简单处理，兼容如果当月没有此日期 throw new Error('日期格式非法') } let date = new Date(strArr[0], strArr[1]-1, strArr[2]) return date;}// 深拷贝日期对象function dateToString(_date, unit) { var _d = new Date(_date.valueOf()); var _dStr = '' if(unit &gt; 0) _dStr += _d.getFullYear(); if(unit &gt; 1) _dStr += ('-' + (parseInt(_d.getMonth()) + 1 &gt;= 10 ? (parseInt(_d.getMonth()) + 1).toString() : '0' + (parseInt(_d.getMonth()) + 1).toString())); if(unit &gt; 2) _dStr += ('-' + (parseInt(_d.getDate()) &gt;= 10 ? parseInt(_d.getDate()).toString() : '0' + parseInt(_d.getDate()).toString())); return _dStr;}// unit指精度, 从1-3分别指年月日，函数返回一个数组，包含中间所有的相差的日子function minorDates(start, end, unit) { var _u = unit || 3; var _start = parseDate(start) var _end = parseDate(end) var _minors = [] var _minorDate = _end - _start var step = 24 * 60 * 60 * 1000; // default 一天 if(_minorDate &lt;= 0) { return _minors } else { for(var i = 0; i &lt; _minorDate / step; i++) { var _d = dateToString(new Date(_start.getTime() + i * step), unit) if(_minors.indexOf(_d) === -1) _minors.push(_d); } } return _minors}console.log(minorDates('2019-02-25', '2020-02-25', 3)) 来自前端面试周报的题 本篇主要记录 Github airuikun/*Weekly-FE-Interview * 仓库内的优秀面试题我自己的解法，会持续更新，但是不会每题都解一遍，建议可以访问源仓库。 Q: 简单手写实现Promise A: 1// 实现主要三个功能，thenable，resolve，reject，catch，finally Q: 简单手写实现Async/Await A: 1 掘金 日常浏览的题目 Q: Promise题 限制异步操作的并发个数并尽可能快的完成全部 有8个图片资源的url，已经存储在数组urls中。 urls类似于['https://image1.png', 'https://image2.png', ....] 而且已经有一个函数function loadImg，输入一个url链接，返回一个Promise，该Promise在图片下载完成的时候resolve，下载失败则reject。但有一个要求，任何时刻同时下载的链接数量不可以超过3个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。 作者：LinDaiDai_霖呆呆 链接：https://juejin.im/post/5e58c618e51d4526ed66b5cf 来源：掘金 A: 1// 最优解法可以往瀑布流靠拢，有一个三个任务race的池，当一个完成时加入一个未开始的开始。 大厂面试题本节内容来自网络","link":"/2020/03/02/other/%E9%A2%98%E8%A7%A3-%E6%AF%8F%E5%91%A810%E9%81%93%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Safari","slug":"Safari","link":"/tags/Safari/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Cheatsheet","slug":"Cheatsheet","link":"/tags/Cheatsheet/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"React.js","slug":"React-js","link":"/tags/React-js/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"NPM","slug":"NPM","link":"/tags/NPM/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Frontend","slug":"Frontend","link":"/tags/Frontend/"},{"name":"性能","slug":"性能","link":"/tags/%E6%80%A7%E8%83%BD/"},{"name":"离别","slug":"离别","link":"/tags/%E7%A6%BB%E5%88%AB/"},{"name":"工作","slug":"工作","link":"/tags/%E5%B7%A5%E4%BD%9C/"},{"name":"再见","slug":"再见","link":"/tags/%E5%86%8D%E8%A7%81/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"CheatSheet","slug":"CheatSheet","link":"/tags/CheatSheet/"},{"name":"记录","slug":"记录","link":"/tags/%E8%AE%B0%E5%BD%95/"},{"name":"路由器","slug":"路由器","link":"/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"软件模式","slug":"软件模式","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"Log","slug":"Log","link":"/tags/Log/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"categories":[{"name":"Frontend","slug":"Frontend","link":"/categories/Frontend/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Other","slug":"Other","link":"/categories/Other/"}]}