<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: Frontend - 柠檬汽水🍋</title><meta description="Blog about FE, life and thoughts."><meta property="og:type" content="blog"><meta property="og:title" content="柠檬汽水🍋"><meta property="og:url" content="https://blog.sparkling.land/"><meta property="og:site_name" content="柠檬汽水🍋"><meta property="og:description" content="Blog about FE, life and thoughts."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.sparkling.land/img/og_image.png"><meta property="article:author" content="Sparkling"><meta property="article:tag" content="Frontend"><meta property="article:tag" content=" 前端"><meta property="article:tag" content=" 博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.sparkling.land"},"headline":"柠檬汽水🍋","image":["https://blog.sparkling.land/img/og_image.png"],"author":{"@type":"Person","name":"Sparkling"},"description":"Blog about FE, life and thoughts."}</script><link rel="icon" href="/assets/sparkling.ico"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-155847142-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-155847142-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">柠檬汽水🍋</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/SparklingFun"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">Frontend</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-20T08:00:00.000Z" title="2019-08-20T08:00:00.000Z">2019-08-20</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">3 分钟 读完 (大约 509 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/20/fe/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98-repaint-%E4%B8%8E%E9%87%8D%E6%8E%92-reflow-%E6%9C%BA%E5%88%B6/">浏览器的重绘（Repaint）与重排（Reflow）机制</a></h1><div class="content"><h4 id="什么时候会触发重排？"><a href="#什么时候会触发重排？" class="headerlink" title="什么时候会触发重排？"></a>什么时候会触发重排？</h4><ul>
<li>添加或删除可见的 DOM 元素</li>
<li>元素位置改变</li>
<li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）</li>
<li>内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替</li>
<li>页面渲染器初始化</li>
<li>浏览器窗口尺寸改变</li>
<li>获取会导致渲染队列刷新的属性（详细介绍如下）</li>
</ul>
<p>除此之外，一些获取DOM结构和布局的操作也会触发重排，比如：</p>
<ul>
<li>offsetTop , offsetLeft , offsetWidth , offsetHeight</li>
<li>scrollTop , scrollLeft , scrollWidth , scrollHeight</li>
<li>clientTop , clientLeft , clientWidth , clientHeight</li>
<li>getComputedStyle() ( currentStyle in IE )</li>
</ul>
<h4 id="为什么说重排比重绘更耗费性能"><a href="#为什么说重排比重绘更耗费性能" class="headerlink" title="为什么说重排比重绘更耗费性能"></a>为什么说重排比重绘更耗费性能</h4><p>当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。</p>
<p>重排会导致大量的计算，而重绘的区域已经计算好，相对而言开销小一些，但是要注意，两种情况都是需要一定开销的，一定要尽量减少；</p>
<h4 id="我可以怎么做来避免呢？"><a href="#我可以怎么做来避免呢？" class="headerlink" title="我可以怎么做来避免呢？"></a>我可以怎么做来避免呢？</h4><ol>
<li>合并多次对样式属性的操作/使用class</li>
<li>批量修改DOM - 通过生成一个DOM片段后一次性插入文档（可以通过脱离文档流来减少开销）</li>
<li>缓存布局信息减少获取的操作</li>
<li>将需要多次重排的元素，position 属性设置为 absolute 或 fixed</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-19T08:00:00.000Z" title="2019-08-19T08:00:00.000Z">2019-08-19</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">8 分钟 读完 (大约 1162 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/19/fe/async-await%E5%92%8Cpromise%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/">Async/await和Promise的一些区别</a></h1><div class="content"><h4 id="先说说Promise"><a href="#先说说Promise" class="headerlink" title="先说说Promise"></a>先说说Promise</h4><p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>
<p>一个 Promise有以下几种状态:</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。（与rejected统称为settled状态）</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<blockquote>
<p> Javascript中的promise代表一种 <strong>已经发生</strong> 的状态， 而且可以通过回调方法链在一起。 如果你想要的是表达式的延时计算，考虑无参数的”箭头方法”:  <code>f = () =&gt;表达式</code> 创建惰性求值的表达式，使用 <code>f()</code> 求值。</p>
</blockquote>
<p>Promise常用的方法有：</p>
<ul>
<li><strong>all</strong>: 这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。</li>
<li><strong>race</strong>: 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</li>
<li><strong>reject</strong>: 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法.</li>
<li><strong>resolve</strong>: 返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。</li>
</ul>
<p><strong>注意：Promise直接执行的是宏任务，只有.then和.catch是微任务!</strong></p>
<h4 id="再说Async-await"><a href="#再说Async-await" class="headerlink" title="再说Async/await"></a>再说Async/await</h4><p><code>async function</code> 用来定义一个 <strong>返回 AsyncFunction 对象</strong> 的异步函数。异步函数是指通过事件循环异步执行的函数，它会 <strong>通过一个隐式的 Promise 返回其结果</strong> (如果不是通过await返回，那么返回的是一个Promise，返回值为resolve的值）。如果你在代码中使用了异步函数，就会发现它的语法和结构会更像是标准的同步函数。</p>
<p>异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。</p>
<p>记住，await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。</p>
<p>注意，当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式Promise)</p>
<p>async/await的目的是简化使用多个 promise 时的同步行为，并对一组 Promises执行某些操作。正如Promises类似于结构化回调，async/await更像结合了generators和 promises。</p>
<p>使用async时要注意，如果同时操作多个异步方法，要注意调用的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sequentialStart = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==SEQUENTIAL START=='</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Execution gets here almost instantly</span></span><br><span class="line">  <span class="keyword">const</span> slow = <span class="keyword">await</span> resolveAfter2Seconds();</span><br><span class="line">  <span class="built_in">console</span>.log(slow); <span class="comment">// 2. this runs 2 seconds after 1.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fast = <span class="keyword">await</span> resolveAfter1Second();</span><br><span class="line">  <span class="built_in">console</span>.log(fast); <span class="comment">// 3. this runs 3 seconds after 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> concurrentStart = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==CONCURRENT START with await=='</span>);</span><br><span class="line">  <span class="keyword">const</span> slow = resolveAfter2Seconds(); <span class="comment">// starts timer immediately</span></span><br><span class="line">  <span class="keyword">const</span> fast = resolveAfter1Second(); <span class="comment">// starts timer immediately</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Execution gets here almost instantly</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> slow); <span class="comment">// 2. this runs 2 seconds after 1.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> fast); <span class="comment">// 3. this runs 2 seconds after 1., immediately after 2., since fast is already resolved</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parallel = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==PARALLEL with await Promise.all=='</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Start 2 "jobs" in parallel and wait for both of them to complete</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">      (<span class="keyword">async</span>()=&gt;<span class="built_in">console</span>.log(<span class="keyword">await</span> resolveAfter2Seconds()))(),</span><br><span class="line">      (<span class="keyword">async</span>()=&gt;<span class="built_in">console</span>.log(<span class="keyword">await</span> resolveAfter1Second()))()</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="那么async-await相比于Promise的区别（优势）？"><a href="#那么async-await相比于Promise的区别（优势）？" class="headerlink" title="那么async/await相比于Promise的区别（优势）？"></a>那么async/await相比于Promise的区别（优势）？</h4><ul>
<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调用也会带来额外的阅读负担</li>
<li>Promise传递中间值非常麻烦，而async/await几乎是同步的写法，非常优雅</li>
<li>错误处理友好，async/await可以用成熟的try/catch，Promise的错误捕获非常冗余</li>
<li>调试友好，Promise的调试很差，由于没有代码块，你不能在一个返回表达式的箭头函数中设置断点，如果你在一个.then代码块中使用调试器的步进(step-over)功能，调试器并不会进入后续的.then代码块，因为调试器只能跟踪同步代码的『每一步』。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-19T08:00:00.000Z" title="2019-08-19T08:00:00.000Z">2019-08-19</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">2 分钟 读完 (大约 331 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/19/fe/http%E7%8A%B6%E6%80%81%E7%A0%81/">HTTP状态码</a></h1><div class="content"><ul>
<li>2XX 成功</li>
</ul>
<p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>204 No content，表示请求成功，但响应报文不含实体的主体部分<br>206 Partial Content，进行范围请求</p>
<ul>
<li>3XX 重定向</li>
</ul>
<p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>307 temporary redirect，临时重定向，和302含义相同</p>
<ul>
<li>4XX 客户端错误</li>
</ul>
<p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p>
<ul>
<li>5XX 服务器错误</li>
</ul>
<p>500 internal sever error，表示服务器端在执行请求时发生了错误<br>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>
<blockquote>
<p>作者：yck<br>链接：<a href="https://juejin.im/post/5872309261ff4b005c4580d4">https://juejin.im/post/5872309261ff4b005c4580d4</a><br>来源：掘金</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-19T08:00:00.000Z" title="2019-08-19T08:00:00.000Z">2019-08-19</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">4 分钟 读完 (大约 537 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/19/fe/http%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/">HTTP的缓存机制</a></h1><div class="content"><h4 id="缓存用来做什么？"><a href="#缓存用来做什么？" class="headerlink" title="缓存用来做什么？"></a>缓存用来做什么？</h4><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
<p>缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p>
<p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存只能存储 GET 响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标URI（一般只有GET请求才会被缓存）。</p>
<h4 id="HTTP中的缓存控制"><a href="#HTTP中的缓存控制" class="headerlink" title="HTTP中的缓存控制"></a>HTTP中的缓存控制</h4><p>HTTP/1.1定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况， 请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略。</p>
<ul>
<li>禁止缓存: <code>Cache-Control: no-store</code></li>
<li>强制确认缓存: <code>Cache-Control: no-cache</code></li>
<li>私有缓存和公共缓存: <code>Cache-Control: private/public</code></li>
<li>缓存过期机制: <code>Cache-Control: max-age=31536000</code></li>
<li>缓存验证确认: <code>Cache-Control: must-revalidate</code></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-19T08:00:00.000Z" title="2019-08-19T08:00:00.000Z">2019-08-19</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">13 分钟 读完 (大约 1964 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/19/fe/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-tcp-ip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B/">OSI七层模型&amp;TCP/IP四层模型</a></h1><div class="content"><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器，交换机。<br>OSI七层模型是一种框架性的设计方法，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。</p>
<ul>
<li><strong>物理层（Physical Layer）</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换），这一层的数据叫做比特，单位是bit比特。</li>
<li><strong>数据链路层（Datalink Layer）</strong>：定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问，这一层通常还提供错误检测和纠正，以确保数据的可靠传输。交换机(二层)、网桥设备在这一层。数据链路层协议的代表包括：PPP、STP、帧中继等。</li>
<li><strong>网络层（Network Layer）</strong>：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择，Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。网络层负责在源机器和目标机器之间建立它们所使用的路由。路由器在该层。协议有：IP、ICMP（互联网控制报文协议）、ARP（地址转换协议）、RARP（反向地址转换协议）</li>
<li><strong>传输层（Transport Layer）</strong>：O S I 模型中最重要的一层。定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）， 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，常常把这一层数据叫做段。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。</li>
<li><strong>会话层（Session Layer）</strong>：负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</li>
<li><strong>表示层（Presentation Layer）</strong>：应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　表示层管理数据的解密与加密，如系统口令的处理。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。</li>
<li><strong>应用层（Application Layer）</strong>： 是最靠近用户的OSI层，这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。</li>
</ul>
<h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><p>TCP/IP协议栈是美国国防部高级研究计划局计算机网（Advanced Research Projects Agency Network，ARPANET）和其后继因特网使用的参考模型。ARPANET是由美国国防部（U.S．Department of Defense，DoD）赞助的研究网络。最初，它只连接了美国境内的四所大学。随后的几年中，它通过租用的电话线连接了数百所大学和政府部门。最终ARPANET发展成为全球规模最大的互连网络-因特网。最初的ARPANET于1990年永久性地关闭。</p>
<p>TCP/IP是一组协议的代名词，它还包括许多协议，组成了TCP/IP协议簇。TCP/IP协议簇分为四层，IP位于协议簇的第二层(对应OSI的第三层)，TCP位于协议簇的第三层(对应OSI的第四层)。<br>TCP/IP通讯协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求。这4层分别为：</p>
<ul>
<li>应用层：应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。</li>
<li>传输层：在此层中，它提供了节点间的数据传送服务，如传输控制协议（TCP）、用户数据报协议（UDP）等，TCP和UDP给数据包加入传输数据并把它传输到下一层中，这一层负责传送数据，并且确定数据已被送达并接收。</li>
<li>网络层：负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机（但不检查是否被正确接收），如网际协议（IP）。</li>
<li>网络接口层：对实际的网络媒体的管理，定义如何使用实际网络（如Ethernet、Serial Line等）来传送数据。</li>
</ul>
<p><img src="/media/2018032308260661_hwybit.jpg" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-18T08:00:00.000Z" title="2019-08-18T08:00:00.000Z">2019-08-18</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">9 分钟 读完 (大约 1376 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/18/fe/react-%E7%BB%84%E4%BB%B6%E4%B8%AD-state-%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">React 组件中 state 和生命周期</a></h1><div class="content"><h4 id="React的生命周期图谱"><a href="#React的生命周期图谱" class="headerlink" title="React的生命周期图谱"></a>React的生命周期图谱</h4><p>v16.3和v16.4+版本的生命周期有着比较大的区别，感谢大神制作了一个<a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React生命周期图谱</a> 这里截图说明：</p>
<p><img src="/media/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_jp8yqw.jpg" alt=""></p>
<ul>
<li><p>constructor<br><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p>
<p>在 React 组件挂载之前，会调用它的构造函数。在为 <code>React.Component</code> 子类实现构造函数时，应在其他语句之前前调用 <code>super(props)</code>。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p>
<p>通常，在 React 中，构造函数仅用于以下两种情况：<br>- 通过给 <code>this.state</code> 赋值对象来初始化内部 state。<br>- 为事件处理函数绑定实例<br>在 <code>constructor()</code> 函数中不要调用 <code>setState()</code> 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 <code>this.state</code> 赋值初始 state</p>
</li>
<li><p><code>static getDerivedStateFromProps(props, state)</code></p>
</li>
</ul>
<p><code>getDerivedStateFromProps</code> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p>
<p>此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 <code>&lt;Transition&gt;</code> 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。</p>
<p><strong>请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 UNSAFE_componentWillReceiveProps 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。</strong></p>
<ul>
<li>shouldComponentUpdate</li>
</ul>
<p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p>
<p>当 props 或 state 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p>
<p>此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 <code>PureComponent</code> 组件，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p>
<ul>
<li>getSnapshotBeforeUpdate</li>
</ul>
<p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p>
<p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>
<p>应返回 snapshot 的值（或 <code>null</code>）。</p>
<ul>
<li>componentDidMount</li>
</ul>
<p><code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。</p>
<p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅</p>
<p>你可以在 <code>componentDidMount()</code> 里可以直接调用 <code>setState()</code>。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 <code>constructor()</code> 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理</p>
<ul>
<li>componentDidUpdate</li>
</ul>
<p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</p>
<p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p>
<p>你也可以在 <code>componentDidUpdate()</code> 中直接调用 <code>setState()</code>，但请注意 <strong>它必须被包裹在一个条件语件里</strong> ，正如上述的例子那样进行处理，<strong>否则会导致死循环</strong>。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。</p>
<ul>
<li>componentWillUnmount</li>
</ul>
<p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p>
<p><code>componentWillUnmount()</code> 中不应调用 <code>setState()</code>，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-18T08:00:00.000Z" title="2019-08-18T08:00:00.000Z">2019-08-18</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">2 分钟 读完 (大约 339 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/18/fe/vue-v2-6-10-%E7%9A%84%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/">Vue(v2.6.10)的选项 / 生命周期钩子</a></h1><div class="content"><h4 id="Vue更新版生命周期"><a href="#Vue更新版生命周期" class="headerlink" title="Vue更新版生命周期"></a>Vue更新版生命周期</h4><p>截止v2.6.10版本，Vue相关的选项/生命周期共有11个：</p>
<ul>
<li>beforeCreate</li>
<li>created</li>
<li>beforeMount</li>
<li>mounted</li>
<li>beforeUpdate</li>
<li>updated</li>
<li>activated</li>
<li>deactivated</li>
<li>beforeDestroy</li>
<li>destroyed</li>
<li>errorCaptured</li>
</ul>
<h4 id="生命周期顺序："><a href="#生命周期顺序：" class="headerlink" title="生命周期顺序："></a>生命周期顺序：</h4><p>初始化生命周期和方法 -&gt; <strong>beforeCreate</strong> -&gt; 初始化依赖注入和响应式 -&gt; <strong>created</strong> -&gt; 模板解析编译 -&gt; <strong>beforeMount</strong> -&gt; 创建element节点 -&gt; <strong>mounted</strong> -&gt; 如果数据被更新 -&gt; <strong>updated</strong> -&gt; 触发重新渲染和patch (-&gt; 如果数据继续更新 -&gt; <strong>beforeUpdate</strong> -&gt; 调用<code>destroy</code>方法 -&gt; <strong>beforeDestroy</strong> -&gt; 销毁子节点&amp;watcher&amp;事件监听 -&gt; <strong>destroyed</strong></p>
<ul>
<li><p>activated<br>keep-alive 组件激活时调用。<br>该钩子在服务器端渲染期间不被调用。</p>
</li>
<li><p>deactivated<br>keep-alive 组件停用时调用。<br>该钩子在服务器端渲染期间不被调用。</p>
</li>
<li><p>errorCaptured<br>  <strong>2.5.0+ 新增</strong><br>  当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
</li>
</ul>
<blockquote>
<p>这里提一下<code>keep-alive</code>, 这是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。当组件在<code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和<code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-18T08:00:00.000Z" title="2019-08-18T08:00:00.000Z">2019-08-18</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">16 分钟 读完 (大约 2401 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/18/fe/%E5%89%8D%E7%AB%AF%E7%9C%8Bhttp/">前端看HTTP</a></h1><div class="content"><h4 id="HTTP是什么"><a href="#HTTP是什么" class="headerlink" title="HTTP是什么"></a>HTTP是什么</h4><p>HTTP (超文本传输协议) 是用来在 Web 上传输文件的 <strong>基础协议</strong> ，基于 <strong>TCP/IP通信协议</strong> 来传递数据，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们。目前HTTP说明文档的版本是HTTP/2。</p>
<p>HTTPS 是 HTTP 协议的安全版本，HTTPS <strong>在 HTTP 上加入套接字 SSL（TLS 为 SSL 最新版）层</strong> ，对网页进行加密传输。</p>
<p>HTTP 是 <strong>基于文本</strong> (所有的通信都是以纯文本的形式进行) 以及 <strong>无状态的 (当前通信不会发现以前的通信状态)</strong> 。这个特点对在www上访问网页的人是很理想的。而且，HTTP也可以让网站更加的灵活多变，利用在AJAX上等。</p>
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 <strong>URL是一种特殊类型的 URI</strong> 。</p>
<p>HTTP是用于传输诸如HTML的超媒体文档的 <strong>应用层</strong> 协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。 HTTP遵循经典的 <strong>客户端-服务端模型</strong> ，客户端打开一个连接以发出请求，然后等待它收到服务器端响应。 HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。该协议虽然通常基于TCP / IP层，但可以在任何可靠的传输层上使用；也就是说，一个不会像UDP协议那样静默丢失消息的协议。RUDP作为UDP的可靠的升级版本，是一种合适的替代选择。</p>
<h4 id="通过定义能够知道的特点"><a href="#通过定义能够知道的特点" class="headerlink" title="通过定义能够知道的特点"></a>通过定义能够知道的特点</h4><ol>
<li>基于TCP/IP通信协议<br>这部分的知识稍后开篇来讲</li>
<li>HTTP位于应用层<br>这部分的知识稍后开篇来讲</li>
<li>遵循客户端-服务端模型<br>C/S(客户端/服务器)模型，是常用的服务器模型，包括现在说的B/S(浏览器/客户端)模型，都是对C/S结构的一种变化或者改进的结构。 TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有服务器都是对等的。但由于资源被数据提供者所垄断，于是产生了C/S模型：所有客户端都通过服务器获取所需资源。</li>
<li>无状态<br>这里需要区分一下两个概念：<ul>
<li><strong>无连接</strong>：每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</li>
<li><strong>无状态</strong>：是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</li>
</ul>
</li>
</ol>
<p>在后续的Web发展中需要带有一定的状态，则通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p>
<h4 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h4><h5 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS"></a>什么是HTTPS</h5><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。</p>
<h5 id="HTTPS加密机制"><a href="#HTTPS加密机制" class="headerlink" title="HTTPS加密机制"></a>HTTPS加密机制</h5><p>HTTP中没有加密机制，可以通过 <strong>SSL（Secure Socket Layer 安全套接层）</strong> 或 <strong>TLS（Transport Layer Security 安全层传输协议）</strong> 的组合使用，加密HTTP的通信内容。</p>
<p>HTTPS是 HTTP Secure 或 HTTP over SSL。</p>
<p>SSL（Security Socket Layer）是最初由网景公司（NetScape）为了保障网上交易安全而开发的协议，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。网景公司开发过SSL3.0之前的版本；目前主导权已转移给IETF（Internet Engineering Task Force），IETF以SSL3.0为原型，标准化并制定了TSL1.0，TLS1.1，TLS1.2。但 <strong>目前主流的还是SSL3.0和TSL1.0</strong> 。</p>
<p>SSL工作在 <strong>OSI七层模型中的表示层</strong> ，<strong>TCP/IP 四层模型的应用层</strong> 。</p>
<p>SSL 和 TLS 可以作为基础协议的一部分（对应用透明），也可以嵌入在特定的软件包中（比如Web服务器中的实现）。</p>
<p>SSL 基于TCP，SSL不是简单地单个协议，而是两层协议；SSL记录协议（SSL Record Protocol）为多种高层协议（SSL握手协议，SSL修改密码参数协议，SSL报警协议）提供基本的安全服务。HTTP是为Web客户端/服务器交互提供传输服务的，它可以在SSL的顶层运行；SSL记录协议为SSL链接提供两种服务，机密性：握手协议定义了一个共享密钥，用于SSL载荷的对称加密。 消息完整性：握手协议还定义了一个共享密钥，它用来产生一个消息认证码（Message Authentication Code，MAC）。</p>
<p>SSL/TLS握手阶段分为五步(假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程)：<br>以下引自 <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰的网络日志</a></p>
<ul>
<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>
<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>
<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ul>
<p>直白解释，在HTTPS使用时，客户端首先发起请求，服务端返回证书，客户端确认无误后，选择对应的公钥开始加密，服务端接收到数据后开始使用服务器的私钥解密。</p>
<h4 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h4><p>HTTP 消息头允许客户端和服务器通过 request和 response传递附加信息。一个请求头由名称（不区分大小写）后跟一个冒号“：”，冒号后跟具体的值（不带换行符）组成。该值前面的引导空白会被忽略。</p>
<p>根据不同上下文，可将消息头分为：</p>
<ul>
<li>一般头: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。</li>
<li>请求头: 包含更多有关要获取的资源或客户端本身信息的消息头。</li>
<li>响应头: 包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。</li>
<li>实体头: 包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。</li>
</ul>
<p>常用的头部主要有：</p>
<table>
<thead>
<tr>
<th>应答头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Length</td>
<td>表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>
</tr>
<tr>
<td>Expires</td>
<td>应该在什么时候认为文档已经过期，从而不再缓存它</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-16T08:00:00.000Z" title="2019-08-16T08:00:00.000Z">2019-08-16</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">4 分钟 读完 (大约 604 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/16/fe/meta%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%BF%E7%94%A8/">meta标签的使用</a></h1><div class="content"><p>平时使用时最常见的用法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是通过meta我们可以实现很多特别的功能。</p>
<h4 id="meta是什么"><a href="#meta是什么" class="headerlink" title="meta是什么"></a>meta是什么</h4><blockquote>
<p>The <meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.</p>
</blockquote>
<p>换句话来说，就是页面里对用户不可见，但是可供浏览器解析的页面信息。</p>
<h4 id="meta的类型"><a href="#meta的类型" class="headerlink" title="meta的类型"></a>meta的类型</h4><h5 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h5><p>这一类使用格式为<code>&lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;</code></p>
<ul>
<li><p>content-Type<br>可以设置html的字符集和格式，但是被<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>取代</p>
</li>
<li><p>X-UA-Compatible<br>设置浏览器渲染模式，一般采取最新的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cache-control<br>设置浏览器缓存，一般设置为<code>&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;</code><br>可设置为以下属性：</p>
<ul>
<li>no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。</li>
<li>no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）</li>
<li>public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果</li>
<li>private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）</li>
<li>maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。</li>
<li>no-siteapp: 禁止百度默认的移动端转码。</li>
</ul>
</li>
<li><p>expires<br>设置网页过期时间，超时需要重新从服务器获取。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"Sunday 26 October 2016 01:00 GMT"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>refresh<br>网页将在设定的时间内，自动刷新并调向设定的网址。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"2;URL=https://blog.sparkinglemon.me"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>设置为2s后自动转向到网址</p>
</li>
<li><p>Set-Cookie<br>配置页面cookie</p>
</li>
</ul>
<h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><p>name属性的配置格式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"参数"</span> <span class="attr">content</span>=<span class="string">"具体的描述"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>keywords<br>设置页面关键词，SEO收录常用</p>
</li>
<li><p>description<br>页面描述，SEO常用</p>
</li>
<li><p>viewport<br><strong>移动端</strong> 设置视口。后续会在移动端适配详细补充。</p>
</li>
<li><p>robots<br>告知爬虫具体需要爬取的页面，默认是all ，可以设置none，noindex（非本页），nofollow（通过本页索引其他页）</p>
</li>
<li><p>author<br>页面作者，不常用</p>
</li>
<li><p>generator<br>页面制作于</p>
</li>
<li><p>copyright<br>页面版权信息</p>
</li>
<li><p>revisit-after<br>设置爬虫重访时间</p>
</li>
</ul>
<blockquote>
<p>部分内容参考了 <a href="https://segmentfault.com/a/1190000004279791">Lxxyx-“HTML meta标签总结与属性使用介绍”</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-16T08:00:00.000Z" title="2019-08-16T08:00:00.000Z">2019-08-16</time><span class="level-item"><a class="link-muted" href="/categories/Frontend/">Frontend</a></span><span class="level-item">1 分钟 读完 (大约 168 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/16/fe/script%E6%A0%87%E7%AD%BE%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95/">script标签有几种写法</a></h1><div class="content"><h4 id="script-标签有哪些属性"><a href="#script-标签有哪些属性" class="headerlink" title="script 标签有哪些属性"></a>script 标签有哪些属性</h4><ul>
<li>async</li>
<li>defer</li>
<li>integrity</li>
<li>src</li>
<li>type</li>
<li>text</li>
<li>crossorigin</li>
</ul>
<p>区别如下</p>
<p><img src="/media/16285181c4ab990d_goqvkh.png" alt=""></p>
<p>如图可知，async不影响页面解析过程，但是加载完成执行过程会终止parsing；<br>而defer是在过程中加载，等到页面解析完成后才执行。</p>
<p><strong>要注意，async无法确定顺序，比较适合不依赖dom结构的，而defer则是顺序执行</strong></p>
<h4 id="其他的方式"><a href="#其他的方式" class="headerlink" title="其他的方式"></a>其他的方式</h4><ol>
<li>动态创建script标签</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"file1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>

<p>动态创建的script无论在何时执行创建，其源js均会在最后执行</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Frontend/page/2/">上一页</a></div><div class="pagination-next"><a href="/categories/Frontend/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Frontend/">1</a></li><li><a class="pagination-link" href="/categories/Frontend/page/2/">2</a></li><li><a class="pagination-link is-current" href="/categories/Frontend/page/3/">3</a></li><li><a class="pagination-link" href="/categories/Frontend/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/assets/avatar.png" alt="Sparkling"></figure><p class="title is-size-4 is-block line-height-inherit">Sparkling</p><p class="is-size-6 is-block">Technology sparks fun</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">3</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">32</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/SparklingFun"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://blog.zhangruipeng.me/hexo-theme-icarus/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Icarus Theme</span></span><span class="level-right"><span class="level-item tag">blog.zhangruipeng.me</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Frontend/"><span class="level-start"><span class="level-item">Frontend</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Life/"><span class="level-start"><span class="level-item">Life</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Other/"><span class="level-start"><span class="level-item">Other</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-22T09:05:52.000Z">2020-07-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/22/other/webhook-cloudflare-worker/">Webhook联动Cloudflare Worker实现博客</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T00:34:26.000Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/other/rm2100-ax200-ping/">红米RM2100+AX200诡异跳ping问题</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-07T08:22:15.000Z">2020-05-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/07/other/sentry-%E4%B8%80%E7%AB%99%E5%BC%8F%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/">Sentry——一站式错误监控平台部署记录</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-21T22:44:42.000Z">2020-04-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/21/other/%E5%88%A9%E7%94%A8wsl%E5%9C%A8windows%E4%B8%8B%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/">利用WSL在Windows下获得更好的开发体验</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Other/">Other</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-21T06:27:05.000Z">2020-04-21</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/21/fe/vue-3-0-beta-b%E7%AB%99%E7%9B%B4%E6%92%AD%E5%86%85%E5%AE%B9%E9%80%9F%E8%AE%B0/">&quot;Vue 3.0 Beta&quot;B站直播内容速记</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Frontend/">Frontend</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/CSS/"><span class="tag">CSS</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CentOS/"><span class="tag">CentOS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CheatSheet/"><span class="tag">CheatSheet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cheatsheet/"><span class="tag">Cheatsheet</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Frontend/"><span class="tag">Frontend</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTTP/"><span class="tag">HTTP</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Javascript/"><span class="tag">Javascript</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Log/"><span class="tag">Log</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NPM/"><span class="tag">NPM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PWA/"><span class="tag">PWA</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/React-js/"><span class="tag">React.js</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Safari/"><span class="tag">Safari</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/TCP/"><span class="tag">TCP</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VPS/"><span class="tag">VPS</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue-js/"><span class="tag">Vue.js</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WSL/"><span class="tag">WSL</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%8D%E8%A7%81/"><span class="tag">再见</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"><span class="tag">前端工程化</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E4%BD%9C/"><span class="tag">工作</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD/"><span class="tag">性能</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B5%8B%E8%AF%95/"><span class="tag">测试</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A6%BB%E5%88%AB/"><span class="tag">离别</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%B0%E5%BD%95/"><span class="tag">记录</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"><span class="tag">路由器</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%BC%8F/"><span class="tag">软件模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tag">面试题</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">柠檬汽水🍋</a><p class="size-small"><span>&copy; 2020 Sparkling</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://blog.sparkling.land',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>